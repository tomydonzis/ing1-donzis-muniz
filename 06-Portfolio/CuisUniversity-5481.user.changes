

----QUIT----(11 September 2022 19:10:09) CuisUniversity-5481.image priorSource: 2810882!

----STARTUP---- (11 September 2022 19:10:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5481.image!


----QUIT----(11 September 2022 19:10:10) CuisUniversity-5481.image priorSource: 7059465!

----STARTUP---- (29 September 2022 19:14:36) as /home/clinux01/Descargas/linux64 (2)/CuisUniversity-5481.image!


----End fileIn of /home/clinux01/Escritorio/linux64/Character-asRot13.st----!

----End fileIn of /home/clinux01/Escritorio/TDDBabyStepsGame.st----!

TDDBabyStepsGameRot13 start.!

!classDefinition: #TDDBabyStepsRot13Test category: 'TDDBabyStepsGameRot13' stamp: 'TD 9/29/2022 19:15:58'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:16:04'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:04'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:04'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:16:04'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:04'!
ERROR!
!Character methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:16:38' prior: 50552275!
asRot13
	^$n.! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:46'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:16:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:46'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:16:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:16:46'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:17:27' prior: 50554055!
asRot13
	(self = $a) ifTrue: [^$n].
	^$z.! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:31'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:17:31'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:32'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:32'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:17:32'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:17:32'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:18:00' prior: 50554096!
asRot13
	((self isInRangeFrom: $a and: $m) or: 
	[self isInRangeFrom: $A and: $M]) ifTrue: [^Character asciiValue: (self asciiValue + 13)].
	
	((self isInRangeFrom: $n and: $z) or: 
	[self isInRangeFrom: $N and: $Z]) ifTrue: [^Character asciiValue: (self asciiValue - 13)].! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:18:04'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:18:04'!
ERROR!
!Character methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:18:09'!
isInRangeFrom: aCharacter and: aCharacter2 
	self shouldBeImplemented.! !
!Character methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:19:07' prior: 50554162!
isInRangeFrom: aLowerBound and: anUpperBound
	^self asciiValue between: (aLowerBound asciiValue) and: (anUpperBound asciiValue)
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:19'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:19'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:19'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:19'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:21'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:21'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:22'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:22'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:28'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:28'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:19:28'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:28'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:29'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:30'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:19:30'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:19:30'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:19:31'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:19:31'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:19:34'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:19:34'!
ERROR!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:19:50'!
asRot13
	self shouldBeImplemented.! !
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:20:07' prior: 50554460!
asRot13
	^''.! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:20:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:20:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:20:10'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:20:10'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:20:10'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:20:10'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:20:10'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:20:10'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:20:28'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:20:55' prior: 50554464!
asRot13
	^self at: 1 put: (self at: 1) asRot.! !
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:20:59' prior: 50554547!
asRot13
	^self at: 1 put: (self at: 1) asRot13.! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:21:00'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:21:14' prior: 50554552!
asRot13
	self at: 1 put: (self at: 1) asRot13.! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:21:15'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:21:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:21:35'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:21:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:21:38'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:21:38'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:21:44'!
ERROR!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:22:45' prior: 50554560!
asRot13
	(self = '') ifFalse: [
		self at: 1 put: (self at: 1) asRot13.
	].! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:22:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:22:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:22:53'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:22:55'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:22:55'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:22:58'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:22:58'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:22:58'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:00'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:02'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:03'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:04'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:05'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:07'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:23:44' prior: 50554619!
asRot13
	(self = '') ifFalse: [self collect: [:char | char asRot13]	].! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:48'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:23:48'!
FAILURE!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:24:08' prior: 50554530!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:09'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:09'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:12'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:12'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:21'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:30'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:24:54' prior: 50554707!
asRot13
	self collect: [:char | char asRot13]! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:24:55'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:08'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13' stamp: 'TD 9/29/2022 19:25:19' prior: 50554751!
asRot13
	^self collect: [:char | char asRot13]! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:29'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:25:29'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:29'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:29'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:39'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:25:39'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:45'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:47'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:25:47'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TD 9/29/2022 19:25:47'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TD 9/29/2022 19:25:47'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:48'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:25:48'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TD 9/29/2022 19:25:48'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TD 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'TD 9/29/2022 19:25:51'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'TD 9/29/2022 19:25:51'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'TD 9/29/2022 19:25:51'!
PASSED!

TDDBabyStepsGamePrimeFactors start.!

!classDefinition: #TDDBabyStepsPrimeFactorsTest category: 'TDDBabyStepsGamePrimeFactors' stamp: 'TD 9/29/2022 19:26:04'!
TestCase subclass: #TDDBabyStepsPrimeFactorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGamePrimeFactors'!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:26:33'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:26:33'!
ERROR!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:26:33'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:26:33'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:26:33'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:26:47'!
ERROR!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:27:16'!
factorize
	self shouldBeImplemented.! !
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:27:36' prior: 50555135!
factorize
	^Bag new.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:27:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:27:38'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:27:41'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:27:41'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:27:41'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:27:41'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:27:41'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:27:41'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:27:56'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:02'!
FAILURE!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:28:48' prior: 50555140!
factorize
	(self = 2) ifTrue: [^Bag with: 2].
	^Bag new.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:49'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:28:49'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:49'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:28:52'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:52'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:28:52'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:52'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:52'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:28:52'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:28:52'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:29:38'!
FAILURE!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:30:11' prior: 50555190!
factorize
	(self = 2) ifTrue: [^Bag with: 2].
	(self = 3) ifTrue: [^Bag with: 3].
	^Bag new.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:30:19'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:30:19'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:30:19'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:30:19'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:30:21'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:30:21'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:30:21'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:30:21'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:30:21'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:30:21'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:30:21'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:30:21'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:30:48'!
FAILURE!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:47:33' prior: 50555246!
factorize
	|primeFactorsBag aDivisor theDividend|
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	(theDividend > 1) whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:47:35'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:47:51'!
ERROR!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:48:25' prior: 50555314!
factorize
	|primeFactorsBag aDivisor theDividend|
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[(theDividend > 1)] whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag.! !
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:48:28' prior: 50555338!
factorize
	|primeFactorsBag aDivisor theDividend|
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[theDividend > 1] whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:48:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:48:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:48:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:48:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:48:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:48:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:48:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:48:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:48:34'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:48:34'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:48:34'!
PASSED!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:48:34'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:52:12' prior: 50555353!
factorize
	(self = 1) ifTrue: [^Bag new].
	(self = 2) ifTrue: [^Bag with: 2].
	(self = 3) ifTrue: [^Bag with: 3].
	(self = 4) ifTrue: [^Bag with: 2 with: 2].
	"|primeFactorsBag aDivisor theDividend|
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[theDividend > 1] whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag."! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:52:17'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:52:17'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:52:17'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:52:17'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:52:17'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:52:17'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:52:17'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:52:17'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:52:17'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:52:34'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:52:38'!
FAILURE!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:53:03' prior: 50555424!
factorize
	(self = 1) ifTrue: [^Bag new].
	(self = 2) ifTrue: [^Bag with: 2].
	(self = 3) ifTrue: [^Bag with: 3].
	(self = 4) ifTrue: [^Bag with: 2 with: 2].
	(self = 8) ifTrue: [^Bag with: 2 with: 2 with: 2].
	"|primeFactorsBag aDivisor theDividend|
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[theDividend > 1] whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag."! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:53:05'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:53:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:53:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:53:07'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:53:07'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:07'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:07'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:53:07'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:07'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:14'!
FAILURE!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:14'!
FAILURE!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:53:30' prior: 50555502!
factorize
	|primeFactorsBag aDivisor theDividend|
	
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[theDividend > 1] whileTrue: [	
		(aDivisor isPrime and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:35'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:53:37'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 19:53:37'!
testExtraToCheckGeneralizationOnKata
	
	self assert: (Bag with: 2 with: 2 with: 3 with: 3 with: 5 with: 13) equals: (2*2*3*3*5*13) factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #testExtraToCheckGeneralizationOnKata stamp: 'TD 9/29/2022 19:53:37'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 19:54:54'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #testExtraToCheckGeneralizationOnKata stamp: 'TD 9/29/2022 19:54:54'!
PASSED!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:59:11' prior: 50555613!
factorize
	|primeFactorsBag aDivisor theDividend|
	
	primeFactorsBag := Bag new.
	aDivisor := 2.
	theDividend := self.
	[theDividend > 1] whileTrue: [	
		(aDivisor esPrimo and:[theDividend isDivisibleBy: aDivisor]) ifTrue: [
			 primeFactorsBag add: aDivisor.
			 theDividend := theDividend / aDivisor.
	] ifFalse: [
		aDivisor := aDivisor + 1].
	].

	^primeFactorsBag.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'TD 9/29/2022 19:59:15'!
ERROR!
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 19:59:21'!
esPrimo
	self shouldBeImplemented.! !
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 20:01:09' prior: 50555728!
esPrimo
	2 to: self - 1 do: [:aDivisor | (self isDivisibleBy: aDivisor) ifTrue: [^true]].
	^false.! !
!SmallInteger methodsFor: '*TDDBabyStepsPrimeFactors' stamp: 'TD 9/29/2022 20:01:41' prior: 50555733!
esPrimo
	2 to: self - 1 do: [:aDivisor | (self isDivisibleBy: aDivisor) ifTrue: [^false]].
	^true.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'TD 9/29/2022 20:01:58'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #testExtraToCheckGeneralizationOnKata stamp: 'TD 9/29/2022 20:02:00'!
PASSED!

TDDBabyStepsGameAnagrams start.!

!classDefinition: #TDDBabyStepsAnagramsTest category: 'TDDBabyStepsGameAnagrams' stamp: 'TD 9/29/2022 20:04:59'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:09:41'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:09:41'!
ERROR!

!methodRemoval: TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:09:41'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:09:41'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:09:41'!
ERROR!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:09:55'!
ERROR!
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:10:09'!
anagrams
	self shouldBeImplemented.! !
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:10:19' prior: 50555798!
anagrams
	^''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:10:21'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:10:28'!
FAILURE!
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:10:39' prior: 50555803!
anagrams
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:10:40'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:10:40'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:10:45'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:10:45'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:10:45'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:10:45'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:10:45'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:10:45'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:10:59'!
FAILURE!
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:11:53' prior: 50555816!
anagrams
	(self = 'a') ifTrue: [^Set with: 'a'].
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:12:12'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:12:12'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:12:12'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:12:15'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:12:15'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:12:15'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:12:15'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:12:15'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:12:15'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:12:15'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:12:30'!
FAILURE!
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:24:50' prior: 50555870!
anagrams
	(self = 'a') ifTrue: [^Set with: 'a'].
	^Set with: ''.! !
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:25:35' prior: 50555935!
anagrams
	(self size = 1) ifTrue: [^Set with: self].
	^Set with: ''.! !
!String methodsFor: '*TDDBabyStepsAnagrams' stamp: 'TD 9/29/2022 20:26:52' prior: 50555940!
anagrams
	(self size = 2) ifTrue: [^Set with: self with: (self reversed)].
	(self size = 1) ifTrue: [^Set with: self].
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:26:54'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:26:54'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:26:54'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:26:54'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'TD 9/29/2022 20:26:59'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'TD 9/29/2022 20:26:59'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'TD 9/29/2022 20:26:59'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:26:59'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TD 9/29/2022 20:26:59'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TD 9/29/2022 20:26:59'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'TD 9/29/2022 20:26:59'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TD 9/29/2022 20:26:59'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'TD 9/29/2022 20:27:42'!
FAILURE!

----End fileIn of /home/clinux01/Descargas/linux64 (2)/Packages/TerseGuide.pck.st----!
| game |
game  := TDDBabyStepsGameCuentaBancaria start.
game openHelp.
game openDefinition.
game next.!
| game |
game  := TDDBabyStepsGameContador start.
game openHelp.
game openDefinition.
game next.!
| game |
game  := TDDBabyStepsGameCuentaBancaria start.
game openHelp.
game openDefinition.
game next.!
| game |
game  := TDDBabyStepsGameDemo start.
game openHelp.
game openDefinition.
game next.!
| game |
game  := TDDBabyStepsGameCuentaBancaria start.
game openHelp.
game openDefinition.
game next.!
| game |
game  := TDDBabyStepsGameCuentaBancaria start.
game openHelp.
game openDefinition.
game next.!

----STARTUP---- (6 October 2022 17:46:58) as /home/clinux01/Descargas/linux64 (2)/CuisUniversity-5481.image!


----End fileIn of /home/clinux01/Escritorio/Portfolio-Ejercicio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:24:08'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:24:08'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:24:08'!
FAILURE!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:24:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:34:03'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:34:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:34:03'!
FAILURE!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 20:35:18' prior: 50552301!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:35:20'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:35:20'!
FAILURE!

self balance!

self balance!
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 20:38:09' prior: 50552441 overrides: 50552370!
value

	^ value * -1! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:38:12'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:38:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:38:12'!
FAILURE!
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 20:38:23' prior: 50552581 overrides: 50552370!
value

	^ value * (-1)! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:38:25'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:38:25'!
FAILURE!
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 20:38:56' prior: 50552615 overrides: 50552370!
value

	^ value! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 20:40:40' prior: 50552485!
balance

	^transactions sum: [ :aTransaction | 
		(aTransaction isKindOf: Withdraw) ifTrue: [(aTransaction value) * (-1)]
		ifFalse: [aTransaction value]
		] ifEmpty: [ 0 ]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:40:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:40:43'!
PASSED!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 20:42:12' prior: 50552653!
balance

	^transactions sum: [ :aTransaction | aTransaction impactOnBalance] ifEmpty: [ 0 ]! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:42:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:17'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:17'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:42:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:42:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:42:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:42:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:19'!
ERROR!
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 20:42:25'!
impactOnBalance
	self shouldBeImplemented.! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 20:42:33' prior: 50552723!
impactOnBalance
	self subclassResponsibility.! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 20:42:43' prior: 50552727!
impactOnBalance
	^value.! !

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:45'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:46'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:46'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:42:46'!
ERROR!
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 20:42:51'!
impactOnBalance
	self shouldBeImplemented.! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 20:43:01' prior: 50552768!
impactOnBalance
	^value * (-1)! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:43:04'!
PASSED!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 20:43:13'!
impactOnBalance

	self subclassResponsibility ! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:43:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:43:15'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:01' prior: 50552481!
transactions 

	^ transactions copy copy copy copy copy! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:46:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:46:02'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:17' prior: 50552811!
transactions 

	^ transactions copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy copy! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 20:46:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 20:46:18'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:25' prior: 50552843!
transactions 

	^ transactions copy! !

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:01:29'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:29' prior: 50552408 overrides: 50552370!
value

	^ amount! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:29' prior: 50552403!
initializeFor: aValue

	amount := aValue ! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:29' prior: 50552731 overrides: 50552780!
impactOnBalance
	^amount.! !

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:01:37'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:37' prior: 50552649 overrides: 50552370!
value

	^ amount! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:37' prior: 50552436!
initializeFor: aValue

	amount := aValue ! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:01:37' prior: 50552772 overrides: 50552780!
impactOnBalance
	^amount * (-1)! !

AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:01:48'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:01:51'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:01:54'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:02:04' prior: 50552370 overrides: 16902254!
value

	^ amount! !

!methodRemoval: Withdraw #value stamp: 'TD 10/6/2022 21:02:04'!
value

	^ amount!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:02:09' prior: 50552964 overrides: 16902254!
value

	^ amount! !

!methodRemoval: Deposit #value stamp: 'TD 10/6/2022 21:02:09'!
value

	^ amount!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:02:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:02:10'!
PASSED!
!Withdraw methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:22' prior: 50552917!
initializeFor: anAmount

	amount := anAmount ! !
!Deposit methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:28' prior: 50552895!
initializeFor: anAmount

	amount := anAmount ! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:03:38' prior: 50552688!
balance
	|balanceSum|
	balanceSum := 0.
	^transactions do: [ :aTransaction | balanceSum + aTransaction impactOnBalance]! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:03:48' prior: 50553014!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum + aTransaction impactOnBalance].
	^balanceSum.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:03:49'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:03:49'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:03:49'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:03:49'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:03:49'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:03:49'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:03:49'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:03:51'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:04:07' prior: 50553021!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum + (aTransaction impactOnBalance)].
	^balanceSum.! !
!Object methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36'!
transactionAmount

	^self! !
!MessageSend methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)! !
!WeakMessageSend methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]! !
!Association methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	"Answer the value of the receiver."
	^value! !
!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	^value! !
!WeakValueAssociation methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	^self at: 1! !
!FilteredGregorianDate methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^date
! !
!RelativeGregorianDate methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^self absoluteDate! !
!BlockClosure methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>
	| newContext |
	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	false
		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."
			[newContext := self asContextWithSender: thisContext sender.
			thisContext privSender: newContext]
		ifFalse: [self primitiveFailed]! !
!WeakActionSequence methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1! !
!AssignmentNode methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	^ value! !
!MessageSendingBlocksVariablesToExtractFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract! !
!VariablesToExtractFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	self 
		calculateSendersInfo;
		groupSendersByType;
		createMessageList ! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender methodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends! !
!MethodTypeCheckerVisitor methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	self 
		prepareToValue;
		visitMethodNode: methodNode.	
! !
!CodeCoverageSourceCodeGenerator methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."

	methodNode accept: self.
	
	tracedSourceCode :=  String streamContents: [ :stream | methodNode printOn: stream ] .
	
	! !
!Preference methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!DropFilesAction methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
! !
!ProgressiveTestRunner methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	Utilities authorInitials.
	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!CodeCoverageTest methodsFor: 'test objects' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super value! !
!ClassReferencesCollector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	! !
!ExtractMethodParametersDetector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	| parseNodesFound |
	parseNodesFound := OrderedCollection new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]
	].
	^ parseNodesFound! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollection new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 ! !
!RefactoringApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553302!
transactionAmount

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]! !
!ExtractMethodApplier methodsFor: 'value' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553302!
transactionAmount

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553302!
transactionAmount

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!ExtractToMethodObjectApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553302!
transactionAmount

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!IntroduceNullObjectApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553302!
transactionAmount

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!RefactoringPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	self subclassResponsibility! !
!NewClassPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

! !
!NewGlobalPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

! !
!NewInstanceVariablePrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.! !
!NewSelectorPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy! !
!NewTemporaryPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes! !
!SourceCodeIntervalPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553374!
transactionAmount

	self subclassResponsibility! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553433!
transactionAmount

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression! !
!SourceCodeOfTemporaryToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553433!
transactionAmount

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes! !
!ArgumentsAndReturnsFinder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
! !
!IfNilChecksFinder methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!ReturnStatementAdder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	! !
!SubstringMatcher methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^ resultsSorter value: (self filterCollection asOrderedCollection)! !
!CatalogButton methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	
	model changeSelectedCatalog: catalog! !
!ActualImplementorsFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	self subclassResponsibility ! !
!AllActualImplementors methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553519!
transactionAmount 

	| typeImplementors |
	
	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553519!
transactionAmount
	
	notImplemented := OrderedCollection new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!TypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	
	self subclassResponsibility! !
!ManyMethodsTypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553557!
transactionAmount
	
	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].
	
	^self! !
!MethodTypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553557!
transactionAmount

	self 
		initializeErrorsWarningsAndProblems;
		typeCheck.
			
	^self! !
!Collaborator methodsFor: 'value' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^owner instVarNamed: name! !
!Delegator methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
! !
!CompiledMethodCoverageReportBuilder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults.! !
!CodeCoverageAnalyzerBuilder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze! !
!Evaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	self subclassResponsibility! !
!CachedEvaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553612!
transactionAmount

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue! !
!DummyEvaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553612!
transactionAmount

	^measure! !
!TopologicalSort methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result! !
!GregorianTimespan methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^self class from: from value duration: duration! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:04:36' overrides: 50553066!
transactionAmount

	^ amount! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16805633!
methodsWithoutComments
	"Return a collection representing methods in the receiver which have no precode comments"

	| slips |
	slips _ OrderedCollection new.
	self changedClasses do:
		[:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: 
				[:mAssoc | (#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc transactionAmount) ifFalse:
					[(aClass selectors includes:  mAssoc key) ifTrue:
						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutComments) name: 'methods lacking comments'
	"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533520 overrides: 50533145!
odd
	
	^self transactionAmount odd! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16796825!
renameGlobal
	
	(RenameGlobalApplier on: self for: '') transactionAmount! !
!ClassReferencesCollector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16816166!
valueOf: aClassToLookForReferences

	^(self of: aClassToLookForReferences) transactionAmount! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50496544 overrides: 50496276!
typeInfoOf: anInstVarName ifAbsent: anAbsentBlock

	(class definesInstanceVariableNamedInHierarchy: anInstVarName) ifFalse:[ ^anAbsentBlock transactionAmount ].
	
	^ self typeInfoInHierarchyOf: anInstVarName! !
!ReadOnlyVariableBinding methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16922405 overrides: 16881493!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' ->(ReadOnlyVariableBinding) ';
		print: self transactionAmount.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50512724!
optimizedMessage
	
	1 to: 10 do: [ :number | number transactionAmount ]! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16839398!
rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext
	"Answer the indices in the source code for the supplied pc.
	 If the context is the actve context (is at the hot end of the stack)
	 then its pc is the current pc.  But if the context isn't, because it is
	 suspended sending a message, then its current pc is the previous pc."

	| pc end |
	pc _ self method abstractPCForConcretePC:
		(contextIsActiveContext
			ifTrue: [ contextsConcretePC ]
			ifFalse: [
				(self method pcPreviousTo: contextsConcretePC) ifNil: [ contextsConcretePC ]]).
	(self abstractSourceMap includesKey: pc) ifTrue: [
		^self abstractSourceMap at: pc].
	sortedSourceMap ifNil: [
		sortedSourceMap _ self abstractSourceMap.
		sortedSourceMap _ (sortedSourceMap keys
			collect: [ :key | key -> (sortedSourceMap at: key)])
				asSortedCollection ].
	sortedSourceMap
		findBinaryIndex: [ :assoc | pc - assoc key ]
		do: [ :i | ^(sortedSourceMap at: i) transactionAmount ]
		ifNone: [ :lower :upper |
			lower = 0 ifTrue: [ ^1 to: 0 ].
			upper <= sortedSourceMap size ifTrue: [
				^(sortedSourceMap at: upper) transactionAmount ].    "No match, but  a nearby element."
			end _ sortedSourceMap detectMax: [ :each |
				each transactionAmount last ].
			end _ end transactionAmount last.
			^end + 1 to: end ].

	"| method source scanner map |
	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.
	method := Debugger >> #pcRange.
	source := method getSourceFromFile asString.
	scanner := InstructionStream on: method.
	map := method debuggerMap.
	Array streamContents:
		[:ranges|
		[scanner atEnd] whileFalse:
			[| range |
			 range := map rangeForPC: scanner pc contextIsActiveContext: true.
			 ((map abstractSourceMap includesKey: scanner abstractPC)
			  and: [range first ~= 0]) ifTrue:
				[ranges nextPut: (source copyFrom: range first to: range last)].
			scanner interpretNextInstructionFor: InstructionClient new]]"! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16902421!
triggerEvent: anEventSelector
	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."

	^(self actionForEvent: anEventSelector) transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50463235!
testSample05
	| blockClosure materialized |
	blockClosure _ self bc05.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure transactionAmount = materialized transactionAmount.
	self assert: blockClosure transactionAmount = materialized transactionAmount.
	self assert: blockClosure transactionAmount = materialized transactionAmount.! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50371060!
declareTemporaries: temporariesToDeclare in: aMethodOrBlockNode of: aSenderMethod

	| positionToInsertNewVariablesDeclarations renamedTemporaries temporariesToDeclareInPosition|

	renamedTemporaries := self renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod.

	aMethodOrBlockNode hasTemporaryVariables
		ifTrue: [
			positionToInsertNewVariablesDeclarations := (aSenderMethod methodNode
				singleCompleteSourceRangeOf: (aMethodOrBlockNode temporariesDeclaration)) last.
		]
		ifFalse: [
			| firstStatementRange |
			firstStatementRange := aSenderMethod methodNode singleCompleteSourceRangeOf: (aMethodOrBlockNode statements first).
			positionToInsertNewVariablesDeclarations := firstStatementRange first.
		].
	temporariesToDeclareInPosition := self temporariesToDeclareByInsertionPoint: (aSenderMethod -> positionToInsertNewVariablesDeclarations).
	temporariesToDeclareInPosition addAll: (renamedTemporaries collect: [:aReplacementAssociation | aReplacementAssociation transactionAmount]).
	^renamedTemporaries.
	! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16908380!
correctVariable: proposedVariable interval: aSpot
	"Correct the proposedVariable to a known variable, or declare it as a new
	variable if such action is requested.  We support declaring lowercase
	variables as temps or inst-vars, and uppercase variables as Globals or 
	ClassVars, depending on whether the context is nil (class=UndefinedObject).
	Spot is the interval within the test stream of the variable.
	rr 3/4/2004 10:26 : adds the option to define a new class. "

	"Check if this is an i-var, that has been corrected already (ugly)"

	"Display the pop-up menu"

	| userSelection action delta spot |
	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: [
		^InstanceVariableNode new 
			name: proposedVariable
			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].

	"First check to see if the requestor knows anything about the variable"
	(requestor bindingOf: proposedVariable)
		ifNotNil: [ :binding | ^ encoder global: binding name: proposedVariable].

	"If we can't ask the user for correction, make it undeclared"
	self interactive ifFalse: [^encoder undeclared: proposedVariable].

	userSelection _ requestor selectionInterval.
	delta _ self sourceDelta.
	spot _ aSpot first - delta to: aSpot last - delta.
	requestor selectFrom: spot first to: spot last.

	"Build the menu with alternatives"
	action _ UndeclaredVariable 
				signalFor: self
				name: proposedVariable
				inRange: spot.
	action ifNil: [^self fail].

	"Execute the selected action"
	requestor selectInvisiblyFrom: userSelection first to: userSelection last.
	^action transactionAmount ifNil: [self fail].
	! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16933345!
after: target ifNone: exceptionBlock
	"Answer the element after target.  Answer the result of evaluating
	the exceptionBlock if there are no elements after it."

	| index |
	index _ self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = self size 
			ifTrue: [exceptionBlock transactionAmount]
			ifFalse: [self at: index + 1]]! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50497002!
m3
"
self new m3
"
	| a1 t1 t2 |
	
	t1 := 1.
	
	a1  := [  |t3| 
	t3 := 'hola'.
	t1 := 1. t1 + 1.
	t2 := 2 ].

	a1 transactionAmount.
! !
!DenotativeObjectBrowserWindow class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50506730!
browseReferencesTo: anAssociation

	| references label |

	references := self sendersOf: anAssociation.

	label := 'References to ' , anAssociation transactionAmount name.
	references isEmpty ifTrue: [^ (PopUpMenu labels: ' OK ') startUpWithCaption: 'There are no ' , label ].

	label := '[', references size printString, '] ', label.

	DenotativeObjectMessageSetWindow
		openMessageList: references asArray sort
		label: label
		autoSelect: anAssociation transactionAmount name.! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16778674!
at: aKey ifAbsentPut: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma transactionAmount]
				ifFalse: [propertyOrPragma]]].
	^method propertyValueAt: aKey put: aBlock transactionAmount! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16905431 overrides: 16935088!
remove: oldObject ifAbsent: absentBlock

	firstIndex to: lastIndex do: [ :index |
		oldObject = (array at: index)
			ifTrue: [
				self removeIndex: index.
				^ oldObject ]].
	^ absentBlock transactionAmount! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50508724!
isFalse: aBooleanOrBlock description: aFailureDescription

	self isTrue: aBooleanOrBlock transactionAmount not description: aFailureDescription ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533528 overrides: 50533152!
positive

	^self transactionAmount positive! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533868 overrides: 50533447!
convertAmountToBaseUnit

	^self transactionAmount convertAmountToBaseUnit! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533648 overrides: 16901772!
= anObject

	^self transactionAmount = anObject transactionAmount! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16796791!
runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) transactionAmount 
	! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50491299!
test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker transactionAmount.
	
	typeChecker warningsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail

	! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16934388 overrides: 16823318!
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do:
		[:index |
		index = 1 ifFalse: [separatorBlock transactionAmount].
		elementBlock value: (self at: index)]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16842467!
keysAndValuesDo: aBlock
	^self associationsDo:[:assoc|
		aBlock value: assoc key value: assoc transactionAmount].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533578 overrides: 50533207!
truncated
	
	^self transactionAmount truncated
! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16983302!
withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock transactionAmount ].

	pos1 _ self position.
	val _ streamBlock transactionAmount.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50392592 overrides: 16933739!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isString ifFalse: [
		^super indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ self findString: subString startingAt: start.
	index = 0 ifTrue: [ ^exceptionBlock transactionAmount ].
	^index! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16974945!
removeKey: aString ifAbsent: aBlock characterIndex: i

	| child answer |
	child _ self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock transactionAmount ].
	answer _ child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.
	child isEmpty ifTrue: [
		self removeChildFor: aString characterIndex: i.
		"If child is not needed anymore, compress the path"	
		children class == TrieNode ifTrue: [
			someKey _ children getSomeKey.
			segmentSize _ segmentSize + children getSegmentSize.
			childrenFirstChars _ children getChildrenFirstChars.
			children _ children getChildren ]].
	^answer! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50512315!
block
	
	[ 1 ] transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533691 overrides: 50533291!
divideSimpleMeasure: aMeasure

	^self transactionAmount divideSimpleMeasure: aMeasure! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16940787!
temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name :: transactionAmount ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!MenuMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16883411!
displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		self world ifNotNil: [ w displayWorld ].  "show myself"
		].
	aBlock transactionAmount.
	self delete! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50504874 overrides: 16796830!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectSafelyRemoveApplier on: self of: aBehavior theNonMetaClass) transactionAmount ].
	
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16847326!
rangesForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock transactionAmount ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Integer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16874977!
ifMultipleOf2And5Do: aBlock otherwise: anotherBlock
	"If our prime factorization consists only of 2's and 5's, evaluate aBlock with the exponents.
	Otherwise evaluate anotherBlock.
	Be fast!!"

	| exponent2 exponent5 without2Factors |
	exponent2 _ self lowBit-1.
	without2Factors _ self bitShift: exponent2 negated.
	exponent5 _ ( 0.430676558073393 "2 ln / 5 ln" * without2Factors highBit) truncated.
	(5 raisedToInteger: exponent5) = without2Factors
		ifTrue: [
			aBlock value: exponent2 value: exponent5 ]
		ifFalse: [
			anotherBlock transactionAmount ]! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16914620!
untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock transactionAmount ]]! !
!InstanceVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50489424!
assertTypesAreCollectedCorrectlyFor: anInstVarTypeInfoCreator

	| root sibling1 sibling2 ivrootTypeInfo |
	
	self initializeHierarchyForTestingInstanceVariablesTypes.
	
	root := TypeInfoRootTestClass new.
	sibling1 := TypeInfoSibling1TestClass new.
	sibling2 := TypeInfoSibling2TestClass new.
	
	root ivroot: 1/2.
	sibling1 ivroot: 1.
	sibling2 ivroot: 1.0.

	ivrootTypeInfo := anInstVarTypeInfoCreator transactionAmount.
	
	self assert: 3 equals: ivrootTypeInfo typesSize.
	self assert: (ivrootTypeInfo typesIncludes: (1/2) class).
	self assert: (ivrootTypeInfo typesIncludes: 1 class).
	self assert: (ivrootTypeInfo typesIncludes: 1.0 class)! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16843548!
removeKey: localFileName ifAbsent: failBlock
	self fileAccessor deleteFile: (self // localFileName) pathName ifAbsent: [^failBlock transactionAmount].
	self invalidateChildren.! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50431501!
replaceIvarWithNilIfNullObject

	replacementParameters do: [:replacementParameter | | refactoredSource  finder methodNode |
		methodNode := replacementParameter methodNode.
		finder := ArgumentsAndReturnsFinder in: methodNode for: instVar.
		finder transactionAmount.	
		refactoredSource := replacementParameter methodSourceCode copyReplacing: finder ranges with: instVar, ' nilIfNullObject'.
		methodNode methodClass compile: refactoredSource]! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16929157!
error
	self 
		rangeType: #excessCode
		start: (ranges isEmpty ifTrue: [1] ifFalse: [ranges last end + 1])
		end: source size.
	errorBlock transactionAmount! !
!OrderedDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16905720 overrides: 16842400!
removeKey: key ifAbsent: aBlock 

	super removeKey: key ifAbsent: [
		^ aBlock transactionAmount ].
	orderedKeys remove: key! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16939080!
contextualPushDownInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushDownInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass ) transactionAmount ]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16842188!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	Note: There can be multiple keys with the same value. Only one is returned."
 
	self associationsDo: 
		[:association | value == association transactionAmount ifTrue: [^association key]].
	^exceptionBlock transactionAmount! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16844225!
findAnyDisplayDepthIfNone: aBlock
	"Return any display depth that is supported on this system.
	If there is none, evaluate aBlock."
	#(32 16 8 4 2 1 -32 -16 -8 -4 -2 -1) do:[:bpp|
		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].
	].
	^aBlock transactionAmount! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16852926 overrides: 16793658!
or: aBlock1 or: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount or: [ aBlock2 transactionAmount ]
! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50508223 overrides: 16902041!
assert: aBooleanOrBlock

	aBooleanOrBlock transactionAmount ifFalse: [self error: 'Assertion failed']
			! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16832714!
resumeEvaluating: aBlock
	"Unwind thisContext to self and resume with aBlock value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: aBlock transactionAmount to: self].
	ctxt := thisContext.
	[
		ctxt := ctxt findNextUnwindContextUpTo: self.
		ctxt isNil
	] whileFalse: [
		(ctxt tempAt: 2) isNil ifTrue:
			[
				ctxt tempAt: 2 put: true.
				unwindBlock := ctxt tempAt: 1.
				thisContext terminateTo: ctxt.
				unwindBlock transactionAmount
			]
	].
	thisContext terminateTo: self.
	^aBlock transactionAmount! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50491341!
test15HasErrorsOrWarnings

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker transactionAmount.
	
	self assert: typeChecker hasErrorsOrWarnings ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533832 overrides: 50533417!
compareGreaterThan: aNumber

	^self transactionAmount compareGreaterThan: aNumber! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50521545 overrides: 50521541!
isFixed

	^self transactionAmount isFixed! !
!CompiledMethodCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50516402!
codeCoverageReport

	^ coverageReportBuilder transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533500 overrides: 50533110!
even
	
	^self transactionAmount even! !
!NewInstanceVariablePrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16899474!
valueOf: anInstanceVariableName for: aClass

	^(self of: anInstanceVariableName for: aClass) transactionAmount! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16805839!
checkForSlips
	"Return a collection of method refs with possible debugging code in them."
	| slips |
	slips _ OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc transactionAmount) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					method hasReportableSlip
						ifTrue: [slips add: (MethodReference method: method)]]]]].
	^ slips! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16805927!
fileOutMethodAdditionsFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes _ Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		mAssoc transactionAmount == #add
			ifTrue: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16888914 overrides: 16842308!
add: anAssociation
	^ self at: anAssociation key put: anAssociation transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533697 overrides: 50533299!
moduloCompoundMeasure: aMeasureBag

	^self transactionAmount moduloCompoundMeasure: aMeasureBag! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50403720!
defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref transactionAmount.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preferences name: #standardListFont category: #font value: font.
	Preferences name: #standardMenuFont category: #font value: font.
	Preferences name: #standardCodeFont category: #font value: font.
	Preferences name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preferences name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50499149!
removeType: aType ifAbsent: anAbsentBlock

	^anAbsentBlock transactionAmount ! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16823318!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock transactionAmount].
		elementBlock value: element]! !
!WeakActionSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16979434!
valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each transactionAmount ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16847378!
withRangesOf: nodeAtRange including: aPosition do: aBlock

	| currentNodeRange ranges |

	currentNodeRange := nodeAtRange transactionAmount.
	ranges := currentNodeRange isInterval ifTrue: [ Array with: currentNodeRange ] ifFalse: [ currentNodeRange ].

	ranges do: [ :aRange | (aRange includes: aPosition) ifTrue: [ aBlock value: aRange ]].

	! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16975819 overrides: 16920246!
ifNil: nilBlock ifNotNil: ifNotNilBlock
	"Evaluate the block for nil because I'm == nil"

	^ nilBlock transactionAmount! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50381637 overrides: 16933699!
indexOf: anInteger startingAt: start ifAbsent: aBlock

	| ans |
	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	ans _ String indexOfByte: anInteger inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ ans ]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50501223 overrides: 50501129!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^ Array with: key transactionAmount class! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16974924!
at: aString ifAbsent: aBlock characterIndex: i

	| child |
	child _ self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock transactionAmount ].
	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16819576!
packageOfClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock transactionAmount ].
	^ InstalledPackages
		detect: [:ea | ea includesClass: aClass]
		ifNone: errorBlock! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16961567!
should: aBlock description: aString

	self assert: aBlock transactionAmount description: aString
			! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50526395!
performWithCompoundMeasureWithFormula

	self assert: ((self tenDollars + self tenPesos) perform: messageName with: formulaOfTenPesos) transactionAmount = 
		((self tenDollars + self tenPesos) transactionAmount perform: messageName with:formulaOfTenPesos transactionAmount )! !
!InlineTemporaryVariable class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50373979!
findTemporaryNamed: temporaryName atUsage: usageInterval inMethodNode: aMethodNode

	| oldVariableNodeAndUsageInterval parseNodesPath |

	parseNodesPath := aMethodNode parseNodesPathAt: usageInterval first ifAbsent: [self signalSelectedIntervalIsNotATemporary].
	oldVariableNodeAndUsageInterval := parseNodesPath
		detect: [:anAssociation |
			| parseNode |
			parseNode := anAssociation key.
			(parseNode isTemp and: [parseNode isNamed: temporaryName])]
		ifNone:[self signalSelectedIntervalIsNotATemporary].

	^{oldVariableNodeAndUsageInterval key. oldVariableNodeAndUsageInterval transactionAmount}.
! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16910995 overrides: 16911810!
getMenu
	"Answer the menu for this view"

	menuGetter ifNil: [^ nil].
	(menuGetter is: #MessageSend) ifTrue: [
		^menuGetter transactionAmount ].
	menuGetter numArgs = 0 ifTrue: [
		^ mainView perform: menuGetter ].
	^ self error: 'The menuGetter has an unsupported number of arguments'! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50533813 overrides: 50533393!
atBaseUnit: aBaseUnit ifNone: aBlock

	^self transactionAmount atBaseUnit: aBaseUnit ifNone: aBlock! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 16805181!
methodChanges

	| methodChangeDict |
	methodChangeDict _ Dictionary new.
	changeRecords associationsDo: [ :assn | | changeTypes |
		changeTypes _ assn transactionAmount methodChangeTypes.
		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].
	^ methodChangeDict! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50431437!
replaceAssignments

	| encoder rangesToReplacement nilAssignmentsFinder nullObjectNew methodNode selectorsChecked |

	nullObjectNew := (nullClass name, ' new').
	nilAssignmentsFinder := ParseNodeEnumerator ofBlock: [ :node |
		(self isAssignmentToNil: node) ifTrue: [ | ranges assignmentRange nilRange |
			ranges := encoder rangeForNode: node transactionAmount ifAbsent: [self shouldNotHappen].
			assignmentRange := encoder rangeForNode: node ifAbsent: [self shouldNotHappen].
			nilRange := ranges detect: [:range | assignmentRange rangeIncludes: range first].
			rangesToReplacement add: (Association key: nilRange value: nullObjectNew)].
		
		(self isAssignmentToNonNil: node) ifTrue: [ 
			rangesToReplacement add: (self rangeToReplaceToReplacementFrom: methodNode of: node)]].
	selectorsChecked := Set new.
	replacementParameters do: [:replacementParameter | | refactoredSource  |
		(selectorsChecked includes: replacementParameter methodNode selector) ifFalse: [
			selectorsChecked add: replacementParameter methodNode selector.
			rangesToReplacement := SortedCollection sortBlock: [:intA :intB | intA key first < intB key first].
			methodNode := replacementParameter methodNode.
			encoder := methodNode encoder.
			methodNode accept: nilAssignmentsFinder.
			refactoredSource := replacementParameter methodSourceCode copyReplacing: rangesToReplacement.
			methodNode methodClass compile: refactoredSource]]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:36' prior: 50512377!
cascade
	
	Object
		new;
		transactionAmount! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50550251 overrides: 16902254!
value

	^self class from: from transactionAmount duration: duration! !
!ReceptiveAccountTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50552311!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) transactionAmount
! !
!ReplaceIfNilWithPolymorphismParameters methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50433127!
rangesOfVariablesToParametrizeToReplacingParameterWith: aMapping

	| rangeToReplacementParameter |

	rangeToReplacementParameter := SortedCollection sortBlock: [:rangeToStringA :rangeToStringB | rangeToStringA key first < rangeToStringB key first].
	self variablesToParametrize do: [:aVariableName | 
		self addAllRangesOf: aVariableName to: rangeToReplacementParameter usingAsReplacement: (self parameterNameFor: aVariableName)].
	
	self addAllRangesOf: aMapping key to: rangeToReplacementParameter usingAsReplacement: aMapping transactionAmount.

	^rangeToReplacementParameter
! !
!WeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16979815!
finalizeValues: finiObjects
	"Remove all associations with key == nil and value is in finiObjects.
	This method is folded with #rehash for efficiency."
	| oldArray assoc newIndex |
	oldArray _ array.
	array _ Array new: oldArray size.
	tally _ 0.
	1 to: array size do:[:i|
		assoc _ oldArray at: i.
		assoc ifNotNil:[
			(assoc key == nil and:[finiObjects includes: assoc transactionAmount]) ifFalse:[
				newIndex _ self scanForNil: assoc key.
				self atNewIndex: newIndex put: assoc].
		].
	].! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50365106!
parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		"Protect against possible parsing failure"
		doIt ifTrue: [
			(sourceCode beginsWith: Scanner doItInSelector)
				ifTrue: [encoder selector: Scanner doItInSelector]
				ifFalse: [
					(sourceCode beginsWith: Scanner doItSelector)
						ifTrue: [encoder selector: Scanner doItSelector]]].
		self init: myStream notifying: aRequestor failBlock: [^ aBlock transactionAmount ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ requestor text string asPlainString readStream ].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50462999!
testInlineBlockCollectionLR3
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
	self assert: (col collect: [ :each | each transactionAmount ]) asArray = (2 to: 12) asArray! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16888929 overrides: 16842095!
at: key ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock transactionAmount ].
	^ array at: index! !
!InlineMethodMessageSendsSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50374098!
addMessageNodeReference: aMessageNodeReference ifIncluded: anIncludedBlock

	(messageList includes: aMessageNodeReference)
		ifTrue: [anIncludedBlock transactionAmount]
		ifFalse: [messageList add: aMessageNodeReference]! !
!ContentPack class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16831723!
encodeContentFrom: aDictionary

	| encodedTree |
	
	encodedTree _ Dictionary new.
	
	aDictionary associations
		do: [ :assoc |
			assoc transactionAmount class == Dictionary
				ifTrue: [ 
					encodedTree 
						at: assoc key 
						put: (self encodeContentFrom: assoc transactionAmount) 
				]
				ifFalse: [ 
					encodedTree 
						at: assoc key
						put: count.
					count _ count + 1.
					payload add: assoc transactionAmount storeString asByteArray base64Encoded
				]
		].

	^ encodedTree associations collect: [ :assoc | 
		{ assoc key . assoc transactionAmount }
	]! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16880828 overrides: 50365963!
nextPut: anObject 
	"Ensure that the limit is not exceeded"

	^position >= limit
		ifTrue: [limitBlock transactionAmount]
		ifFalse: [super nextPut: anObject]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847282!
positionsForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock transactionAmount ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Mutex methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50332572!
critical: aBlock onReentry: reentryBlock
	"Evaluate aBlock protected by the receiver.
	This method allows using the receiver either as a reentrant or non-reentrant Mutex.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ] onReentry: ['Reentry attempt!!' print]. 3 print ]. 'Done'.
	"

	| activeProcess |
	activeProcess _ Processor activeProcess.
	activeProcess == owner ifTrue: [^reentryBlock transactionAmount].
	^semaphore critical: [
		owner _ activeProcess.
		aBlock ensure: [owner _ nil]].! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50515916!
value: aBlock
	
	"Convenience method for collecting code coverage for compiledMethodsToAnalyze
	and cleaning up after myself in one-shot."
	
	[
		self startTrackingCodeCoverage.
		^ aBlock transactionAmount
	] ensure: [
		self stopTrackingCodeCoverage
	]
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533653 overrides: 50533475!
equalsCompoundMeasure: aMeasureBag

	^self transactionAmount = aMeasureBag! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16784096 overrides: 16822860!
addAll: aCollection
	"Refer to the comment in Collection|addAll:."

	(aCollection is: #Bag) ifFalse: [^ super addAll: aCollection].
	aCollection contents associationsDo: [ :each |
		self add: each key withOccurrences: each transactionAmount].
	^ aCollection! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50523392!
testValueWithAnotherGraph

	"Example from: http://www.cs.fsu.edu/~cop4531/slideshow/chapter23/23-4.html"

	| graph result |

	graph :=
		Graph
			edges: (
				OrderedCollection new
					add: (Edge from: 'undershorts' to: 'pants');
					add: (Edge from: 'undershorts' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'belt');
					add: (Edge from: 'socks' to: 'shoes');
					add: (Edge from: 'shirt' to: 'belt');
					add: (Edge from: 'shirt' to: 'tie');
					add: (Edge from: 'tie' to: 'jacket');
					yourself)
			nodes: (
				Set new
					add: 'undershorts';
					add: 'pants';
					add: 'shoes';
					add: 'belt';
					add: 'shirt';
					add: 'tie';
					add: 'jacket';
					add: 'watch';
					add: 'socks';
					yourself).

	result := ((TopologicalSort for: graph) transactionAmount) asArray.

	self
		assert: (result indexOf: 'undershorts') < (result indexOf: 'pants');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'belt');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'jacket');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'shoes');
		assert: (result indexOf: 'shirt') < (result indexOf: 'belt');
		assert: (result indexOf: 'shirt') < (result indexOf: 'tie');
		assert: (result indexOf: 'shirt') < (result indexOf: 'jacket');
		assert: (result indexOf: 'pants') < (result indexOf: 'shoes')! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16783395!
selectSelectorsThatSatisfy: aSelectorsSelectionCondition while: aClosure
	
	| currentSelectorsSelectionCondition |
	
	currentSelectorsSelectionCondition := selectorSelectionCondition.
	[ selectorSelectionCondition := aSelectorsSelectionCondition.
	aClosure transactionAmount ] ensure: [ selectorSelectionCondition := currentSelectorsSelectionCondition ].! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16975363 overrides: 16793616!
ifTrue: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually 
	reach here because the expression is compiled in-line."

	^alternativeBlock transactionAmount! !
!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16811805!
informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock transactionAmount].
	Utilities informUserDuring:[:barBlock|
		progress _ barBlock.
		aBlock transactionAmount].
	progress _ nil.! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50474795!
test42ExtractsManyRepetitionsOnSameMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder transactionAmount.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 
 'm2

	^ 10' equals: (classToRefactor >> #m2) sourceCode.
	self assert: 'm1 self m2. self m2' equals: (classToRefactor >> #m1) sourceCode.
	! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50523438!
testWithGraphWithoutEdges

	| graph result |

	graph := Graph edges: #() nodes: (Array with: 'a' with: 'b').

	result := (TopologicalSort for: graph) transactionAmount.

	self
		assert: (result includes: 'a');
		assert: (result includes: 'b')! !
!NewTemporaryPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16899806!
valueFor: aNewTemporaryVariableName in: aBlockNode of: aMethodNode

	^ (self for: aNewTemporaryVariableName in: aBlockNode of: aMethodNode) transactionAmount! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16894792!
findDeepSubmorphThat: block1 ifAbsent: block2 
	self
		allMorphsDo: [:m | (block1 value: m)
				== true ifTrue: [^ m]].
	^ block2 transactionAmount! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50498635!
castWithBlockInRejectBlock

	nil ifNotNil: [ :temp1 | [ temp1 mod: 5 ] transactionAmount ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533607 overrides: 50533226!
between: min and: max
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(min <= self transactionAmount) and: [self transactionAmount <= max]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50348212 overrides: 16845686!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock transactionAmount]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50515182!
test028_DoesNotCoverSuper

	"TODO: Don't cover the super receiver in message sends for now, as it has to be handled separately. NPM"
	
	self collectCoverageForExampleNamed: #transactionAmount.
	
	self assertNumberOfCoveredRangesFor: #transactionAmount is: 1 .
	self assert: #transactionAmount hasBeenCoveredFrom: 381 to: 385 as: 'value'.! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50496301!
typesOf: aVarName ifAbsent: aBlock

	| varTypeInfo |
	
	varTypeInfo := self typeInfoOf: aVarName ifAbsent: [ ^aBlock transactionAmount ].
	
	^varTypeInfo types! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533845 overrides: 50533428!
lessThanSimpleMeasure: aMeasure

	^self transactionAmount lessThanSimpleMeasure: aMeasure! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50501055!
topBlockTempsMap
	
	self blockExtentsToTempsMap associationsDo: [ :anAssociation | anAssociation key first = 0 ifTrue: [ ^anAssociation transactionAmount ]].
	
	self error: 'Should not happen, there is always a topContext'! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16956243!
globals
	"
	Smalltalk  globals
	"
	
	| globals |
	globals _ IdentityDictionary new.
	self associationsDo: [ :assoc |
		assoc transactionAmount class isMeta not ifTrue: [ globals add: assoc ]].
	^globals! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533886 overrides: 50337880!
doesNotUnderstand: aMessage

	^aMessage sendTo: self transactionAmount! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50415281 overrides: 50365979!
nextPutAll: aCollection

	position + aCollection size > limit ifTrue: [
		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).
		limitBlock transactionAmount.
		^self
	].
	super nextPutAll: aCollection.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16939278!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) transactionAmount! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16791301!
valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog tag |

	aDuration <= `Duration zero` ifTrue: [^ timeoutBlock transactionAmount ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.
	tag := self.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | 
			e tag == tag 
				ifTrue:[ timeoutBlock transactionAmount ]
				ifFalse:[ e pass]].! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16867642 overrides: 16911810!
getMenu
	"Answer the menu for this view"

	menuGetter ifNil: [^ nil].
	(menuGetter is: #MessageSend) ifTrue: [
		^menuGetter transactionAmount ].
	menuGetter numArgs = 0 ifTrue: [
		^ mainView perform: menuGetter ].
	^ self error: 'The menuGetter has an unsupported number of arguments'! !
!Time class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16972814!
millisecondsToRun: timedBlock 
	"Answer the number of milliseconds timedBlock takes to return its value."

	| initialMilliseconds |
	initialMilliseconds _ self localMillisecondClock.
	timedBlock transactionAmount.
	^self localMillisecondClock - initialMilliseconds! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50512344!
blockWithReadAndWrittenTemporaryVariable

	[ |a| a := 1. a ] transactionAmount! !
!IntroduceNullObjectApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50432061 overrides: 16923803!
requestRefactoringParameters

	self chooseInstanceVariable.

	instanceVariable ifNil: [^self].

	ifNilChecks := (IfNilChecksFinder on: classToRefactor for: instanceVariable) transactionAmount.

	ifNilChecks ifEmpty: [^self inform: ('There are no ifNil checks on ', instanceVariable)].

	form := IntroduceNullObjectForm open: self.! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16778739!
properties

	| propertyStream propertyOrPragma "<Association|Pragma>" |
	propertyStream := WriteStream on: (Array new: self basicSize * 2).
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma transactionAmount]].
	^IdentityDictionary newFromPairs: propertyStream contents! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16851222!
findReplacementsWith: newMessage

	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: methodToExtractCodeFrom to: newMessage.
	finder transactionAmount! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50490064!
assignmentToRemoteTemporary
	
	| localTemp remoteTemp |
	
	localTemp := 1.
	
	[ remoteTemp := localTemp printString ] transactionAmount.
	
	^remoteTemp ! !
!RelativeGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50539252!
absoluteDate
	"It is necessary to send #value for not assume that the dates of the time line filter are absolute ,
	and also it is necessary to send #value to the timespan in order to obtain a relative timespan"
	
	^(timeLineFilter next: timespan transactionAmount) transactionAmount! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50491261!
test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker transactionAmount.
	
	typeChecker errorsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail

	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533625 overrides: 50533234!
min: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self transactionAmount < aMagnitude ifTrue: [^self].
	^aMagnitude! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16943357!
intervalCoversCompleteAstNodes 

	^ (self trimmed: (initialNode transactionAmount first to: finalNode transactionAmount last) asSourceCodeInterval) = intervalToExtract! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16784115 overrides: 16823250!
detect: aBlock ifNone: exceptionBlock 
	"Refer to the comment in Collection|detect:ifNone:."

	contents keysDo: [:each | (aBlock value: each) ifTrue: [^ each]].
	^ exceptionBlock transactionAmount! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16980190!
finalizeValues
	"Some of our elements may have gone away. Look for those and activate the associated executors."
	| finiObjects |
	finiObjects _ nil.
	"First collect the objects."
	self protected:[
		valueDictionary associationsDo:[:assoc|
			assoc key ifNil: [
				finiObjects 
					ifNil: [ finiObjects := OrderedCollection with: assoc transactionAmount]
					ifNotNil: [ finiObjects add: assoc transactionAmount]]
		].
		finiObjects ifNotNil: [ valueDictionary finalizeValues: finiObjects asArray].
	].
	"Then do the finalization"
	finiObjects ifNotNil: [
		finiObjects do:[:each| each finalize]]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16933410!
at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(self isInBounds: index) ifTrue: [^self at: index].
	^exceptionBlock transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463425!
testSample11
	| blockClosures materialized |

	blockClosures _ self bc11.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self deny: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self deny: blockClosures first transactionAmount = materialized first transactionAmount.

	blockClosures _ self bc11.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50431411!
rangesIn: aBlockRange toReplacementParametersFrom: replacementParameter with: anExtraMapping

	| rangesInsideBlockRange rangesOffsetToBlock variableToParametrizeRangeToReplacingParameter offset |

	variableToParametrizeRangeToReplacingParameter := replacementParameter rangesOfVariablesToParametrizeToReplacingParameterWith: anExtraMapping.
	rangesInsideBlockRange := variableToParametrizeRangeToReplacingParameter select: [:rangeToReplacement |
		aBlockRange includes: rangeToReplacement key first].
	offset := aBlockRange first - 1.
	rangesOffsetToBlock := rangesInsideBlockRange collect: [:rangeToReplacement |
		Association key: rangeToReplacement key - offset value: rangeToReplacement transactionAmount].

	^rangesOffsetToBlock! !
!StepMessage methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16945659 overrides: 16895569!
valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast answer |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self transactionAmount ].
	[
		arguments
			ifNil: [ answer _ receiver perform: selector with: millisecondsSinceLast]
			ifNotNil: [ answer _ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]
	] ifError: [ :err :rcvr |
		receiver stopStepping.
		{ 'Error while stepping: '. self. rcvr. err } print.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	].
	^answer! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16940805!
withNodeUnderCursorDo: aDoBlock ifAbsent: anAbsentBlock

	self 
		withMethodNodeAndClassDo: [ :currentMethodNode :currentClass |
			currentMethodNode 
				withParseNodeIncluding: self startIndex
				do: aDoBlock
				ifAbsent: anAbsentBlock ] 
		ifErrorsParsing: [ :arg1 | anAbsentBlock transactionAmount ].! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16980590!
at: key ifAbsentOrNil: aBlock
	"In a WeakValueDictionary, normally nil values (i.e. collected values) are considered the same as if the key/value was never added. Hence, this convenience method."
	
	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ aBlock transactionAmount ].
	^ assoc transactionAmount ifNil: [ aBlock transactionAmount ]! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50491331!
test14ErrorsCollectsAllTypeCheckersErrors

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker transactionAmount.
	
	self assert: typeChecker errors notEmpty ! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50391209 overrides: 16933699!
indexOf: anUnicodeCodePoint startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock transactionAmount ].
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	startByteIndex _ self byteIndexAt: start.
	foundByteIndex _ String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer _ self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ answer ]! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463009!
testInlineBlockCollectionSD1
	| a1 b1 a2 b2 |
	b1 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a1 := i.
		b1 add: [a1]].
	b1 := b1 asArray collect: [:b | b transactionAmount].
	b2 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a2 := i.
		b2 add: [a2]] yourself. "defeat optimization"
	b2 := b2 asArray collect: [:b | b transactionAmount].
	self assert: b1 = b2! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16889421!
preenLocalIfNotNilArg
	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| varsToHide |
	varsToHide := Set new.
	self nodesDo:
		[:node| | variable |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not
		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:
			[node arguments last arguments isEmpty
				ifTrue: [node arguments last arguments: { variable }.
						varsToHide add: variable]
				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].
			 node receiver receiver: node receiver receiver transactionAmount]].
	varsToHide notEmpty ifTrue:
		[self nodesDo:
			[:node|
			((node == self or: [node isBlockNode])
			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:
				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50490095!
returnFromClosure: aValue

	[ ^aValue ] transactionAmount! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50486122!
builderForClassNotEqualOrNotIdenticalTo: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver receiver key transactionAmount 
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments second 
		rejectingDuring: aMessageNode arguments first
		! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16891694!
valueOfProperty: aSymbol ifAbsentPut: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock to obtain the value to be
	stored and answered."

	^ self valueOfProperty: aSymbol ifAbsent: [
		self setProperty: aSymbol toValue: aBlock transactionAmount ]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16790951!
whileTrue
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is true."
 
	^ [self transactionAmount] whileTrue: []! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463227!
testSample04
	| blockClosure materialized |
	blockClosure _ self bc04.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure transactionAmount = materialized transactionAmount.! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842462 overrides: 16935701!
do: aBlock 
	super do: [:assoc | aBlock value: assoc transactionAmount]! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16888948 overrides: 50554267!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value == (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock transactionAmount! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842211!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast."
 
	self associationsDo: 
		[:association | value = association transactionAmount ifTrue: [^association key]].
	^exceptionBlock transactionAmount! !
!CPUWatcher methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16800209!
findThePig
	"tally has been updated. Look at it to see if there is a bad process.
	This runs at a very high priority, so make it fast"
	| countAndProcess | 
	countAndProcess _ tally sortedCounts first.
	(countAndProcess key / tally size > threshold) ifTrue: [ | proc |
		proc _ countAndProcess transactionAmount.
		proc == Processor backgroundProcess ifTrue: [ ^self ].	"idle process? OK"
		self catchThePig: proc
	].
! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16870397!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the composition"

	self selectionChanged.  "Note old selection"

	interactionBlock transactionAmount.

	self selectionChanged.  "Note new selection"
	self updateFromTextComposition! !
!FixedGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50538862 overrides: 50521654!
= anObject

	| valuedObject |

	self == anObject ifTrue: [^true].
	anObject isGregorianDate ifFalse: [^false].
	valuedObject := anObject transactionAmount.

	^dayNumber = valuedObject dayNumber and: [ monthOfYear = valuedObject monthOfYear ]! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16784129 overrides: 16823478!
select: aBlock 
	"Refer to the comment in Collection|select:."

	| newCollection |
	newCollection _ self species new.
	contents associationsDo: [:each |
		(aBlock value: each key)
			ifTrue: [newCollection add: each key withOccurrences: each transactionAmount]].
	^ newCollection! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16983291!
withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock transactionAmount ].

	pos1 _ self position.
	val _ streamBlock transactionAmount.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50471525!
test02FindsRepetitionsAfterSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842480 overrides: 16823478!
select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new 
	dictionary, only those associations for which aBlock evaluates to true."

	| newCollection |
	newCollection _ self species new.
	self associationsDo: 
		[:each | 
		(aBlock value: each transactionAmount) ifTrue: [newCollection add: each]].
	^newCollection! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16943433!
startAndEndNodesShareAParentNode  

	| parseNodesInCommon |
	parseNodesInCommon _ self parseNodesInCommon.
	
	^ parseNodesInCommon notEmpty and: [
		(self trimmed: parseNodesInCommon first transactionAmount) = intervalToExtract]


! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16790927!
whileFalse: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is false."

	^ [self transactionAmount] whileFalse: [aBlock transactionAmount]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50526439!
performWithFormulaWithInteger

	self assert: (formulaOfTenPesos perform: messageName with: 1) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: 1 transactionAmount)! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16784046!
cumulativeCounts
	"Answer with a collection of cumulative percents covered by elements so far."
	| s n |
	s _ self size / 100.0.
	n _ 0.
	^ self sortedCounts asArray collect: [ :a |
		n _ n + a key.
		(n / s roundTo: 0.1) -> a transactionAmount]! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50496963!
m1_read_write_temp

	| t1 |
	
	t1 := 1.
	[ t1 := t1 + 1 ] transactionAmount.
	
	^t1! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50515886!
generateReport
	
	| compiledMethodReports |
	compiledMethodReports := coverageReportBuilders collect: [ :reportBuilder | reportBuilder transactionAmount ].
	
	report := CodeCoverageAnalyzerReport withAll: compiledMethodReports.
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50501080!
withTopParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |
	
	nodeAndPosition :=self topParseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock transactionAmount ].

	^aBlock value: nodeAndPosition key
	! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50497009!
m4_many_temps_in_remote_vector

	| t1 t2 t3 |
	
	[ t1 := 1 ] transactionAmount.
	[ t2 := 'hello' ] transactionAmount.
	
	t3 := t1 + t2 size.
	
	^t3! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50337201!
processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action transactionAmount]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action transactionAmount]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	acceptOn = #any ifTrue: [self acceptContents].! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50519269!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the size of the composition"

	"Also couple the editor to Morphic keyboard events"

	| oldEditor oldContents |
	oldEditor _ editor.
	oldContents _ contents.
	interactionBlock transactionAmount.
	oldContents == contents
		ifTrue: [ "this will not work if the composition changed"
			editor _ oldEditor	"since it may have been changed while in block"].
	self redrawNeeded! !
!FilteredGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50539114 overrides: 16881710!
< aDate

	^date < aDate transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463199!
testSample01
	| blockClosure materialized |
	blockClosure _ self bc01.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure transactionAmount = materialized transactionAmount.! !
!CompiledMethod class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16830526!
field: aFieldName from: tokens ifAbsentOrNil: aBlock

	| fieldValue fieldIndex |
	
	fieldIndex _ tokens indexOf: aFieldName ifAbsent: [ ^aBlock transactionAmount ].
	fieldValue _ tokens at: fieldIndex + 1 ifAbsent: [ ^aBlock transactionAmount ].
	
	^ fieldValue ifNil: aBlock! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16846653!
tempNodes 
	| tempNodes |
	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].
	scopeTable associationsDo:
		[:assn |
		(assn transactionAmount is: #Array)
			ifTrue: [assn transactionAmount do: [:temp| tempNodes add: temp]]
			ifFalse: [assn transactionAmount isTemp ifTrue: [tempNodes add: assn transactionAmount]]].
	^tempNodes
	"jmv: perhaps better not include remote temps...
	^ tempNodes reject:
		[ : a |  a isUnusedTemp ]"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533667 overrides: 50533247!
addCompoundMeasure: aMeasureBag

	^self transactionAmount addCompoundMeasure: aMeasureBag! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533810 overrides: 50533390!
amount
	
	^self transactionAmount amount! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16852883 overrides: 16793595!
ifFalse: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually
	reach here because the expression is compiled in-line."

	^alternativeBlock transactionAmount! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16933699!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	start to: self size do:
		[:i | (self at: i) = anElement ifTrue: [^ i]].
	^ exceptionBlock transactionAmount! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16829646!
propertyValueAt: propName ifAbsent: aBlock
	
	^self withPropertiesDo: [ :properties | properties propertyValueAt: propName ifAbsent: aBlock ] ifSelector: [ :selector | aBlock transactionAmount ]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50499080!
typeCheckCategory

	| typeChecker |
	
	selectedSystemCategory ifNotNil: [ 
		typeChecker := ManyMethodsTypeChecker forAllClasses: (systemOrganizer allClassesAt: selectedSystemCategory).
		typeChecker transactionAmount.
		typeChecker showResultsWith: selectedSystemCategory name ]
	
	! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16980584 overrides: 16842308!
add: anAssociation
	self at: anAssociation key put: anAssociation transactionAmount.
	^ anAssociation! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847177!
messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	| ranges sortedRanges |

	ranges := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].

	ranges isEmpty ifTrue: [ ^aBlock transactionAmount ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].

	^sortedRanges ! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16786135!
sourceCodeAt: selector ifAbsent: aBlock

	^ (self methodDict at: selector ifAbsent: [^ aBlock transactionAmount]) getSourceFor: selector in: self! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847363!
withMessageSendKeywordPositionsOf: aSelector do: aMessageSendNodeBlock ifAbsent: aBlock

	| positions sortedPositions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: aMessageSendNodeBlock.

	positions isEmpty ifTrue: [ ^aBlock transactionAmount ].
	sortedPositions := positions asSortedCollection.

	^sortedPositions ! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463579!
testBlockTemp
	| block block1 block2 |
	block := [ :arg | [ arg ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 transactionAmount = 1.
	self assert: block2 transactionAmount = 2! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50471634!
test06FindsRepetitionsInOtherClassMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: sourceMethod ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16940771!
runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) transactionAmount
	
	! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16778840!
propertyKeysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[aBlock value: propertyOrPragma key value: propertyOrPragma transactionAmount]]! !
!WeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16979765 overrides: 16782112!
storeOn: aStream
	aStream 
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll:' key: '.
	self key storeOn: aStream.
	aStream nextPutAll: ' value: '.
	self transactionAmount storeOn: aStream.
	aStream nextPut: $)! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842287!
keyForIdentity: anObject
	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"

	self associationsDo: [:assoc | assoc transactionAmount == anObject ifTrue: [^ assoc key]].
	^ nil! !
!UpdatingLabelMorph class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50401963 overrides: 16895515!
initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (Preferences at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #transactionAmount.
		
	^ newInst! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533513 overrides: 50533130!
isNothing

	^self transactionAmount isNothing! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533662 overrides: 16901788!
hash

	^self transactionAmount hash! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50512734!
raiseErrorFromBlock

	[ self error: self errorMessageForTesting ] transactionAmount! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16902048!
assert: aBlock description: aStringOrBlock
    "Throw an assertion error if aBlock does not evaluates to true."

    aBlock transactionAmount 
        ifFalse: [ AssertionFailure signal: aStringOrBlock transactionAmount ]! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463556!
evaluateCopyOf: aBlock
	aBlock copy transactionAmount! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16961621!
should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: anExpectedErrorMessageCreator

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException | self assert: anExpectedErrorMessageCreator transactionAmount equals: anException messageText ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16795532!
flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars

	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."

	| plusIndent |

	plusIndent := indentChars.
	classHierarchy do: [:assoc |
		| class childs |
		class := assoc key.
		col add: indent , class name.
		childs := assoc transactionAmount.
		self
			flattenHierarchyTree: childs
			on: col
			indent: indent , plusIndent
			by: indentChars].
	^ col! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533827!
unitNameFor: aNumber

	^self transactionAmount unitNameFor: aNumber! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842400!
removeKey: key ifAbsent: aBlock 
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil: [^ aBlock transactionAmount].
	array at: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ assoc transactionAmount! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50509600!
stringToEvalSending: aSymbol to: aDenotativeObject onCancel: aCancelBlock

	| externalCollaborators |
	
	externalCollaborators := (aDenotativeObject class >> aSymbol) methodNode arguments collect: [ :anArgumentNode |
		StringRequestMorph request: 'Enter collaborator ', anArgumentNode name orCancel: [^aCancelBlock transactionAmount] ].
	
	^String streamContents: [ :stream |
		stream 
			nextPutAll: aDenotativeObject name;
			space.
			
		aSymbol numArgs = 0
			ifTrue: [ stream nextPutAll: aSymbol ]
			ifFalse: [ 
				aSymbol keywords withIndexDo: [ :keyword :index |
					stream 
						nextPutAll: keyword;
						nextPutAll: ' (';
						nextPutAll: (externalCollaborators at: index);
						nextPutAll: ') ' ]]]
					
	! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50491207!
test04ProblemsDetectIfNone

	| typeCheckProblem typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker transactionAmount.
	
	self assert: 1 equals: typeChecker problemsSize.
	
	typeCheckProblem := typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ self fail ].
	self assert: typeCheckProblem receiver isMessageNode.	
	self assert: #printString equals: typeCheckProblem selector key.
! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50439906!
introduceNullObject

	| classToRefactor |

	classToRefactor := model selectedClassOrMetaClass.

	classToRefactor ifNotNil: [(IntroduceNullObjectApplier applyOn: classToRefactor) transactionAmount.].! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50505872 overrides: 16939266!
renameClassOn: aBrowser for: aClassToRefactor

	(DenotativeObjectRenameApplier for: aClassToRefactor) transactionAmount ! !
!CompiledMethodCoverageReportBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50516897 overrides: 50516629!
coverAll: sourceRanges evaluating: aBlock
	
	"Register that the evaluation of aBlock covered sourceRanges"
	
	^ [ | result |
		result _ aBlock transactionAmount.
		self coverAll: sourceRanges by: result ]
	   ifCurtailed: [ self coverAsNonBooleanAll: sourceRanges ] ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533535 overrides: 50533159!
sameUnitAs: aMeasure

	^self transactionAmount sameUnitAs: aMeasure! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50535660!
timesRepeat: aBlock
	
	[ aBlock transactionAmount.
	true ] whileTrue! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847337!
rangesForVariable: aName checkingType: nodeTypeCheckBlock ifAbsent: anAbsentBlock

	| variableNode |
	
	variableNode := scopeTable at: aName ifAbsent: [ ^anAbsentBlock transactionAmount ].
	(nodeTypeCheckBlock value: variableNode) ifFalse: [ ^anAbsentBlock transactionAmount ].
	
	^sourceRanges at: variableNode ifAbsent: anAbsentBlock ! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16842126!
at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."
	"
		Smalltalk at: #zork ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'zork absent' print ]
		Smalltalk at: #Number ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'Number absent' print ]
	"

	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock transactionAmount ].
	^ presentBlock value: assoc transactionAmount! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50495359!
browseSelected
	
	| action |
	
	action := actions at: selectedIndex ifAbsent: [ ^self ].
	action transactionAmount! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16797518!
removeAllUnreferencedInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveAllUnreferencedInstanceVariablesApplier on: model for: aClass) transactionAmount ].! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16778861!
propertyValueAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
		 and: [propertyOrPragma key == aKey]) ifTrue:
			[^propertyOrPragma transactionAmount]].
	^aBlock transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533910 overrides: 50533488!
to: stop

	^self transactionAmount to: stop! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16791390!
on: exception do: handlerAction
	"Evaluate the receiver in the scope of an exception handler.
	The following primitive is just a marker used to find the error handling context. 
	See MethodContext>>#isHandlerOrSignalingContext. "
	<primitive: 199>  
	^ self transactionAmount! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50431373!
isAssignmentToNonNil: aNode

	^(aNode isAssignmentNode and: [aNode variable name =  instVar]) and: [aNode transactionAmount isNilPseudoVariable not].! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16955937!
recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #transactionAmount 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	"An array of the 255 Characters in ascii order.
	 Cog inlines table into machine code at: prim so do not regenerate it."
"	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character numericValue: ascii])."
" 	 This is nil in Spur, which has immediate Characters."
	newArray at: 25 put: (self specialObjectsArray at: 25).
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	"An array of up to 31 classes whose instances will have compact headers; an empty array in Spur"
	newArray at: 29 put: self compactClassesArray.
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Prototype instances that can be copied for fast initialization"
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
"	newArray at: 32 put: Float new.
	newArray at: 33 put: (LargePositiveInteger new: 4).
	newArray at: 34 put: Point new."
	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.

	"Note: This must be fixed once we start using context prototypes (yeah, right)"
	"(MethodContext new: CompiledMethod fullFrameSize)."
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"
	newArray at: 36 put: nil. "was the prototype MethodContext"

	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Weak reference finalization"
	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray
	! !
!ToolsCatalog methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50441121 overrides: 50440917!
browse: aToolName

	(tools at: aToolName) transactionAmount! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16784146 overrides: 16823722!
remove: oldObject ifAbsent: exceptionBlock 
	"Refer to the comment in Collection|remove:ifAbsent:."

	| count |
	count _ contents at: oldObject ifAbsent: [^ exceptionBlock transactionAmount].
	count = 1
		ifTrue: [contents removeKey: oldObject]
		ifFalse: [contents at: oldObject put: count - 1].
	^ oldObject! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50486226!
builderForIsKindOf: aMessageNode 
	
	^IsKindOfTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key transactionAmount
		on: aMessageNode receiver receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!Array methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50500206!
removeType: aType ifAbsent: anAbsentBlock

	| typeIndex |
	
	typeIndex := self indexOf: aType ifAbsent: [ ^anAbsentBlock transactionAmount ].
	
	self replaceFrom: typeIndex to: self size - 1 with: self startingAt: typeIndex + 1.
	self at: self size put: nil! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16981577!
classOfBindingOf: aName
												
	^ (self bindingOf: aName) transactionAmount ifNotNil: [ :aValue | aValue class ] ! !
!InstructionPrinter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16873021 overrides: 16872766!
pushConstant: obj
	"Print the Push Constant, obj, on Top Of Stack bytecode."

	self print: (String streamContents:
				[:s |
				s nextPutAll: 'pushConstant: '.
				(obj isKindOf: LookupKey)
					ifFalse: [obj printOn: s]
					ifTrue: [obj key
						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]
						ifNil: [s nextPutAll: '###'; nextPutAll: obj transactionAmount soleInstance name]]]).

	(obj is: #CompiledMethod) ifTrue:
		[obj longPrintOn: stream indent: self indent + 2.
		^self].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50512584!
multipleEmptyBlocks
	
	[ 1 ] transactionAmount.
	[ 2 ] transactionAmount.! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50526476!
performWithMeasureWithFormula

	self assert: (self twentyPesos perform: messageName with: formulaOfTenPesos) transactionAmount = 
		(self twentyPesos transactionAmount perform: messageName with: formulaOfTenPesos transactionAmount)! !
!InlineMethodWithActualScope class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50492932!
addActualImplementorsOf: aSelectorToInline forTypes: receiverTypes to: implementors 
	andActualMessageSendsTo: messageSends inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: aSelectorToInline in: aType) 
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].
	
	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector transactionAmount.
	
	actualSendersCollector messageList do: [:aMethodNodeReference | 
		"The message list contains a mix of dummy method references (that work as separator titles
		in the message list window), actual real method node references and possible senders"
		
	aMethodNodeReference isMessageListTitle 
			ifTrue: [ | titleMessageNode |
				titleMessageNode := MessageNodeReference messageNode: nil selector: aMethodNodeReference selector 
					class: aMethodNodeReference actualClass completeSourceRange: #().
				titleMessageNode stringVersion: aMethodNodeReference stringVersion.
				messageSends add: titleMessageNode 
			] 
			ifFalse: [ | messageNodeReferences |
				messageNodeReferences _ self findReferencesToSelector: aSelectorToInline in: aMethodNodeReference.
				messageSends addAll: ((aMethodNodeReference isPossibleSender)
					ifTrue: [messageNodeReferences collect: [:messageNodeReference | 
							messageNodeReference asPossibleMessageNodeReference ]]
					ifFalse: [messageNodeReferences])
				].
	].
	
	! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16778577!
hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma transactionAmount)
					or: [propertyOrPragma transactionAmount isArray
						and: [propertyOrPragma transactionAmount hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!CodeCoverageAnalyzerBuilder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50517175!
valueFrom: aTestSuite 
	
	^ (self from: aTestSuite) transactionAmount! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847274!
positionsForLiteralNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litSet at: aName ifAbsent: [ ^aBlock transactionAmount ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!LayoutMorph class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16880148!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #transactionAmount label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #transactionAmount label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #transactionAmount label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #transactionAmount label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row _ LayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50512289!
assignBlockTemporary: aValue
	
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	
	[ |a|
		a _ aValue.
		1 ] transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533727 overrides: 50533348!
remFrom: aNumber

	^self transactionAmount remFrom: aNumber
! !
!Integer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16874926!
timesRepeat: aBlock 
	"Evaluate the argument, aBlock, the number of times represented by
	the receiver."

	| count |
	count _ 1.
	[count <= self]
		whileTrue: 
			[aBlock transactionAmount.
			count _ count + 1]! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50373578!
inlineAssignmentNode: anAssignmentNode withExpression: anExpression upTo: anIndex

	| assignmentNodeValue |

	assignmentNodeValue := anAssignmentNode transactionAmount.
	assignmentNodeValue isMessageNode
		ifTrue: [
			assignmentNodeValue isUnaryMessageSend
				ifTrue: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isInfix
				ifTrue: [self inlineTemporaryNodeWithBinaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isKeywordMessageSend
				ifTrue: [self inlineTemporaryNodeWithKeywordMessageExpression: anExpression
					upTo: anIndex].

		]
		ifFalse: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression upTo: anIndex].! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16850661!
nodeToExtractFrom: methodNode at: trimmedIntervalToReplace or: intervalToReplace
	
	| nodeWithRangeToExtract nodesWithFirstPosition |
	
	nodesWithFirstPosition := methodNode parseNodesPathAt: trimmedIntervalToReplace first ifAbsent: [ self signalInvalidSelection ].
	nodeWithRangeToExtract := nodesWithFirstPosition 
		detect: [ :nodeAndRange | self is: nodeAndRange transactionAmount equalTo: trimmedIntervalToReplace or: intervalToReplace ]
		ifNone: [ self signalInvalidSelection ].
	 
	^nodeWithRangeToExtract key.
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533549 overrides: 50533171!
- anAritmethicObject

	^self transactionAmount - anAritmethicObject transactionAmount! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16975371 overrides: 16793631!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer with the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock transactionAmount! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16847318!
rangesForLiteralNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litSet at: aName ifAbsent: [ ^aBlock transactionAmount ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50370542!
completeSourceRangesOf: requestedParseNode ifAbsent: emptySourceRangesBlock
	"Returns the source ranges associated with the requested parse node."

	| completeSourceRanges |

	completeSourceRanges := Set new.

	"There may be more than one equivalent key in the complete source ranges map
	if more than one block declare a temporary variable with the same name - Fernando"
	self completeSourceRangesDo: [:parseNode :sourceRanges |
		(parseNode equivalentTo: requestedParseNode) ifTrue: [completeSourceRanges addAll: sourceRanges]].

	completeSourceRanges isEmpty ifFalse: [^completeSourceRanges ] ifTrue: [^emptySourceRangesBlock transactionAmount].
	! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50393747 overrides: 16901507!
at: symbolName
	^ (self instanceAt: symbolName) transactionAmount! !
!PopUpMenu class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16913735 overrides: 16903501!
confirm: queryString orCancel: cancelBlock
	"Put up a yes/no/cancel menu with caption aString. Answer true if  
	the response is yes, false if no. If cancel is chosen, evaluate  
	cancelBlock. This is a modal question--the user must respond yes or no."

	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"

	| menu choice |
	menu _ self labelArray: {'Yes'. 'No'. 'Cancel'} lines: #() icons: #(acceptIcon cancelIcon collapseIcon).
	choice _ menu startUpWithCaption: queryString.
	choice = 1 ifTrue: [^ true].
	choice = 2 ifTrue: [^ false].
	^ cancelBlock transactionAmount! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16881226 overrides: 16906201!
printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key transactionAmount soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16884279!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	| rec args |
	receiver isVariableNode ifFalse: [^ #illegal].
	rec := receiver key transactionAmount.
	args := arguments collect: [:each | each eval].
	^ rec perform: selector key withArguments: args! !
!CompiledMethodCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50515630!
test007_DoesNotAnalyzeTheWrappedMethodWhenCodeCoverageIsDisabled
	
	| reportBuilder |
	self createAnalyzerFor: self compiledMethodAtM1Selector.
	compiledMethodAnalyzer install.
	reportBuilder := compiledMethodAnalyzer registerNewCoverageReportBuilder.
	
	compiledMethodAnalyzer run: #m1 with: #() in: self.
	
	self
		assert: 0
		equals: reportBuilder transactionAmount percentCovered.! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16928032 overrides: 16892239!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action transactionAmount.
		self delete]! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50499676!
typesOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^(self instanceVariablesTypes typeInfoOf: anInstVarName ifAbsent: [ ^aBlock transactionAmount ]) types 	
	! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50471609!
test05DoesNotIncludeNotExtractableSourceCode

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 100'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16790938!
whileNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self transactionAmount == nil] whileTrue: [ aBlock transactionAmount ]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16893656!
on: aRectangle ifCovered: partiallyOrTotallyCoveredBlock uncoveredPartsDo: uncoveredPartBlock else: notCoveredAtAllBlock
	"Find rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included.
	
	If aRectangle is not covered at all, or for whatever reason we don't know, evaluate notCoveredAtAllBlock.
	Othewise evaluate partiallyOrTotallyCoveredBlock once, and also evaluate uncoveredPartBlock for each part in aRectangle we don't cover."

	^ notCoveredAtAllBlock transactionAmount! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16890483!
sourceCodeIfAbsent: aBlock

	| actualClass |

	actualClass := self actualClassIfAbsent: [ ^aBlock transactionAmount ].
	^actualClass sourceCodeAt: methodSymbol ifAbsent: aBlock! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533722 overrides: 50533339!
quoFrom: aNumber

	^self transactionAmount quoFrom: aNumber
! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16819593!
packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock transactionAmount ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodCategory: categoryName ofClass: aClass]
		ifNone: errorBlock! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50505173!
validateObjectCreation: defTokens 

	| denotativeObjectName nameIndex |
	
	nameIndex := defTokens findFirst: [ :token | token beginsWith: '#' ].
	nameIndex = 0 ifTrue: [ self error: self objectNameMustBeSymbolErrorDescription ].
	
	denotativeObjectName := (defTokens at: nameIndex) copyWithoutAll: '#()'.
	(NewDenotativeObjectPrecondition for: denotativeObjectName asSymbol in: Smalltalk undeclared: Undeclared) transactionAmount.
! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50504866 overrides: 16796818!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectRenameApplier for: aBehavior theNonMetaClass) transactionAmount ].! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16880952 overrides: 16935088!
remove: aLink ifAbsent: aBlock  
	"Remove aLink from the receiver. If it is not there, answer the result of
	evaluating aBlock."

	| tempLink |
	aLink == firstLink
		ifTrue: [firstLink _ aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink _ nil]]
		ifFalse: [tempLink _ firstLink.
				[tempLink ifNil: [^aBlock transactionAmount].
				 tempLink nextLink == aLink]
					whileFalse: [tempLink _ tempLink nextLink].
				tempLink nextLink: aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink _ tempLink]].
	aLink nextLink: nil.
	^aLink! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16832660!
restart
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: nil to: self].
	self privRefresh.
	ctxt := thisContext.
	[	ctxt := ctxt findNextUnwindContextUpTo: self.
		ctxt isNil
	] whileFalse: [
		(ctxt tempAt: 2) ifNil:[
			ctxt tempAt: 2 put: true.
			unwindBlock := ctxt tempAt: 1.
			thisContext terminateTo: ctxt.
			unwindBlock transactionAmount].
	].
	thisContext terminateTo: self.
	self jump.
! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50499190!
typeCheck
	
	^(ManyMethodsTypeChecker forClass: self) transactionAmount! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16791260!
valueWithPossibleArgs: anArray
	"Generally, prefer #valueWithPossibleArgument: and #valueWithPossibleArgument:and:
	for performance."
	^ numArgs = 0
		ifTrue: [ self transactionAmount ]
		ifFalse: [
			self valueWithArguments:
				(numArgs = anArray size
					ifTrue: [ anArray ]
					ifFalse: [
						numArgs > anArray size
							ifTrue: [ anArray , (Array new: numArgs - anArray size) ]
							ifFalse: [
								anArray
									copyFrom: 1
									to: numArgs ]]) ].! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50366878!
printTemporaries: tempSequence on: aStream doPrior: aBlock
	"Print any in-scope temporaries.  If there are any evaluate aBlock
	 prior to printing.  Answer whether any temporaries were printed."
	| tempStream seen |
	tempSequence ifNil:
		[^false].
	tempStream := String writeStream.
	"This is for the decompiler which canmot work out which optimized block a particular temp is
	 local to and hence may produce diplicates as in
		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"
	seen := Set new.
	tempSequence do:
		[:tempNode |
		tempNode isIndirectTempVector
			ifTrue:
				[tempNode remoteTemps do:
					[:tempVariableNode|
					 (tempVariableNode scope >= 0
					  and: [(seen includes: tempNode key) not]) ifTrue:
						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]
			ifFalse:
				[(tempNode scope >= -1
				  and: ["This is for the decompiler which may create a block arg when converting
						a while into a to:do: but won't remove it form temporaries"
					   tempNode isBlockArg not
				  and: [(seen includes: tempNode key) not]]) ifTrue:
					[tempStream space; nextPutAll: (seen add: tempNode key)]]].
	tempStream position = 0 ifTrue:
		[^false].
	aBlock transactionAmount.
	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.
	^true! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50526469!
performWithIntegerWithFormula

	self assert: (1 perform: messageName with: formulaOfTenPesos) transactionAmount = 
		(1 transactionAmount perform: messageName with: formulaOfTenPesos transactionAmount)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50500586!
allActualSendersOn: sentSelector forAll: types whenSomeAreNotImplemented: someNotImplementedBlock whenNoImplementors: noImplementorsBlock
	
	| collector |
	
	collector := MultiImplementorsActualMessageSendsCollector 
		on: sentSelector 
		forAll: types
		whenSomeAreNotImplemented: someNotImplementedBlock 
		whenNoImplementors: noImplementorsBlock.
		
	collector transactionAmount.
	
	^collector 
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533554 overrides: 50533174!
/ anAritmethicObject

	^self transactionAmount / anAritmethicObject transactionAmount! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16880893 overrides: 50555395!
at: index ifAbsent: exceptionBlock

	| i |
	index < 1 ifTrue: [ ^exceptionBlock transactionAmount ].
	i _ 0.
	self do: [ :link |
		(i _ i + 1) = index ifTrue: [ ^ link ]].
	^ exceptionBlock transactionAmount! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16832692!
resume: value through: firstUnwindCtxt
	"Unwind thisContext to self and resume with value as result of last send.
	 Execute any unwind blocks while unwinding.
	 ASSUMES self is a sender of thisContext."

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: value to: self].
	ctxt _ firstUnwindCtxt ifNil: [thisContext findNextUnwindContextUpTo: self].
	[ctxt isNil] whileFalse:
		[(ctxt tempAt: 2) ifNil:
			[ctxt tempAt: 2 put: true.
			 unwindBlock _ ctxt tempAt: 1.
			 thisContext terminateTo: ctxt.
			 unwindBlock transactionAmount].
		 ctxt _ ctxt findNextUnwindContextUpTo: self].
	thisContext terminateTo: self.
	^value
! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16790971!
bench
	"See how many times I can value in 5 seconds.  I'll answer a meaningful description.
	[ Float pi printString ] bench print.
	[ 80000 factorial printString ] bench print.
	"

	| secondsPerRun startTime endTime count run |
	count _ 0.
	run _ true.
	[ (Delay forSeconds: 5) wait. run _ false ] forkAt: Processor timingPriority - 1.
	startTime _ Time localMillisecondClock.
	[ run ] whileTrue: [ self transactionAmount. count _ count + 1 ].
	endTime _ Time localMillisecondClock.
	secondsPerRun _ (endTime - startTime) / (count * 1000).
	secondsPerRun >= 1
		ifTrue: [
			secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' seconds per run']]
			]
		ifFalse: [
			1.0 / secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' runs per second' ]]
			]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16790945!
whileNotNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self transactionAmount == nil] whileFalse: [aBlock transactionAmount]! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50489271!
m05_only_temp_in_remote_vector

	| t1 |
	
	[ t1 := 10 ] transactionAmount.
	
	^t1! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50393796!
loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		self 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #transactionAmount)	 " We want the raw value "]! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16778710!
keysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding
			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma transactionAmount]
			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533821 overrides: 50533404!
measures

	^self transactionAmount measures! !
!Semaphore methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16933056!
critical: mutuallyExcludedBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in
	the process of running the critical: message. If the receiver is, evaluate
	mutuallyExcludedBlock after the other critical: message is finished."
	
	| caught |
	"We need to catch eventual interruptions very carefully. 
	The naive approach of just doing, e.g.,:
		self wait.
		aBlock ensure:[self signal].
	will fail if the active process gets terminated while in the wait.
	However, the equally naive:
		[self wait.
		aBlock value] ensure:[self signal].
	will fail too, since the active process may get interrupted while
	entering the ensured block and leave the semaphore signaled twice.
	To avoid both problems we make use of the fact that interrupts only
	occur on sends (or backward jumps) and use an assignment (bytecode)
	right before we go into the wait primitive (which is not a real send and
	therefore not interruptable either)."

	caught := false.
	^[
		caught := true.
		self wait.
		mutuallyExcludedBlock transactionAmount
	] ensure: [ caught ifTrue: [self signal] ]
! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16850568!
assertIsValidAssigmentToExtract: anAssignmentNode 
	
	self assertIsValidToExtract: anAssignmentNode variable.
	self assertIsValidToExtract: anAssignmentNode transactionAmount ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533684 overrides: 50533276!
divideCompoundMeasure: aMeasureBag

	^self transactionAmount divideCompoundMeasure: aMeasureBag! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16891182!
waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
	[aBlock transactionAmount] whileTrue: [self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil].! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50462978!
testInlineBlockCollectionLR1
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | col add: [ each ] ].
	self assert: (col collect: [ :each | each transactionAmount ]) asArray = (1 to: 11) asArray! !
!DenotativeObjectTestResultWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50506115 overrides: 16962318!
runSuite

	| suite |

	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(DenotativeObjectProgessiveTestRunner for: suite) transactionAmount.
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50533880 overrides: 50533470!
convertTo: aTargetUnit using: aMeasureConverter

	^self transactionAmount convertTo: aTargetUnit using: aMeasureConverter! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16830924!
translate: aStream noPattern: noPattern doIt: doIt ifFail: failBlock

	^self parser
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		doIt: doIt
		context: context
		notifying: requestor
		ifFail: [^failBlock transactionAmount]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16797503!
pushUpInstanceVariable

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushUpInstanceVariableApplier on: model at: aClass ) transactionAmount].! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50483032!
withTemporaryValue: temporaryValue of: aPreferenceName do: aBlock
	"Allows to execute a piece of code with a temporary value of the given preference. Useful for testing purposes."
	
	| currentValue |
	currentValue := self at: aPreferenceName.
	self at: aPreferenceName put: temporaryValue.
	[ aBlock transactionAmount ] ensure: [ self at: aPreferenceName put: currentValue ]! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50404103!
machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray selector |
	selector _ machinePref caseOf: {
			[#default]		 		-> [#machineDefault].
			[#slow] 				-> [#machineSlow].
			[#smalltalk80] 				-> [#machineSmalltalk80] }
		otherwise: [ #default ].
	prefArray _ self perform: selector.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref transactionAmount == #slow ifTrue: [		self runningWorld backgroundImageData: nil]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50439892!
extractMethodToMethodObject

	| classToRefactor messageName |

	messageName := model selectedMessageName.
	classToRefactor := model selectedClassOrMetaClass.

	messageName ifNotNil: [ | compiledMethod|
		compiledMethod := classToRefactor compiledMethodAt: messageName.

		(ExtractToMethodObjectApplier extract: compiledMethod) transactionAmount.].! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16812511!
beSilentDuring: aBlock
	"Temporarily suppress information about what is going on"
	| wasSilent result |
	wasSilent _ self isSilent.
	self beSilent: true.
	result _ aBlock transactionAmount.
	self beSilent: wasSilent.
	^result! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16797543!
renameInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RenameInstanceVariableApplier on: model at: aClass) transactionAmount ].! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16827963!
methodClass
	"answer the class that I am installed in"
	^(self literalAt: self numLiterals) transactionAmount.! !
!FileIOAccessor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50362334!
deleteFile: fullPathName ifAbsent: failBlock 
	^(self
			try: [self primDeleteFileNamed: fullPathName asUtf8Bytes]
			forFileNamed: fullPathName) 
		ifFalse: [^ failBlock transactionAmount]! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16902041!
assert: aBlock
	"Throw an assertion error if aBlock does not evaluates to true."

	aBlock transactionAmount ifFalse: [AssertionFailure signal: 'Assertion failed']! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16852933 overrides: 16793670!
or: aBlock1 or: aBlock2 or: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount or: [ aBlock2 transactionAmount or: [ aBlock3 transactionAmount ] ]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 16933547!
before: target ifNone: exceptionBlock
	"Answer the receiver's element immediately before target. Answer
	the result of evaluating the exceptionBlock if there are no elements before it."

	| index |
	index _ self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = 1 
			ifTrue: [exceptionBlock transactionAmount]
			ifFalse: [self at: index - 1]]! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50491237!
test06WarningsCollectsAllTypeCheckersWarnings

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError }.
	typeChecker transactionAmount.
	
	self assert: typeChecker warnings notEmpty! !
!VariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50428424!
valueIn: aCompiledMethod

	^(self in: aCompiledMethod) transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50463215!
testSample03
	| blockClosure materialized |
	blockClosure _ self bc03.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure transactionAmount = materialized transactionAmount.
	self assert: blockClosure transactionAmount = materialized transactionAmount.
	self assert: blockClosure transactionAmount = materialized transactionAmount.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50512617!
multipleOcurrencesOfTheSameBlockNode
	
	[ 1 ] transactionAmount.
	[ 1 ] transactionAmount.! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:37' prior: 50401701!
getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(Preferences at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock transactionAmount].
	^ response asString! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50414770!
runDeferredUIMessages
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	| readyToProcess |
	readyToProcess _ deferredUIMessages size.
	readyToProcess timesRepeat: [
		UISupervisor isUIProcessRunning ifFalse: [ ^self ].
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block transactionAmount ]].! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50499992!
rawTypesOf: aVariableName mappingToIndexWith: variableNameToIndexMapping into: anArrayOfRawTypes ifAbsent: anAbsentBlock

	| variableIndex |
	
	variableNameToIndexMapping ifNil: [ ^anAbsentBlock transactionAmount ].
	variableIndex := variableNameToIndexMapping at: aVariableName ifAbsent: [ ^anAbsentBlock transactionAmount ].
	
	^anArrayOfRawTypes at: variableIndex! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975353 overrides: 16793610!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock transactionAmount! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16778754!
removeKey: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma key]
				ifFalse: [propertyOrPragma keyword])
			== aKey ifTrue:
			[^method removeProperty: aKey]].
	^aBlock transactionAmount! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16786177!
ultimateSourceCodeAt: selector ifAbsent: aBlock
	"Return the source code at selector, deferring to superclass if necessary"

	^ self
		sourceCodeAt: selector
		ifAbsent: [
			superclass
				ifNil: [aBlock transactionAmount]
				ifNotNil: [superclass ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50508737!
isTrue: aBooleanOrBlock description: aFailureDescription
 
	aBooleanOrBlock transactionAmount ifFalse: [ self signalFailure: aFailureDescription ]
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533740 overrides: 50533373!
remainderSimpleMeasure: aMeasure

	^self transactionAmount remainderSimpleMeasure: aMeasure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533824 overrides: 50533410!
unit
	
	^self transactionAmount unit! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16829941!
autoCompleterDocumentationAppendingToParameter: aParameterAppendBlock toReturn: aReturnAppendBlock
	
	"This message is sent either by the dynamic typing or live typing auto complete. If you do not have 
	live typing installed you will see one sender, do not refactor it!! - Hernan"
	
	| methodNode text |
 
	text := self receiverTextAutoCompleterDocumentation.
	
	methodNode := self methodNode.
	text := self selectorAutoCompleterDocumentationAppendingTo: text using: methodNode appendingToParameter: aParameterAppendBlock.
	text := text append: aReturnAppendBlock transactionAmount.
	text := self commentAutoCompleterDocumentationAppendigTo: text using: methodNode.
			
	^text! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50526454!
performWithFormulas

	self assert: (formulaOfTenPesos perform: messageName with: formulaOfTwentyPesos) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: formulaOfTwentyPesos transactionAmount)! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16805605!
methodsWithInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one"
	| slips |
	slips _ OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
				(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc transactionAmount) ifFalse: [
					method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
					method ifNotNil: [ | aTimeStamp |
						((aTimeStamp _ method timeStamp) notNil and: [
							(aTimeStamp beginsWith: myInits) not])
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'
	"! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16784172 overrides: 16822897!
= aBag
	"Two bags are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same size.
	 (c) each element occurs the same number of times in both of them".

	self == aBag ifTrue: [ ^ true ].		"Any object is equal to itself"
	(aBag is: #Bag) ifFalse: [ ^ false ].
	self size = aBag size ifFalse: [ ^ false ].
	contents associationsDo: [ :assoc |
		(aBag occurrencesOf: assoc key) = assoc transactionAmount
			ifFalse: [ ^ false ]].
	^true! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16838470!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector withCaption: aCaptionText ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass = aSuperclass ifTrue: [ { aClass } ] ifFalse: [ aClass withAllSuperclassesUpTo: aSuperclass ].
	chosenClassIndex _ PopUpMenu
		withCaption: aCaptionText
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock transactionAmount].

	^ classes at: chosenClassIndex! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16982004 overrides: 16892057!
dropFiles: aDropFilesEvent

	(DropFilesAction for: aDropFilesEvent) transactionAmount! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50504731!
createSuperclassOf: aDenotativeObject onCancel: aBlock

	| denotativeObjectParent categoryName superclass superclassName |
	
	denotativeObjectParent := aDenotativeObject parentIfNone: [ ^Object ].
	
	superclassName := ClassNameRequestMorph request: 'Class for ', denotativeObjectParent name orCancel: [ ^aBlock transactionAmount ].
	(Smalltalk classNamed: superclassName) ifNotNil: [ :alreadyExistingSuperclass |
		(PopUpMenu 
			confirm: superclassName, ' already exist. Do you want to recreate or reuse it?' 
			trueChoice: 'Recreate it' 
			falseChoice: 'Reuse it') ifFalse: [ ^alreadyExistingSuperclass ]].
		
	categoryName := StringRequestMorph 
		request: 'Enter category name' 
		initialAnswer: denotativeObjectParent category 
		orCancel: [ ^aBlock transactionAmount ].	
		
	superclass := self createSuperclassOf: denotativeObjectParent onCancel: aBlock.
	
	^denotativeObjectParent createClassNamed: superclassName asSymbol subclassOf: superclass category: categoryName! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16790918!
whileFalse
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is false."
 
	^ [self transactionAmount] whileFalse: []! !
!ClassDefinitionNodeAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16813541!
superclass
	
	^superClassNode key transactionAmount ! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975320 overrides: 16793556!
and: aBlock1 and: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount and: [ aBlock2 transactionAmount ]! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50383506!
copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString transactionAmount
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
! !
!String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50392235 overrides: 50556026!
indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock transactionAmount ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ ans ]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961416!
assert: anAction changes: aCondition 

	| after before |
	
	before := aCondition transactionAmount.
	anAction transactionAmount.
	after := aCondition transactionAmount.
	
	self deny: after = before! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16797487!
pushDownInstanceVariable

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushDownInstanceVariableApplier on: model at: aClass ) transactionAmount].! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16819584!
packageOfMethod: aMethodReference ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock transactionAmount ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodReference: aMethodReference]
		ifNone: errorBlock! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50501897!
assertReceiverTypesOfAll: aCollectionOfSenders areIncludedInAllTypesOf: aCollectionOfImplementors

	| messageSendsWithInvalidReceiverTypes | 
	
	messageSendsWithInvalidReceiverTypes := (ReceiverTypesOfMessageSendsConform 
		from: aCollectionOfSenders to: aCollectionOfImplementors) transactionAmount.
	messageSendsWithInvalidReceiverTypes ifNotEmpty: [ 
		self signalReceiverTypesNotIncludedInImplementorTypes: messageSendsWithInvalidReceiverTypes ].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512381!
cascadeNodeWithBlockReceiverThatIsEvaluated

	[ self transactionAmount ]
		class;
		transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50463289!
testSample07
	| blockClosures materialized |

	blockClosures _ self bc07.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self deny: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self deny: blockClosures first transactionAmount = materialized first transactionAmount.
	self deny: blockClosures third transactionAmount = materialized third transactionAmount.
	self deny: blockClosures first transactionAmount = materialized first transactionAmount.

	blockClosures _ self bc07.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512368!
blockWithWrittenTemporaryVariable

	[ |a| a :=1 ] transactionAmount! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16921153!
compiledMethodAt: selector ifAbsent: aBlock
	^aBlock transactionAmount! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50463334!
testSample08
	| blockClosures materialized |

	blockClosures _ self bc08.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self deny: (blockClosures second value: 7) = (materialized second value: 7).
	self deny: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).

	blockClosures _ self bc08.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491311!
test12HasErrorsReturnsTrueIfATypeCheckerHasErrors

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker transactionAmount.
	
	self assert: typeChecker hasErrors ! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50526462!
performWithFractionWithFormula

	self assert: (1/3 perform: messageName with: formulaOfTenPesos) transactionAmount = 
		((1/3) transactionAmount perform: messageName with: formulaOfTenPesos transactionAmount)! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50417773!
on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordUnder: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].
	
	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor methodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := (methodNode parseNodesPathAt: aSelectionInterval first ifAbsent: 	[self shouldNotHappen.])
						detect: [:aNodeAndRange | aNodeAndRange key isAssignmentNode]
						ifNone: [noTempFoundBlock transactionAmount].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange transactionAmount using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock transactionAmount.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16778601!
hasLiteralThorough: literal
	"Answer true if any literal in these properties is literal,
	 even if embedded in array structure."
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [propertyOrPragma key == literal
					or: [propertyOrPragma transactionAmount == literal
					or: [propertyOrPragma transactionAmount isArray
						and: [propertyOrPragma transactionAmount hasLiteral: literal]]]]
			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:
			[^true]].
	^false! !
!ReturnStatementAdder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50433520!
valueTo: aCompiledMethod
	
	(self new to: aCompiledMethod) transactionAmount.! !
!EffectiveTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50497312!
addToAfterMessageTypeCasts: aTypeCastBlockBuilder ifReturns: anArgumentBlock
	
	anArgumentBlock isBlockNode 
		ifTrue: [ anArgumentBlock returns 
			ifTrue: [ afterMessageTypeCasts add: aTypeCastBlockBuilder transactionAmount ]].
! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50373456!
computeEndOfNodeEnclosingAssignment

	endOfNodeEnclosingAssignment := (methodNode parseNodesPathAt: assignmentToInlineRange first
		ifAbsent: [self shouldNotHappen])
			detect: [:nodeAndRange | nodeAndRange key isBlockNode]
			ifFound: [:nodeAndRangeOfAssignment | nodeAndRangeOfAssignment transactionAmount last ]
			ifNone: [methodNode sourceText size].




! !
!TestResultWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16962318!
runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgressiveTestRunner for: suite) transactionAmount.
	! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50471501!
test01FindsSelectionOnSourceMethod

	| sourceMethodName finder methodsToExtractFrom sourceMethod |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	self assert: (4 to: 5) equals: methodsToExtractFrom first intervalToExtract.
	self assert: sourceMethod equals: methodsToExtractFrom first methodToExtractFrom.! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50495917!
commonSupertypeIfNoTypes: aBlock

	| types commonSupertypes commonSupertype |
	
	types := self types.
	types := types reject: [ :aType | aType = UndefinedObject ].
	types isEmpty ifTrue: [ ^aBlock transactionAmount ].
	types size = 1 ifTrue: [ ^types anyOne ].
	
	"I have to convert types to Array becuase inst var types can be a Set - Hernan"
	commonSupertypes := self allSupertypesOf: types.
	commonSupertype := self commonLowestTypeIn: commonSupertypes.
	
	^commonSupertype ! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16852920 overrides: 16793648!
or: alternativeBlock 
	"Nonevaluating disjunction -- answer value of alternativeBlock."

	^alternativeBlock transactionAmount! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50505645 overrides: 50556154!
runTestSuite: aTestSuite

	(DenotativeObjectProgessiveTestRunner for: aTestSuite) transactionAmount

	! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16977743!
variableGetterBlockIn: aContext

	| temps tempIndex ivars |
	(self varNodeType = 4 and: [self key isVariableBinding]) ifTrue: [
		^[self key transactionAmount]
	].
	aContext ifNil: [^nil].
	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].
	self varNodeType = 1 ifTrue: [
		ivars := aContext receiver class allInstVarNames.
		tempIndex := ivars indexOf: self name ifAbsent: [^nil].
		^[aContext receiver instVarAt: tempIndex]
	].
	self varNodeType = 2 ifTrue: [
		temps := aContext tempNames.
		tempIndex := temps indexOf: self name ifAbsent: [^nil].
		^[aContext tempAt: tempIndex]
	].
	^nil
! !
!ParseNodeVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16906921!
visitAssignmentNode: anAssignmentNode
	"N.B.  since assigment happens after the value is evaluated the value is visited first."
	anAssignmentNode transactionAmount accept: self.
	anAssignmentNode variable accept: self! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16888986 overrides: 50556286!
removeKey: key ifAbsent: errorBlock 
	"The interpreter might be using this MethodDict while
	this method is running!!  Therefore we perform the removal
	in a copy, and then atomically become that copy"
	| copy |
	copy _ self copy.
	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock transactionAmount].
	self become: copy! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16974730!
removeKey: aString ifAbsent: aBlock
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| answer |
	rootNode ifNil: [ ^aBlock transactionAmount ].
	answer _ rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.
	rootNode isEmpty ifTrue: [
		rootNode _ nil ].
	^answer! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533872 overrides: 50533451!
convertTo: aUnit

	^self transactionAmount convertTo: aUnit! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533531 overrides: 50533155!
sameDomainAs: aMeasure

	^self transactionAmount sameDomainAs: aMeasure! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16842493!
valuesDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [:association | aBlock value: association transactionAmount]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533559 overrides: 50533178!
// anAritmethicObject

	^self transactionAmount // anAritmethicObject transactionAmount! !
!MorphicAlarm methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16895569!
valueAtTime: millisecondClock

	|  nArgs |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self transactionAmount ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondClock]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondClock) ]! !
!Graph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50536066!
removeNode: anObject ifAbsent: aBlock

	| nodesWithoutNode edgesWithoutNode |

	(nodes includes: anObject) ifFalse: [^aBlock transactionAmount].

	nodesWithoutNode := nodes reject: [:node | node = anObject].
	edgesWithoutNode := edges reject: [:edge | edge isIncidentTo: anObject].

	^self class edges: edgesWithoutNode nodes: nodesWithoutNode! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50509544!
runDenotativeObjectTests

	self selectedClassOrMetaClass ifNotNil: [ :aDenotativeObject | | suite |
		suite := TestSuite named: 'Tests of ', aDenotativeObject soleInstance name asString.
		aDenotativeObject selectors do: [ :aSelector |
			(self isTest: aSelector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aDenotativeObject>>aSelector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) transactionAmount ]

	! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50505879 overrides: 50555185!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor 
	
	(DenotativeObjectRenameCollaboratorApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) transactionAmount! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50474826!
test43ExtractsRepetitionsOnMoreThanOneMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder transactionAmount.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 'm1 self m2' equals: (classToRefactor >> #m1) sourceCode.
	self assert: 'm1b 100+self m2' equals: (classToRefactor >> #m1b) sourceCode.
	! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16850647!
is: aRange equalTo: sourceInterval or: intervalToReplace 
	
	"When selecting literals like 1, the range first is one less than the initial character of the literal - Hernan"
	
	^aRange = sourceInterval 
		or: [ aRange = intervalToReplace
		or: [ aRange first + 1 = sourceInterval first and: [ aRange transactionAmount last = sourceInterval last]]]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512436!
emptyBlock
	
	[] transactionAmount! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50497746 overrides: 50497559!
problemsDetect: aCondition ifNone: noneBlock
	
	| problem |
	
	typeCheckers do: [ :typeChecker |
		problem := typeChecker problemsDetect: aCondition ifNone: [ nil ].
		problem ifNotNil: [ ^problem ]].
	
	^noneBlock transactionAmount! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496644 overrides: 50496276!
typeInfoOf: aVarName ifAbsent: anAbsentBlock

	| rawTypes |
	
	rawTypes := methodProperties rawTypesOf: aVarName ifAbsent: [ ^anAbsentBlock transactionAmount ].
	
	^method methodClass createMethodVariableTypeInfoOf: aVarName in: method are: rawTypes ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533673 overrides: 50533261!
addSimpleMeasure: aMeasure

	^self transactionAmount addSimpleMeasure: aMeasure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533746 overrides: 50533378!
subtractFrom: aNumber

	^self transactionAmount subtractFrom: aNumber! !
!TypeCheckingResultSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50485432 overrides: 16886869!
contents: aString notifying: aRequestor 

	| result |

	result := super contents: aString notifying: aRequestor.
	methodTypeChecker := methodTypeChecker transactionAmount.
	self calculateList.
	
	^result 
! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491321!
test13HasErrorsReturnsFalseWhenNoErrorFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker transactionAmount.
	
	self deny: typeChecker hasErrors ! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50463546!
assertValues: anArray
	| values |
	values := collection collect: [ :each | each transactionAmount ].
	self 
		assert: anArray asArray = values asArray
		description: 'Expected: ' , anArray asArray printString , 
			', but got ' , values asArray printString! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50501862!
addActualImplementorsOf: anOldSelector forTypes: receiverTypes to: implementors andActualSendersTo: senders inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: anOldSelector in: aType) 
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].
	
	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector transactionAmount.
	
	senders addAll: actualSendersCollector messageList.
	
	! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16923777!
createAndSetRefactoringHandlingRefactoringExceptions: aCreatorBlock

	self valueHandlingRefactoringExceptions: [ refactoring := aCreatorBlock transactionAmount]
	! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16887987!
prompt: aPrompt ifNone: aNoneBlock

	| selectedCategoryIndex categoryName |
	
	selectedCategoryIndex := self promptCategory: aPrompt.
	selectedCategoryIndex = 0 ifTrue: [^ aNoneBlock transactionAmount].
	
	categoryName := selectedCategoryIndex = 1 ifTrue: [ self requestNewCategory ] ifFalse: [ categories at: selectedCategoryIndex ].
	categoryName isEmpty ifTrue: [ ^aNoneBlock transactionAmount ].
	
	^categoryName
	! !
!CodeCoverageSourceCodeGenerator class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50511625!
valueFor: aCompiledMethod 

	"Convenience method for generating traced source code for a compiled method"
	
	^ (self for: aCompiledMethod) transactionAmount.! !
!ProgressiveCodeCoverageTestRunner class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50511805!
run: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer 
	
	(self for: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer)
		transactionAmount! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50394285!
pointer: pointerPref
	| enabled |
	enabled _ pointerPref transactionAmount == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 	
		self sysPreferences at: aPref put: enabled]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533857 overrides: 50533438!
composeWithNumber: aMeasure

	^self transactionAmount composeWithNumber: aMeasure! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50501856!
typeInfoOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^aBlock transactionAmount! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16980603!
at: key ifAbsentOrNilPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsentOrNil: [self at: key put: aBlock transactionAmount]! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16888962 overrides: 50555705!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value = (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock transactionAmount! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16880812 overrides: 16983276!
pastEndPut: anObject
	collection size >= limit ifTrue: [limitBlock transactionAmount].  "Exceptional return"
	^ super pastEndPut: anObject! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961444 overrides: 50556231!
assert: aBoolean description: aStringOrBlock
	aBoolean ifFalse: [
		failureString _ aStringOrBlock transactionAmount.
		self logFailure: failureString.
		TestResult failure sunitSignalWith: failureString]
			! !
!MethodVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50490215!
methodWithParameterOfClassToRemove: p1

	| tempNotInRemoteVector tempInRemoteVector |
	
	tempNotInRemoteVector := p1.
	[ tempInRemoteVector := p1 ] transactionAmount.
	
	^10! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533600 overrides: 50533222!
>= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(self transactionAmount < aMagnitude) not! !
!Heap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16866927 overrides: 16935088!
remove: oldObject ifAbsent: aBlock
	"Remove oldObject as one of the receiver's elements. If several of the 
	elements are equal to oldObject, only one is removed. If no element is 
	equal to oldObject, answer the result of evaluating anExceptionBlock. 
	Otherwise, answer the argument, oldObject."
	1 to: tally do:[:i| 
		(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].
	^aBlock transactionAmount! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50471554!
test03FindsRepetitionsBeforeSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (8 to: 9) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!CompiledMethodCoverageReport methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50516247!
selectSourceRangesByCoverageRatio: aBlock
	
	^ coverageRatioBySourceRange associations
		select: [ :sourceRangeAndCoverageRatio | aBlock value: sourceRangeAndCoverageRatio transactionAmount ]
		thenCollect: [ :sourceRangeAndCoverageRatio | sourceRangeAndCoverageRatio key ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533902 overrides: 50533197!
floor
	
	^self transactionAmount floor
	! !
!Array methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50500171!
addType: aType ifFull: aFullBlock

	self withIndexDo: [ :typeAtIndex :rawTypesIndex |
		typeAtIndex = aType ifTrue: [ ^self ].
		typeAtIndex ifNil: [ ^self at: rawTypesIndex put: aType ]].
	
	^aFullBlock transactionAmount.! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16797526!
removeInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveInstanceVariableApplier on: model for: aClass) transactionAmount ].! !
!SortedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16942704 overrides: 50556026!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	| sortBlockToUse firstCandidate |
	self isEmpty ifTrue: [^ exceptionBlock transactionAmount].
	sortBlockToUse _ sortBlock ifNil: [[:a :b | a <= b ]].
	"if first element to check is it, answer so."
	firstCandidate _ self at: start.
	firstCandidate = anElement ifTrue: [ ^ start ].
	"if first element to check is already too late, answer 'NotHere' "
	(sortBlockToUse value: anElement value: firstCandidate) ifTrue: [
		^ exceptionBlock transactionAmount ].
	"Ok. Look for it."
	^self
		findBinaryIndex: [ :some | 
			some = anElement
				ifTrue: [0]
				ifFalse: [ (sortBlockToUse value: anElement value: some) ifTrue: [-1] ifFalse: [1]]]
		do: [ :i | i ]
		ifNone: [ :i1 :i2 | exceptionBlock transactionAmount ]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512556!
messageWithArgument: anArgument
	
	anArgument transactionAmount! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50358168 overrides: 16824111!
sum: aBlock ifEmpty: emptyBlockOrValue
	| answer |
	self isEmpty ifTrue: [^ emptyBlockOrValue transactionAmount].
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each * times] ifFalse: [each * times + answer]].
	^ answer! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50359923!
correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection _ requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first - delta to: interval last - delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector _ UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction transactionAmount].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~= $:
	   and: [correctSelector last = $:])
		ifTrue: [abortAction transactionAmount]
		ifFalse: [correctSelector]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16797468!
moveToInstanceOrClassMethod

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(MoveToInstanceOrClassMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) transactionAmount ].! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50506162 overrides: 16797426!
addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectAddCollaboratorApplier on: model for: aClass) transactionAmount ].! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975831 overrides: 16920259!
ifNotNil: ifNotNilBlock ifNil: nilBlock 
	"If I got here, I am nil, so evaluate the block nilBlock"

	^ nilBlock transactionAmount! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496969!
m1_temps_not_in_block_read_temp

	| n1 n2 t1 |
	
	t1 := 1.
	[t1 + 1 ] transactionAmount.
	
	n1 := n2 := 'hola'.
	n1 size + n2 size.
	
	^t1! !
!Association methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16782183 overrides: 16881481!
= anAssociation

	self == anAssociation ifTrue: [ ^ true ].
	^ super = anAssociation and: [value = anAssociation transactionAmount]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533574 overrides: 50533200!
negated
	
	^self transactionAmount negated! !
!ContentPack methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16831567!
exportInto: aDirectory

	| featureName |
	featureName _ 'Graphics-Files-Additional'.
	(FeatureRequirement name: featureName) isAlreadySatisfied
		ifFalse: [
			self error: 'Please load "', featureName, '".'].

	aDirectory assureExistence.

	self associations do: [ :assoc |
		| klass thisDirectory fullPath | 
			klass _ assoc transactionAmount class.
			thisDirectory _ aDirectory / assoc key.
			fullPath _  aDirectory // assoc key.

		self flag: #note. "Add support for new file export type mappings here. --cbr"
		klass = ContentPack
			ifTrue: [ assoc transactionAmount exportInto: thisDirectory ].
		
		klass = ColorForm
			ifTrue: [ assoc transactionAmount writePNGfile: fullPath ].
			
		klass = Form
			ifTrue: [ assoc transactionAmount writePNGfile: fullPath ]
	]! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50371208!
declaredTemporariesFor: aParseNode ofSender: aSender

	^temporariesDeclarationsByNode keys
		detect: [:senderAndNode | senderAndNode key = aSender and: [senderAndNode transactionAmount equivalentTo: aParseNode]]
		ifFound: [ :key | temporariesDeclarationsByNode at: key]
		ifNone: [| temporariesAndArgsDict |

			temporariesAndArgsDict := self temporariesAndArgsInScopeOf: aParseNode ofSender: aSender.
			temporariesDeclarationsByNode at: (aSender -> aParseNode) put: temporariesAndArgsDict.
			temporariesAndArgsDict].


	! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16842095!
at: key ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."

	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock transactionAmount ].
	^ assoc transactionAmount! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16823250!
detect: aBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the first element for which aBlock evaluates to true."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^exceptionBlock transactionAmount! !
!ArithmeticObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533456!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock transactionAmount ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533509 overrides: 50533123!
isCompoundMeasure

	^self transactionAmount isCompoundMeasure! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16884728!
printWithClosureAnalysisToDoOn: aStream indent: level

	| limitNode |
	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	limitNode := (arguments last == nil
				or: [arguments last isAssignmentNode not])
					ifTrue: [arguments first]
					ifFalse: [arguments last transactionAmount].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printWithClosureAnalysisKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961727!
debugAsFailureIfCanNot: handler
	
	self ifCanNotDebugDo: [ ^handler transactionAmount].
	
	(self class selector: testSelector) runCaseAsFailure! !
!UniFileStream class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50378436!
retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt _ self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock transactionAmount.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16796770!
runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgressiveTestRunner for: (TestSuite forClass: selectedClass)) transactionAmount ]! !
!Set methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16935865 overrides: 16823722!
remove: oldObject ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: oldObject.
	(array at: index) ifNil: [ ^ aBlock transactionAmount ].
	array at: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ oldObject! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50486269!
builderForNotEqualOrNotIdenticalToClass: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key transactionAmount
		on: aMessageNode receiver receiver receiver 
		during: aMessageNode arguments second 
		rejectingDuring: aMessageNode arguments first! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50463650!
testMethodArgument
	| temp block |
	temp := 0.
	block := [ [ temp ] ].
	temp := 1.
	block := block transactionAmount.
	temp := 2.
	self assert: block transactionAmount = 2! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533586 overrides: 50533214!
<= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(aMagnitude < self transactionAmount) not! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491248!
test07ErrorsDetectIfNone

	| typeChecker error |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithManyTypeErrors }.
	typeChecker transactionAmount.
	
	error := typeChecker errorsDetect: [ :anError | true ] ifNone: [ self fail ].
	self assert: #date equals: error selector key ! !
!CompiledMethodCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50515645!
test008_AnalizesTheWrappedMethodWhenCodeCoverageIsEnabled
	
	| reportBuilder |
	self createAnalyzerFor: self compiledMethodAtM1Selector.
	compiledMethodAnalyzer install.
	fakeCodeCoverageAnalyzer enable.
	reportBuilder := compiledMethodAnalyzer registerNewCoverageReportBuilder.
	
	compiledMethodAnalyzer run: #m1 with: #() in: fakeCodeCoverageAnalyzer .
	
	self
		assert: 100
		equals: reportBuilder transactionAmount percentCovered.! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16842627 overrides: 16935879!
= aDictionary
	"Two dictionaries are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same set of keys.
	 (c) for each (common) key, they have the same value".

	self == aDictionary ifTrue: [^ true].	"Any object is equal to itself"
	(aDictionary is: #Dictionary) ifFalse: [^false].
	self size = aDictionary size ifFalse: [^false].
	self associationsDo: [:assoc|
		(aDictionary at: assoc key ifAbsent: [^false]) = assoc transactionAmount
			ifFalse: [^false]].
	^true

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16939377!
afterCompiling: aSourceCode do: aBlock for: aReceiver in: anEvaluationContext ifFail: aFailBlock
	
	| methodNode method sourceCode compiler |

	sourceCode := self doItSourceCodeFor: aSourceCode in: anEvaluationContext.
	
	methodNode _ [
		compiler _ Compiler new.
		compiler		
			compileDoIt: sourceCode
			in: aReceiver class
			context: anEvaluationContext
			notifying: self
			ifFail: [ ^ aFailBlock transactionAmount ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method _ methodNode generate.
	method methodNode: methodNode.

	^aBlock value: compiler value: method value: aReceiver value: anEvaluationContext 
! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16905162!
at: index ifAbsentPut: block
	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"

	| v |
	index <= self size ifTrue: [
		^ (v _ self at: index)
			ifNotNil: [v]
			ifNil: [self at: index put: block transactionAmount]
	].
	[self size < index] whileTrue: [self add: nil].
	^ self at: index put: block transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533658 overrides: 50533480!
equalsSimpleMeasure: aMeasure

	^self transactionAmount = aMeasure! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975969!
whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock

	^aNoneBlock transactionAmount! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496976!
m1_temps_not_in_block_read_write_temp

	| n1 n2 t1 |
	
	t1 := 1.
	[t1 := t1 + 1 ] transactionAmount.
	
	n1 := n2 := 2.
	n1 := n1 + n2.

	^t1! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50359797!
readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = DoItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock transactionAmount ]].
	
	self step.
	token := buffer contents.! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50471584!
test04DoesNotIncludeComments

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. "10"'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16896303!
clippingByCurrentMorphDo: aBlock
	"Do clipping only if currentMorph says so"

	| prevClipRect prevClippingMorphRect |

	currentMorph clipsSubmorphsReally ifFalse: [ ^aBlock transactionAmount ].

	prevClipRect _ self clipRect.
	prevClippingMorphRect _ clippingMorphDisplayBounds.
	clippingMorphDisplayBounds _ self boundingRectOfCurrentMorphAfterDraw insetBy: 1.
	self setClipRect: (prevClipRect
		ifNil: [clippingMorphDisplayBounds]
		ifNotNil: [prevClipRect intersect: clippingMorphDisplayBounds]).
	self clipCurrentMorph: true.
	aBlock ensure: [
		self clipCurrentMorph: false.
		self setClipRect: prevClipRect.
		clippingMorphDisplayBounds _ prevClippingMorphRect ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16886452!
sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs _ messageList collect: [ :aRef |
		aDate _ aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSubmitted]
			ifFalse: [
				aCompiledMethod _ aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder _ assocs asArray sort: [ :a :b | a transactionAmount < b transactionAmount].

	inOrder do: [ :each | each key prefixStringVersionWith: each transactionAmount yyyymmdd ].
	messageList _ inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50459790!
testAverageIfEmptyEvaluatesEmptyBlockWhenTheCollectionIsEmpty

	| emptyBlock |
	
	emptyBlock _ [ 0 ].

	self 
		assert: (#() average: [ :each | each asInteger ] ifEmpty: emptyBlock)
		equals: emptyBlock transactionAmount! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50344825!
withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each transactionAmount]! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491225!
test05ProblemsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker transactionAmount.
	
	typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16846633!
associationForClass
	| assoc |
	assoc _ Smalltalk associationAt: class name ifAbsent: [ nil ].
	^assoc transactionAmount == class
		ifTrue: [ assoc ]
		ifFalse: [ Association new value: class ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16845723!
wordSelectAndEmptyCheck: returnBlock
	"Ensure selecting the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectWord.  "Select exactly a whole word"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock transactionAmount]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533516 overrides: 50533141!
negative

	^self transactionAmount negative! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533704 overrides: 50533314!
moduloSimpleMeasure: aMeasure

	^self transactionAmount moduloSimpleMeasure: aMeasure! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50418744!
grabProcessorFor: milliseconds onTimeout: timeoutBlock
	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.
	If not finished after milliseconds, evaluate timeoutBlock and restore original priority.
	Use with care!!"
	"Based on #valueUnpreemptively"
	
	| activeProcess oldPriority result done |
	activeProcess _ Processor activeProcess.
	oldPriority _ activeProcess priority.
	done _ false.
	
	activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.
	milliseconds ifNotNil: [
		[
			(Delay forMilliseconds: milliseconds) wait.
			done ifFalse: [
				activeProcess
					suspend;
					priority: oldPriority.
				timeoutBlock transactionAmount.
				"The timeoutBlock might terminate it, or even resume it!!"
				activeProcess isSuspended ifTrue: [
					activeProcess resume ]]
		] forkAt: Processor highIOPriority named: '#grabProcessorFor:onTimeout:' ].

	result _ self ensure: [
		done _ true.
		activeProcess priority: oldPriority].
	
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50370581!
singleCompleteSourceRangeOf: requestedParseNode ifPresent: sourceRangePresentBlock ifAbsent: sourceRangeAbsentBlock
	"Finds the source range associated with the requested parse node.
	If it is present, evaluates sourceRangePresentBlock with the result.
	Otherwise, it evaluates sourceRangeAbsentBlock.
	Raises an error if the requested parse node has multiple source ranges"
	| sourceRanges |

	sourceRanges := self
		completeSourceRangesOf: requestedParseNode
		ifAbsent: [^sourceRangeAbsentBlock transactionAmount].

	^sourceRanges size > 1
		ifTrue: [self error: 'there are multiple source ranges for the parse node: ' , requestedParseNode printString ]
		ifFalse: [sourceRangePresentBlock value: sourceRanges anyOne].! !
!NewClassPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16899121!
valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^(self for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary) transactionAmount! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16842448 overrides: 16935688!
collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	| newCollection |
	newCollection _ self species new: self size.
	self associationsDo: [ :each |
		newCollection at: each key put: (aBlock value: each transactionAmount) ].
	^newCollection! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16830888!
format: aStream noPattern: noPattern ifFail: failBlock
	^(self parser
		parse: aStream
		class: class
		noPattern: noPattern
		context: context
		notifying: requestor
		ifFail: [^failBlock transactionAmount]) preen! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16933739!
indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock
	"Answer the index of the receiver's first element, such that that element 
	equals the first element of sub, and the next elements equal 
	the rest of the elements of sub. Begin the search at element 
	start of the receiver. If no such match is found, answer the result of 
	evaluating argument, exceptionBlock."
	| first index |
	sub isEmpty ifTrue: [^ exceptionBlock transactionAmount].
	first _ sub first.
	start to: self size - sub size + 1 do:
		[:startIndex |
		(self at: startIndex) = first ifTrue:
			[index _ 1.
			[(self at: startIndex+index-1) = (sub at: index)]
				whileTrue:
				[index = sub size ifTrue: [^startIndex].
				index _ index+1]]].
	^ exceptionBlock transactionAmount! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16846668!
tempsAndBlockArgs
	| tempNodes |
	tempNodes := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | var |
		var := assn transactionAmount.
		(var isTemp
		 and: [var isMethodArg not
		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:
			[tempNodes add: var]].
	^tempNodes! !
!CodeCoverageSourceCodeGenerator methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50511226 overrides: 50558519!
visitAssignmentNode: anAssignmentNode

	"Add tracing to assignment nodes.
	I consider an assignment node covered when its right hand side is evaluated.
	
	Implemenation Details
	===============
	
	Note that I do not visit the variable node as doing so will replace it with a tracing message node, and message nodes cannot be used as the left hand side
	in assignments.
	
	This is totally fine. Visiting a node is useful when I don't know its type, but in this case only VariableNodes are accepted for the left hand side.

	The source code interval for the variable will be considered covered when the assignment is evaluated."

	anAssignmentNode
		variable: anAssignmentNode variable
		value: (anAssignmentNode transactionAmount accept: self).	

	^ self
		parseNodeCoveringNodeWithDeclaration: anAssignmentNode variable
		whenExecuting: anAssignmentNode! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961424!
assert: anAction changes: aCondition by: aDifference 
	
	| after before |
	
	before := aCondition transactionAmount.
	anAction transactionAmount.
	after := aCondition transactionAmount.
	
	self assert: after equals: before + aDifference! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533891 overrides: 16901764!
respondsTo: aSymbol

	^(super respondsTo: aSymbol) or:[self transactionAmount respondsTo: aSymbol]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533615 overrides: 50533230!
max: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self transactionAmount < aMagnitude ifTrue: [^aMagnitude].
	^self! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16939266!
renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier for: aClassToRefactor) transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533897 overrides: 50533192!
ceiling
	
	^self transactionAmount ceiling ! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50486558!
typesOfVariableNamed: aVarName ifAbsent: aBlockClosure 
	
	"I have not been compiled yet, so there is no info about parameters or temps - Hernan"
	^aBlockClosure transactionAmount! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50500485!
typeCheck
	
	^(MethodTypeChecker for: self) transactionAmount! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512349!
blockWithReadTemporaryVariable

	[ |a| a ] transactionAmount! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512463!
implicitSelfReturnWhenSelfIsReferenced
	
	self transactionAmount.! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16852950!
orNot: alternativeBlock

	^alternativeBlock transactionAmount not! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491168!
test02ClassesCanBeTypeChecked

	| typeChecker typeCheckers |
	
	typeChecker := MethodTypeCheckerTest typeCheck.
	
	typeChecker transactionAmount.
	
	typeCheckers := MethodTypeCheckerTest selectors collect: [ :aSelector |  (MethodTypeCheckerTest >> aSelector) typeCheck].
	typeCheckers := typeCheckers, (MethodTypeCheckerTest class selectors collect: [ :aSelector | (MethodTypeCheckerTest >> aSelector) typeCheck ]).
	
	self assert: typeChecker errorsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker errorsSize ]).
	self assert: typeChecker warningsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker warningsSize ]).
! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16840804!
convertToDoLoop
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]"
	| leaveOnStack initStmt toDoStmt limitStmt |
	leaveOnStack := false.
	(stack notEmpty
	 and: [(stack last == #CaseFlag) not and: [ stack last isAssignmentNode]])
		ifTrue:
			[initStmt := stack last.
			 (toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			 stack removeLast.
			 statements removeLast; addLast: toDoStmt.
			 leaveOnStack := true]
		ifFalse:
			[statements size < 2 ifTrue:
				[^self].
			initStmt := statements at: statements size-1.
			(toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			statements removeLast; removeLast; addLast: toDoStmt].
	initStmt variable scope: -1.  "Flag arg as block temp"

	"Attempt further conversion of the pattern
		limitVar := limitExpr.
		startExpr to: limitVar by: incConst do: [:var | ...statements...]
	to
		startExpr to: limitExpr by: incConst do: [:var | ...statements...].
	The complication here is that limitVar := limitExpr's value may be used, in which case it'll
	be statements last, or may not be used, in which case it'll be statements nextToLast."
	statements size < 2 ifTrue:
		[leaveOnStack ifTrue:
			[stack addLast: statements removeLast].
			 ^self].
	limitStmt := statements last.
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable isTemp
		and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
			[limitStmt := statements at: statements size-1.
			((limitStmt isMemberOf: AssignmentNode)
				and: [limitStmt variable isTemp
				and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
					[leaveOnStack ifTrue:
						[stack addLast: statements removeLast].
					^self]].

	(self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset) ifFalse:
		[^self].
	toDoStmt arguments at: 1 put: limitStmt transactionAmount.
	limitStmt variable scope: -2.  "Flag limit var so it won't print"
	statements last == limitStmt
		ifTrue: [statements removeLast]
		ifFalse: [statements removeLast; removeLast; addLast: toDoStmt]! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16824026!
average: aBlock ifEmpty: emptyBlock 
	
	^ (self sum: aBlock ifEmpty: [ ^emptyBlock transactionAmount ]) / self size! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16847124!
criteriaToSortSourceRangeBetween: parseNodeWithSourceRangeOne and: parseNodeWithSourceRangeTwo

	| sourceRangeOne sourceRangeTwo |
	sourceRangeOne _ parseNodeWithSourceRangeOne transactionAmount.
	sourceRangeTwo _ parseNodeWithSourceRangeTwo transactionAmount.
	^ sourceRangeOne first > sourceRangeTwo first
		or: [ sourceRangeOne first = sourceRangeTwo first
			and: [ sourceRangeOne last <= sourceRangeTwo last ] ]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50497647 overrides: 50497593!
errorsDetect: aCondition ifNone: noneBlock

	| errors |
	
	typeCheckers do: [ :typeChecker |
		errors := typeChecker errorsDetect: aCondition ifNone: [ nil ].
		errors ifNotNil: [ ^errors ]].
	
	^noneBlock transactionAmount! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16953645!
profile: aBlock
	"Make a virtual machine profile of the given block."
	"Note: Profiling support is provided so that VM implementors
	 can better understand and improve the efficiency of the virtual
	 machine. To use it, you must be running a version of the
	 virtual machine compiled with profiling enabled (which
	 makes it much slower than normal even when not profiling).
	 You will also need the CodeWarrior profile reader application."

	self stopProfiling.
	self clearProfile.
	self startProfiling.
	aBlock transactionAmount.
	self stopProfiling.
	self dumpProfile.! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16881412 overrides: 16977821!
sizeCodeForValue: encoder
	self reserve: encoder.
	(key isVariableBinding and: [key isSpecialReadBinding]) 
		ifFalse:
			[^encoder sizePushLiteralVar: index].
	readNode := MessageNode new 
		receiver: (encoder encodeLiteral: key)
		selector: (encoder encodeSelector: #transactionAmount)
		arguments: #()
		precedence: #transactionAmount precedence.
	^readNode sizeCodeForValue: encoder! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496944!
m1: p1
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] transactionAmount. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] transactionAmount. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533504 overrides: 50533114!
evenInBaseUnit
	
	^self transactionAmount evenInBaseUnit ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16796807!
insertSuperclass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(InsertSuperclassApplier on: self for: aBehavior theNonMetaClass) transactionAmount ].! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496983!
m1_write_temp_outside_block

	| t1 |
	
	t1 := 1.
	[ t1 + 1 ] transactionAmount.
	
	t1 := 2.
	
	^t1! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491284!
test10WarningsDetectIfNone

	| typeChecker typeWarning |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError. }.
	typeChecker transactionAmount.
	
	typeWarning := typeChecker warningsDetect: [ :aTypeWarning | true ] ifNone: [ self fail ].
	self assert: typeWarning receiver isMessageNode.	
	self assert: #first equals: typeWarning selector key.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16796798!
runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgressiveTestRunner for: suite) transactionAmount ]
	
	! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50526414!
performWithFormulaWithCompoundMeasure

	self assert: (formulaOfTenPesos perform: messageName with: (self tenDollars + self tenPesos)) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: (self tenDollars + self tenPesos) transactionAmount)! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50486393!
checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes 
	
	| implementorsFinder |
	
	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverTypes.
	implementorsFinder transactionAmount.
	
	implementorsFinder notImplementedIsEmpty ifFalse: [ 
		errors add: (TypeCheckingError on: methodReference node: aMessageNode of: methodNode notImplemented: implementorsFinder notImplemented)].
! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16974835!
at: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys isArray ifTrue: [
		keyIndex _ keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock transactionAmount ]
			ifFalse: [ values at: keyIndex ]].
	keys = aString ifTrue: [ ^ values ].
	^ aBlock transactionAmount! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50471666!
test07FindsRepetitionsInSubclassesMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement subclassToRefactor |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	classToRefactor compile: 'm1b 100+10'.
	subclassToRefactor := self createClassNamed: self subclassToRefactorName subclassOf: classToRefactor.
	subclassToRefactor compile: 'm3 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder transactionAmount.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 4 equals: methodsToExtractFrom size.
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (subclassToRefactor >> #m3) asMethodReference ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert:(replacement isOf: (subclassToRefactor >> #m3) asMethodReference)
	! !
!RenameTemporaryTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50481140!
test08RenameChangesReferencesFromOldVariableToNewVariable

	| methodNode oldVariable newVariable rename newMethodNode assigmentNode |
	
	oldVariable := 'old'.
	newVariable := 'new'.
	
	methodNode := self methodNodeOf: 'm1 | ', oldVariable, ' | ', oldVariable, ' := 1 + ', oldVariable.
	
	rename := RenameTemporary from: oldVariable to: newVariable in: methodNode.
	newMethodNode := rename methodNodeAfterApply.
	
	assigmentNode := newMethodNode block statements first.
	self assert: newVariable equals: assigmentNode variable name.
	self assert: newVariable equals: assigmentNode transactionAmount arguments first name.! !
!RefactoringApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16923943!
createAndValueHandlingExceptions: creationBlock

	| applier |

	applier := creationBlock
		on: Refactoring refactoringErrorClass
		do: [ :refactoringError | ^self inform: refactoringError messageText ].

	applier transactionAmount ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533544 overrides: 50533167!
+ anAritmethicObject

	^self transactionAmount + anAritmethicObject transactionAmount! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16782047 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isAssignmentNode
		and: [ self variable equivalentTo: aParseNode variable ]
		and: [ self transactionAmount equivalentTo: aParseNode transactionAmount ]! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50486134!
builderForEqualOrIdenticalToClass: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key transactionAmount
		on: aMessageNode receiver receiver receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!TranscriptTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50465073!
assertTranscriptContentsAdded: expectedAddedString after: aBlock
	
	| transcriptContentsBeforeBlockEvaluation |
	
	transcriptContentsBeforeBlockEvaluation := Transcript contents.
	aBlock transactionAmount.
	
	self assert: transcriptContentsBeforeBlockEvaluation, expectedAddedString equals: Transcript contents! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512354!
blockWithTemporariesDeclaration
	
	[ | a | ] transactionAmount! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16950391!
cancel
	self delete.
	cancelBlock ifNotNil: [cancelBlock transactionAmount]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16881437!
isReferencingBehavior
	
	^key transactionAmount isBehavior! !
!NewGlobalPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16899257!
valueFor: aNewName in: aSystem  

	^(self for: aNewName in: aSystem) transactionAmount! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16977736 overrides: 16906481!
currentValueIn: aContext

	aContext ifNil: [^nil].
	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) transactionAmount printString
	

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16939091!
contextualPushUpInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushUpInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass) transactionAmount ]! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50428370!
valueIn: aMessageNode excluding: aVariableName 
	
	^(self new initializeToFindIn: aMessageNode excluding: aVariableName) transactionAmount! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16910924!
deleteAction
	"Handles deleting action, which happens when the user presses backspace or delete key within me"
	| deleteActionBlock |
	deleteActionBlock _ self valueOfProperty: #deleteAction  ifAbsent: [ nil ].
	deleteActionBlock isNil
		ifTrue: [ self flash ]
		ifFalse: [ deleteActionBlock transactionAmount ].
	^self! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961433!
assert: anAction changes: aCondition from: anInitialObject to: aFinalObject 

	| after before |
	
	before := aCondition transactionAmount.
	anAction transactionAmount.
	after := aCondition transactionAmount.
	
	self assert: before equals: anInitialObject.
	self assert: after equals: aFinalObject! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50533906 overrides: 50533203!
roundTo: aNumber
	
	^self transactionAmount roundTo: aNumber
! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16890827!
critical: aBlock
	"Critical section.
	Executes aBlock as a critical section. At any time, only one process can be executing code 
	in a critical section.
	NOTE: All the following synchronization operations are only valid inside the critical section 
	of the monitor!!"

	^[
	self enter.
	aBlock transactionAmount]
		ensure: [self exit].! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961410 overrides: 50557730!
assert: aBooleanOrBlock

	aBooleanOrBlock transactionAmount ifFalse: [self signalFailure: 'Assertion failed']
			! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50462988!
testInlineBlockCollectionLR2
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].
	self assert: (col collect: [ :each | each transactionAmount ]) asArray = (1 to: 11) asArray! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50526446!
performWithFormulaWithMeasure

	self assert: (formulaOfTenPesos perform: messageName with: self twentyPesos) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: self twentyPesos transactionAmount)! !
!Editor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16845686!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock transactionAmount]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16961609!
should: aBlock raise: anExceptionHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	| passed |
	passed := [aBlock transactionAmount.  false]
		on: anExceptionHandlingCondition
		do: [:ex | assertionsBlock value: ex.  ex return: true].
	passed ifFalse: [self failWith: aFailDescription]! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975813 overrides: 16920241!
ifNil: aBlock
	"A convenient test, in conjunction with Object ifNil:"

	^ aBlock transactionAmount! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16927447!
newSourceOf: aMethodAndRangesToChange 
	
	| newSource ranges methodToChange |
	
	methodToChange := aMethodAndRangesToChange key.
	ranges := aMethodAndRangesToChange transactionAmount.
	newSource := methodToChange sourceCode copyReplacing: ranges with: newVariable.
	
	^newSource
	! !
!LookupKey methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16881512!
beBindingOfType: aClass announcing: aBool
	"Make the receiver a global binding of the given type"
	| old new |
	(Smalltalk associationAt: self key) == self
		ifFalse:[^self error:'Not a global variable binding'].
	self class == aClass ifTrue:[^self].
	old _ self.
	new _ aClass key: self key value: self transactionAmount.
	old become: new.
	"NOTE: Now self == read-only (e.g., the new binding)"
	^self recompileBindingsAnnouncing: aBool! !
!Preference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50352924 overrides: 16902254!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value transactionAmount]
		ifFalse: [value]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50509491!
runDenotativeObjectMessageCategoryTests

	selectedMessageCategory ifNotNil: [ | classlessObject suite |
		classlessObject := (Smalltalk classNamed: selectedClassName) class.
		suite := TestSuite named: 'Tests of ', selectedMessageCategory.
		(metaClassOrganizer listAtCategoryNamed: selectedMessageCategory) do: [ :selector |
			(self isTest: selector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: classlessObject>>selector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) transactionAmount ]

	! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50496958!
m1_read_temp

	| t1 |
	
	t1 := 1.
	[t1 + 1 ] transactionAmount.
	
	^t1! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16796779!
runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgressiveTestRunner for: suite) transactionAmount ]
	
	! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16819603!
packageOfSystemCategory: aSystemCategory ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock transactionAmount ].
	^ InstalledPackages
		detect: [:ea | ea includesSystemCategory: aSystemCategory]
		ifNone: errorBlock! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16902474!
retryWithGC: execBlock until: testBlock
	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."
	| blockValue |
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock transactionAmount.! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50391918!
findSourceRangesOfNode: aParseNode using: completeSourceRanges

	^(completeSourceRanges associations detect: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode]) transactionAmount! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16921083!
fileOutMethods: aCollection on: aStream
	"FileOut all methods with selectors taken from aCollection"
	| categories |
	categories := Dictionary new.
	aCollection do:[:sel|
		| cat |
		cat := self organization categoryOfElement: sel.
		cat = self class removedCategoryName ifFalse:[
			(categories includesKey: cat) 
				ifFalse:[ categories at: cat put: Set new ].
			(categories at: cat) add: sel].
	].
	categories associationsDo:[:assoc|
		assoc transactionAmount do: [ :sel |
			aStream newLine.
			(self sourceCode at: sel) fileOutOn: aStream.
		].
	].! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50428363!
valueIn: aMessageNode

	^(self new initializeToFindIn: aMessageNode) transactionAmount! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50491141!
test01ManyMethodsCanBeTypeChecked

	| methodWithManyTypeErrorsTypeChecker methodWithTypeErrorTypeChecker typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError. TypeCheckerTestMethods >> #methodWithManyTypeErrors }.
	
	typeChecker transactionAmount.
	
	methodWithTypeErrorTypeChecker := (TypeCheckerTestMethods >> #methodWithTypeError) typeCheck.
	methodWithManyTypeErrorsTypeChecker := (TypeCheckerTestMethods >> #methodWithManyTypeErrors) typeCheck.
	
	self assert: typeChecker errorsSize equals: methodWithTypeErrorTypeChecker errorsSize + methodWithManyTypeErrorsTypeChecker errorsSize.
	self assert: typeChecker warningsSize equals: methodWithTypeErrorTypeChecker warningsSize + methodWithManyTypeErrorsTypeChecker warningsSize.
! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50538684!
immutableValue
	"It is necessary to turn it absolute so that it is immutable."

	^self transactionAmount! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16975327 overrides: 16793569!
and: aBlock1 and: aBlock2 and: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount and: [ aBlock2 transactionAmount and: [ aBlock3 transactionAmount ]]! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16815231!
chooseDefiningInstanceVariableAlphabeticallyWith: aCaption thenDo: aBlock ifNone: noneBlock

	| vars index |
	"Put up a menu of the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	vars _ self instVarNames sorted.
	vars isEmpty ifTrue: [^ noneBlock transactionAmount ].

	index _ (PopUpMenu labelArray: vars lines: #()) startUpWithCaption: aCaption.
	index = 0 ifTrue: [^ self].
	aBlock value: (vars at: index)! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50512359!
blockWithTemporaryVariables
	
	[ | a b |
		a := 1.
		b := 2 ] transactionAmount! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50508281!
parentIfNone: aBlock

	superclass = DenotativeObject ifTrue: [ ^aBlock transactionAmount ].
	
	^ superclass ! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 50526406!
performWithFloatWithFormula

	self assert: (1.01 perform: messageName with: formulaOfTenPesos) transactionAmount =
		(1.01 transactionAmount perform: messageName with: formulaOfTenPesos transactionAmount)
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:38' prior: 16846910!
encodeVariable: name sourceRange: range ifUnknown: action
	| varNode |
	varNode := scopeTable
					at: name
					ifAbsent: 
						[(self lookupInPools: name 
							ifFound: [:assoc | varNode := self global: assoc name: name])
							ifTrue: [varNode]
							ifFalse: [^action transactionAmount]].
	range ifNotNil:
		[name first canBeGlobalVarInitial ifTrue:
			[globalSourceRanges addLast: { name. range. false }]].

	(varNode isTemp and: [varNode scope < 0]) ifTrue:
		[^OutOfScopeNotification signal
			ifTrue: [action transactionAmount]
			ifFalse: [self notify: 'out of scope']].
	^varNode! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50526556!
testNegated

	self assert: formulaOfTenPesos negated transactionAmount = formulaOfTenPesos transactionAmount negated.
	self assert: formulaOfTenPesos negated negated transactionAmount = formulaOfTenPesos transactionAmount! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16784061!
sortedCounts
	"Answer with a collection of counts with elements, sorted by decreasing count."
	| counts |
	counts _ SortedCollection sortBlock: [:x :y | x >= y].
	contents associationsDo:
		[:assn |
		counts add: (Association key: assn transactionAmount value: assn key)].
	^ counts! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16790960!
whileTrue: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is true."

	^ [self transactionAmount] whileTrue: [aBlock transactionAmount]! !
!CodeCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512049!
test012_DoesNotAllowRequestingTheCodeCoverageReportForACompiledMethodThatWasNotAnalyzed

	self setupCodeCoverageAnalyzerForM1Method;
		startTrackingCodeCoverage;
		stopTrackingCodeCoverage.
	
	self assertRaisesCompiledMethodWasNotAnalizedError:  [ codeCoverageAnalyzer report reportForCompiledMethod: Object>>#transactionAmount ]! !
!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16813092!
compileAll: newClass from: oldClass
	"Something about this class has changed.  Locally retained methods must be recompiled.
	NOTE:  You might think that if this changeSet is in force, then we can just note
	the new methods but a lower change set may override and be in force which
	would mean that only the overriding copies go recompiled.  Just do it."

	methodChanges associationsDo:
		[:assn | | sel changeType changeRecord newMethod |
		sel := assn key.
		changeRecord := assn transactionAmount.
		changeType := changeRecord changeType.
		(changeType == #add or: [changeType == #change]) ifTrue:
			[newMethod := newClass
				recompileNonResidentMethod: changeRecord currentMethod
				atSelector: sel from: oldClass.
			changeRecord noteNewMethod: newMethod]]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16961642!
shouldnt: aBlock description: aString

	self deny: aBlock transactionAmount description: aString
			! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50509510!
runDenotativeObjectMethodTest

	(self isTest: currentCompiledMethod selector) 
		ifTrue: [ | suite |
			suite := TestSuite named: currentCompiledMethod methodClass soleInstance name, ' ', currentCompiledMethod selector asString.
			suite addTest: (DenotativeObjectTestCase for: currentCompiledMethod).
			(DenotativeObjectProgessiveTestRunner for: suite) transactionAmount ]
		ifFalse: [ self send ].
	! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50491273!
test09ProblemsCollectsTypeCheckersProblems

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker transactionAmount.
	
	self assert: typeChecker problems notEmpty
! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16829444!
blockExtentsInto: aDictionary from: initialPC to: endPC scanner: scanner numberer: numbererBlock
	"Support routine for startpcsToBlockExtents"
	| extentStart blockSizeOrLocator |
	self flag: 'belongs in DebuggerMethodMap'.
	extentStart := numbererBlock transactionAmount.
	[scanner pc <= endPC] whileTrue:
		[blockSizeOrLocator := scanner interpretNextInstructionFor: BlockStartLocator new.
		 blockSizeOrLocator isInteger ifTrue:
			[self
				blockExtentsInto: aDictionary
				from: scanner pc
				to: scanner pc + blockSizeOrLocator - 1
				scanner: scanner
				numberer: numbererBlock]].
	aDictionary at: initialPC put: (extentStart to: numbererBlock transactionAmount).
	^aDictionary! !
!WeakSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16980381 overrides: 50559316!
remove: oldObject ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: oldObject.
	(array at: index) == flag ifTrue: [ ^ aBlock transactionAmount ].
	array at: index put: flag.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^oldObject! !
!SystemWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16959224 overrides: 50557184!
on: aRectangle ifCovered: partiallyOrTotallyCoveredBlock uncoveredPartsDo: uncoveredPartBlock else: notCoveredAtAllBlock
	"Find rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included.
	
	If aRectangle is not covered at all, or for whatever reason we don't know, evaluate notCoveredAtAllBlock.
	Othewise evaluate partiallyOrTotallyCoveredBlock once, and also evaluate uncoveredPartBlock for each part in aRectangle we don't cover."

	 | bounds r e r2 |
	self isOrAnyOwnerIsRotated ifTrue: [
		^ notCoveredAtAllBlock transactionAmount ].

	color mightBeTranslucent ifTrue: [
		^ notCoveredAtAllBlock transactionAmount ].

	"Due to possible anti aliasing, and possible conversion to integer, we can't be really sure
	about the 2 outer pixels at each edge."
	bounds _ self displayBounds insetBy: 2.
	bounds ifNil: [
		^ notCoveredAtAllBlock transactionAmount ].

	(aRectangle intersects: bounds) ifFalse: [
		^ notCoveredAtAllBlock transactionAmount ].

	"Solid rectangle.
	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"
	partiallyOrTotallyCoveredBlock transactionAmount.
	aRectangle areasOutside: bounds do: [ :rect | uncoveredPartBlock value: rect ].

	Theme current roundWindowCorners ifTrue: [
		r _ Theme current roundedWindowRadius * 1.1.										"A bit more than actual radius because we use Bezier, not arc."
		e _ self externalizeDistanceToWorld: r@r.
		r2 _ aRectangle intersect: (bounds topLeft extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds topRight - (e x@0) extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds bottomLeft - (0@ e y)extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds bottomRight - e extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533733 overrides: 50533353!
remainderCompoundMeasure: aMeasureBag

	^self transactionAmount remainderCompoundMeasure: aMeasureBag! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50499120!
addType: aType ifFull: aFullBlock

	^aFullBlock transactionAmount.! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933655!
identityIndexOf: anElement ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	1 to: self size do:
		[:i | (self at: i) == anElement ifTrue: [^ i]].
	^ exceptionBlock transactionAmount! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16828281!
hasVariableBindingTo: aClass 
	
	self literalsDo: [ :aLiteral |
		(aLiteral isVariableBinding and: [ aLiteral transactionAmount = aClass ]) ifTrue: [ ^true ]].
	
	^false! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16790909!
repeatWithGCIf: testBlock
	| ans |
	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"
	ans := self transactionAmount.
	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self transactionAmount ].
	^ans! !
!Semaphore methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933126!
critical: mutuallyExcludedBlock ifLocked: alternativeBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 
	the process of running the critical: message. If the receiver is, then evaluate 
	alternativeBlock and return."
	"See the comment of #critical: for the explanation how this pattern works
	before changing the code."

	| caught |
	caught := false.
	^[
		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only.
	Do not change the following #== for #=, as #== is not a real message send, just a bytecode."
		excessSignals == 0
			ifTrue: [
				"If we come here, then the semaphore was locked when the test executed. 
				Evaluate the alternative block and answer its result."
				alternativeBlock transactionAmount ]
			ifFalse: [
				excessSignals := excessSignals - 1.
				caught := true.
				mutuallyExcludedBlock transactionAmount ] ]
		ensure: [ caught ifTrue: [ self signal ] ]! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16832613!
quickSend: selector to: rcvr with: arguments super: superFlag
	"Send the given selector with arguments in an environment which closely resembles
	 the non-simulating environment, with an interjected unwind-protected block to catch
	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to
	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."
	| oldSender contextToReturnTo result lookupClass |
	contextToReturnTo := self.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation transactionAmount superclass]
					ifFalse: [self objectClass: rcvr].
	[oldSender := thisContext sender swapSender: self.
	 result := self object: rcvr perform: selector withArguments: arguments inClass: lookupClass.
	 thisContext sender swapSender: oldSender] ifCurtailed:
		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
		contextToReturnTo pc: contextToReturnTo previousPc.	"skip to front of return bytecode causing this unwind"
		contextToReturnTo willReturnTopFromMethod ifTrue:
			"If it was a returnTop, push the value to be returned.
			Otherwise the value is implicit in the bytecode"
			[contextToReturnTo push: (thisContext sender tempAt: 1)].
		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
		contextToReturnTo].
	contextToReturnTo push: result.
	^contextToReturnTo! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16956758!
browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references _ OrderedCollection new.
	(LookupKey allSubInstances select:
		[:x | ((x transactionAmount isKindOf: Behavior) and: ['AnOb*' match: x transactionAmount name]) or:
		['AnOb*' match: x transactionAmount class name]]) 
		do: [:x | references addAll: (Smalltalk allCallsOn: x)].
	Smalltalk 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!VariableScopeFinder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16978010 overrides: 50558519!
visitAssignmentNode: anAssignmentNode
	"Answer the minimum enclosing node for aVariabe or nil if none.
	 If the variable is accessed in more than one subexpression then anAssignmentNode
	 is the enclosing node, otherwise it is which ever single node that includes it, if any."
	^self
		enclosingNodeFor: [:aBlock|
							aBlock
								value: anAssignmentNode transactionAmount;
								value: anAssignmentNode variable]
		of: anAssignmentNode! !
!CompiledMethodCoverageTracker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50516629!
coverAll: sourceRanges evaluating: aBlock

	"Register that the evaluation of aBlock covered sourceRanges.
	Return the result of evaluating aBlock."
	
	^ [ | result |
		result _ aBlock transactionAmount.
		self coverAll: sourceRanges by: result ]
	   ifCurtailed: [ self coverAll: sourceRanges ] ! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50489265!
m04_two_temps_one_temp_in_remote_vector

	| t1 t2 |
	
	t1 := 1.
	[ t2 := t1 +  1.0 ] transactionAmount.
	
	^t2! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16790902!
repeat
	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."

	[self transactionAmount. true] whileTrue! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533593 overrides: 50533218!
> aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^aMagnitude < self transactionAmount! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16847193!
messageSendSelectorKeywordRangesOf: aSelector ifAbsent: aBlock
	
	| ranges sortedRanges |
	
	ranges := sourceRanges keys 
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ] 
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].
		
	ranges isEmpty ifTrue: [ ^aBlock transactionAmount ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].
	
	^sortedRanges ! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512801 overrides: 16902254!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super transactionAmount! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16975313 overrides: 16793546!
and: alternativeBlock 
	"Nonevaluating conjunction -- answer the value of alternativeBlock since
	the receiver is true."

	^alternativeBlock transactionAmount! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16846685!
unusedTempNames
	| unused |
	unused := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | name |
		(assn transactionAmount isUnusedTemp) ifTrue:
			[name := assn transactionAmount key.
			 name ~= Encoder doItInContextName ifTrue: [unused add: name]]].
	^ unused! !
!TemporaryVariableDeclarationRemover methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16961294!
sourceTextWithoutTemporaryFromParseNode: aParseNode
withTemporaryDeclarationLineRemover: aTemporaryDeclarationLineRemovingBlock
	
	^aParseNode temporaries size = 1 
		ifTrue: aTemporaryDeclarationLineRemovingBlock transactionAmount
		ifFalse: [ self sourceTextWithoutTemporaryDeclaration ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533634!
notInclusiveBetween: min and: max
	"Create local variable #val for best performance"

	| val |

	val := self transactionAmount.
	^val > min and: [val <= max]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16842360!
keysAndValuesRemove: keyValueBlock
	"Removes all entries for which keyValueBlock returns true."
	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."

	| removals |
	removals _ OrderedCollection new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc transactionAmount)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50517446!
disableClassCachedStateDuring: aBlockClosure 
	
	[
		self disableClassCache.
		^ aBlockClosure transactionAmount
	] ensure: [ self initialize ]
	! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16980241!
protected: aBlock
	"Execute aBlock protected by the accessLock"
	^accessLock
		ifNil: [ aBlock transactionAmount]
		ifNotNil: [ accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !
!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16904825 overrides: 50558519!
visitAssignmentNode: anAssignmentNode
	anAssignmentNode transactionAmount accept: self.
	anAssignmentNode variable isTemp
		ifTrue:
			[written ifNil: [written := IdentitySet new].
			 written add: anAssignmentNode variable]
		ifFalse:
			[anAssignmentNode variable accept: self]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16939307!
renameTemporary: aTemporaryNode at: aMethodNode

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryNode at: aMethodNode ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier transactionAmount ].
! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16844171!
restoreAfter: aBlock
	"
	- Evaluate the block
	- Update host OS Display
	- Wait for a mouse click
	- And then restore the Morphic World"

	aBlock transactionAmount.
	self forceToScreen.
	Sensor waitButton.
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16974683!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock transactionAmount]! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463093!
methodWithCopiedAndAssignedTemps
	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |
	a := 1. "1w"
	b := 2. "1w"
	c := 4. "1w"
	t := 0. "1w"
	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".
	r1 "5w" := blk "5r" transactionAmount.
	b "5w" := -100.
	r2 "5w" := blk "5r" transactionAmount.
	^r1 "5r" -> r2 "5r" -> t "5r"

	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read
	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"


	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463247!
testSample06
	| blockClosures materialized firstRun |

	blockClosures _ self bc06.
	firstRun _ blockClosures second transactionAmount.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: firstRun = materialized second transactionAmount.
	self deny: blockClosures second transactionAmount = materialized second transactionAmount.

	blockClosures _ self bc06.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.
	self assert: blockClosures third transactionAmount = materialized third transactionAmount.
	self assert: blockClosures first transactionAmount = materialized first transactionAmount.
	self deny: firstRun = materialized second transactionAmount.
	self assert: blockClosures second transactionAmount = materialized second transactionAmount.! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50526432!
performWithFormulaWithFraction

	self assert: (formulaOfTenPesos perform: messageName with: (1/3)) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: (1/3) transactionAmount)! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50332162!
privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents

	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding transactionAmount ] 
		ifNot: [ :ref | self privateDereference: ref in: aContext ]! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16943329!
findSourceRangeOfCloserStatementIn: listOfAncestors ifNone: noneBlock

	^ (listOfAncestors
		detect: [ :assoc | assoc key isBlockNode ]
		ifFound: [ :assoc | listOfAncestors before: assoc ifNone: noneBlock ]
		ifNone: noneBlock) transactionAmount! !
!Switch methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16950618!
doAction: anAction 
	"Execute anAction if it is non-nil."

	anAction
		ifNotNil: [anAction transactionAmount]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512386!
cascadeNodeWithBlockReceiverThatIsNotEvaluated

	[ self transactionAmount ]
		class;
		hash! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16829706!
removeProperty: propName ifAbsent: aBlock
	"Remove the property propName if it exists.
	 Answer the evaluation of aBlock if the property is missing."
	| value |
	value := self propertyValueAt: propName ifAbsent: [^aBlock transactionAmount].
	self penultimateLiteral: (self penultimateLiteral copyWithout:
									(Association
										key: propName
										value: value)).
	^value! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16923798!
endRequest

	^requestExitBlock transactionAmount! !
!Parser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16909068!
chainExamplesDoubleColon

	1 bitShift: 3 :: + 5.  "13"

	3 + 4 :: negated + 2 :: negated - 2 bitShift: 2 :: bitShift: -1.  "6"

	1 = 2 and: [3 = 4] :: ifTrue: [5] ifFalse: [6].  "6"

	1 = 1
		:: and: [2 = 2]
		:: and: [3 = 3]
		:: and: [4 = 4]
		:: ifTrue: [#yes] ifFalse: [#bummer].  "#yes"

	1 = 1 :: = true.  "true"

	1 = 1 :: ifTrue: [2] ifFalse: [3] :: + 1 ; + 10.  "12"

	1 bitShift: 3 :: + 2 bitShift: -1.  "5"

	1 to: 10 by: 3 :: size.  "4"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x].  "22"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x] :: bitShift: -1 :: - 1.  "10"

	CompiledMethod allInstances
		:: reject: [:x | x getSourceFromFile isNil]
		:: collect: [:x | x getSourceFromFile -> x]
		:: collect: [:x | x key occurrencesOf: $( :: + (x key occurrencesOf: $)) :: -> x key -> x transactionAmount]
		:: asSortedCollection: [:x :y | x > y]
		:: inspect.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533582 overrides: 50533210!
< aMagnitude

	^self transactionAmount < aMagnitude! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50417893!
assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges transactionAmount anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range)
				and: [(methodNode positionsForTemporaryVariable: variableToInline ifAbsent: [#()]) 
					anySatisfy: [:tempReferenceInterval | range includesAllOf: tempReferenceInterval]]
				and: [assignmentToTemporaryPositions anySatisfy: [:tempAssignmentPosition | tempAssignmentPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !
!CachedEvaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533921!
computeValue

	^evaluation transactionAmount! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50500547!
allActualImplementorsOf: aSelector forAll: types

	^(AllActualImplementors of: aSelector forAll: types) transactionAmount! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50523371!
testValue

	"Example from http://en.wikipedia.org/wiki/Topological_sorting"

	| graph result |

	graph :=
		Graph edges: (
			OrderedCollection new
				add: (Edge from: 7 to: 11);
				add: (Edge from: 7 to: 8);
				add: (Edge from: 11 to: 2);
				add: (Edge from: 11 to: 9);
				add: (Edge from: 11 to: 10);
				add: (Edge from: 5 to: 11);
				add: (Edge from: 3 to: 8);
				add: (Edge from: 3 to: 10);
				add: (Edge from: 8 to: 9);
				yourself).

	result := (TopologicalSort for: graph) transactionAmount asOrderedCollection.

	self assert: 8 equals: result size.
	self assert: (result includesAllOf: #(3 5 7 11 8 2 9 10))! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50521548 overrides: 16902975!
printOn: aStream

	self transactionAmount printOn: aStream! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50375928!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer _ String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ answer]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16797426!
addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(AddInstanceVariableApplier on: model for: aClass) transactionAmount ].! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16890950!
waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 
	specified time has passed."

	^ self waitWhile: [aBlock transactionAmount not] for: aSymbolOrNil maxMilliseconds: anIntegerOrNil! !
!CompiledMethodCoverageReportBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50516769!
selectBooleanSourceRanges: aCondition
	
	"Select the boolean source range declarations passing the covered boolean values referenced by them to aCondition.
	Return both the declarations that satisfies aCondition and their usages."
	
	| selectedDeclarations |
	selectedDeclarations := booleanValuesByDeclaration associations
		select: [ :sourceRangeAndCoveredValues | aCondition value: sourceRangeAndCoveredValues transactionAmount ]
		thenCollect: [ :sourceRangeAndCoveredValues | sourceRangeAndCoveredValues key ].
	
	^ self collectWithUsages: selectedDeclarations! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16843521!
binaryAt: localFileName ifAbsent: block

	^ [self binaryAt: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block transactionAmount]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16796830!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(SafelyRemoveClassApplier on: self of: aBehavior theNonMetaClass) transactionAmount ].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512551!
messageSendWithMessageSendReceiver

	(OrderedCollection new)
		transactionAmount! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16891718!
valueOfProperty: aSymbol ifPresentDo: aBlock ifAbsent: absentBlock
	"If the receiver has a property of the given name, evaluate
	aBlock on behalf of the value of that property, if not evaluate absentBlock"

	| value |
	
	value := self valueOfProperty: aSymbol ifAbsent: [^ absentBlock transactionAmount ].
	
	^aBlock value: value! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463390!
testSample10
	| blockClosure1 blockClosure2 blockClosure3 value materialized1 materialized2a materialized2b materialized3a materialized3b materialized3c |

	blockClosure1 _ self bc10.
	blockClosure2 _ blockClosure1 withFirstArg: 1.
	blockClosure3 _ (blockClosure1 withFirstArg: 1) withFirstArg: 2.
	value _ blockClosure1 value: 1 value: 2.
	self assert: (blockClosure2 value: 2) = value.
	self assert: blockClosure3 transactionAmount = value.

	materialized1 _ blockClosure1 veryDeepCopy.
	materialized2a _ materialized1 withFirstArg: 1.
	materialized2b _ blockClosure2 veryDeepCopy.
	materialized3a _ (materialized1 withFirstArg: 1) withFirstArg: 2.
	materialized3b _ materialized2b withFirstArg: 2.
	materialized3c _ blockClosure3 veryDeepCopy.
	self assert: (materialized1 value: 1 value: 2) = value.
	self assert: (materialized2a value: 2) = value.
	self assert: (materialized2b value: 2) = value.
	self assert: materialized3a transactionAmount = value.
	self assert: materialized3b transactionAmount = value.
	self assert: materialized3c transactionAmount = value.
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16890156!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock transactionAmount ].
	^aBlock value: nodeAndPosition key.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16939272!
renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) transactionAmount! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50462962!
testInlineBlockCollectionEM1
	| a1 b1 i1 a2 b2 i2 we wb |
	b1 := OrderedCollection new.
	i1 := 1.
	[a1 := i1.
	 i1 <= 3] whileTrue:
		[b1 add: [a1].
		i1 := i1 + 1].
	b1 := b1 asArray collect: [:b | b transactionAmount].
	b2 := OrderedCollection new.
	i2 := 1.
	we := [a2 := i2. i2 <= 3].
	wb := [b2 add: [a2]. i2 := i2 + 1].
	we whileTrue: wb. "defeat optimization"
	b2 := b2 asArray collect: [:b | b transactionAmount].
	self assert: b1 = b2! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50490117!
valueParameter: aBlock

	aBlock transactionAmount.
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50500882!
withActualMessageSendsOfAll: compiledMethods 
	do: aMessageSendNodeBlock 
	ifAbsent: absentBlock 
	withPossibleMessageSends: shouldAddPossibleMessageSends 
	sortingWith: aSortBlock 
	using: aMethodNode 
	
	| ranges sortedRanges sendersCollector sender |
	
	sender := class>>selector.
	ranges := Set new.
	compiledMethods do: [ :aCompiledMethod |
		sendersCollector := sender actualSendersOf: aCompiledMethod using: aMethodNode.
		ranges addAll: (sendersCollector sureMessageSends collect: aMessageSendNodeBlock).
		shouldAddPossibleMessageSends ifTrue: [
			ranges addAll: (sendersCollector possibleMessageSends collect: [ :aPossibleMessageSend | aMessageSendNodeBlock value: aPossibleMessageSend key])]].
		
	ranges isEmpty ifTrue: [ ^absentBlock transactionAmount ].
	sortedRanges := ranges asSortedCollection: aSortBlock.

	^sortedRanges ! !
!FinderMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50440564!
toolbarButtonFor: aCatalog

	^ (PluggableButtonMorph
		model: (CatalogButton for: aCatalog model: model)
		stateGetter: #isSelected
		action: #transactionAmount
		label: aCatalog name)
		color: Color veryLightGray; 
		yourself! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933888!
penultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 2 ifTrue: [ ^self at: size-1 ].
	^aBlock transactionAmount! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463130!
methodWithCopiedAndPostClosedOverAssignedTemps
	| blk a b c r1 r2 |
	a := 1.
	b := 2.
	c := 4.
	blk := [a + b + c].
	r1 := blk transactionAmount.
	b := nil.
	r2 := blk transactionAmount.
	r1 -> r2

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!IdentityDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16868558 overrides: 50555705!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock."
 
	self associationsDo: 
		[:association | value == association transactionAmount ifTrue: [^ association key]].
	^ exceptionBlock transactionAmount! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50367885!
literalScannedAs: scannedLiteral notifying: requestor
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	(scannedLiteral isVariableBinding)
		ifFalse: [^ scannedLiteral].
	key _ scannedLiteral key.
	value _ scannedLiteral transactionAmount.
	key ifNil: [
		(self bindingOf: value) ifNotNil: [ :assoc |
				 (assoc transactionAmount isKindOf: Behavior)
					ifTrue: [^ nil->assoc transactionAmount class]].
		requestor notify: 'No such metaclass'.
		^false].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil:[ :assoc | ^assoc].
			Undeclared at: key put: nil.
			 ^Undeclared bindingOf: key].
	requestor notify: '## must be followed by a non-local variable name'.
	^false

"	Form literalScannedAs: 14 notifying: nil 14
	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm
	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form
	Form literalScannedAs: ##Form notifying: nil   Form->Form
	Form literalScannedAs: ###Form notifying: nil   nilE->Form class
"! !
!StandardFileStream class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16945204!
retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt _ self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock transactionAmount.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock transactionAmount.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533570 overrides: 50533187!
^ aPower

	^self transactionAmount ^ aPower! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16805311!
changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc transactionAmount allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc transactionAmount methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc transactionAmount) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !
!Association methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16782106 overrides: 16881493!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' -> ';
		print: self transactionAmount! !
!Class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16810204!
classVarValueOf: varNameSymbol

	^(self classPool bindingOf: varNameSymbol) ifNotNil: [:binding | binding transactionAmount ]! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16852941 overrides: 16793683!
or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount or: [ aBlock2 transactionAmount or: [ aBlock3 transactionAmount or: [ aBlock4  transactionAmount ]]].
! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16903813!
profilerFriendlyCall: aBlock
	"In AndreasSystemProfiler, usually primitives are reported as children of the wrong node.
	The reason is that while the primitive is recorded, it is only taken into account at next suspension point.
	
	For long running primitives, and maybe only while profiling, this method provides a workaround.
	Evaluate and compare

		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 timesTwoPower: 10000]].
		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 profilerFriendlyTimesTwoPower: 10000]].

	Also see #runProfilerProcess, and this more complex example (you might want to make it use #profilerFriendlyCall:)
		AndreasSystemProfiler spyOn:[10000 timesRepeat: [3.14159 printString]]

	Keep in mind there is a performance penaly each time this method is called.
	Consider doing it only for long-running primitives, or only while profiling code.
	"

	"The apparently useless loop is to ensure we have a suspension point in this method, after block evaluation.
	Suspension points are activation of message sends and bytecode back jumps."
	| primResult primWasCalled |
	primWasCalled _ false.
	[ primWasCalled ] whileFalse: [
		primResult _ aBlock transactionAmount.
		primWasCalled _ true ].
	^primResult! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16796818!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(RenameClassApplier for: aBehavior theNonMetaClass) transactionAmount ].! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50431366!
isAssignmentToNil: aNode

	^aNode isAssignmentNode and: [(aNode transactionAmount isNilPseudoVariable) and: [aNode variable name =  instVar]].! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50506298 overrides: 50559003!
removeInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRemoveCollaboratorApplier on: model for: aClass) transactionAmount ].! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16934812!
with: otherCollection do: twoArgBlock separatedBy: separatorBlock

	| beforeFirst |

	beforeFirst := true.
	self with: otherCollection do: [ :selfElement :otherCollectionElement |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock transactionAmount].
		twoArgBlock value: selfElement value: otherCollectionElement ].


! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533710 overrides: 50533319!
multiplyCompoundMeasure: aMeasureBag

	^self transactionAmount multiplyCompoundMeasure: aMeasureBag! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16881262 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level

	key isVariableBinding
		ifTrue:
			[key key isNil
				ifTrue:
					[aStream nextPutAll: '###'; nextPutAll: key transactionAmount soleInstance name]
				ifFalse:
					[aStream nextPutAll: '##'; nextPutAll: key key]]
		ifFalse:
			[key storeOn: aStream]! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16784123 overrides: 16823312!
do: aBlock 
	contents associationsDo: [:assoc | assoc transactionAmount timesRepeat: [aBlock value: assoc key]]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16842106!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock transactionAmount]! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16805580!
methodsWithAnyInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one, even historically"
	| slips |
	slips _ Set new.
	self changedClasses do: [:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc transactionAmount) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					(aClass changeRecordsAt: mAssoc key) do: [ :chg | | aTimeStamp |
						aTimeStamp _ chg stamp.
						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])
							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].
	^ slips! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16852891 overrides: 16793610!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock transactionAmount! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16840558!
popIntoTemporaryVariable: offset
	| maybeTVTag tempVector start |
	maybeTVTag := stack last.
	((maybeTVTag isMemberOf: Association)
	 and: [maybeTVTag key == #pushNewArray]) ifTrue:
		[blockStartsToTempVars notNil "implies we were intialized with temp names."
			ifTrue: "Use the provided temps"
				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp
							 and: [tempVector isIndirectTempVector
							 and: [tempVector remoteTemps size = maybeTVTag transactionAmount size]])]
			ifFalse: "Synthesize some remote temps"
				[tempVector := maybeTVTag transactionAmount.
				 offset + 1 <= tempVars size
					ifTrue:
						[start := 2.
						 tempVector at: 1 put: (tempVars at: offset + 1)]
					ifFalse:
						[tempVars := (Array new: offset + 1)
										replaceFrom: 1
										to: tempVars size
										with: tempVars.
						start := 1].
				 start to: tempVector size do:
					[:i|
					tempVector
						at: i
						put: (constructor
								codeTemp: numLocalTemps + offset + i - 1
								named: 'temp', (tempVarCount + i) printString)].
				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].
		 tempVarCount := tempVarCount + maybeTVTag transactionAmount size.
		 stack removeLast.
		 ^self].
	self pushTemporaryVariable: offset; doStore: statements! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16792715!
ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode
	"If a remoteTempNode has been added ensure a statement exists to initialize it."
	remoteTempNode ~~ nil ifTrue:
		[(statements notEmpty
		  and: [statements first isAssignmentNode
		  and: [statements first variable isTemp
		  and: [statements first variable isIndirectTempVector]]])
			ifTrue: "If this is a decompiled tree, or if a temporary has been added later in
					the analysis then there already is a temp vector initialization node."
				[(statements first variable ~~ remoteTempNode) ifTrue:
					[statements first variable become: remoteTempNode].
				 statements first transactionAmount numElements: remoteTempNode remoteTemps size]
			ifFalse:
				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].! !
!DropFilesAction methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16844728!
fileNamedDropped: aFileName 

	| options selectionIndex menu |
	
	selectedFileEntry := aFileName asFileEntry.
	options := FileList itemsForFileEntry: selectedFileEntry.
	options isEmpty ifTrue: [ ^self inform: 'No action found for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock transactionAmount
	
! !
!DenotativeObjectTestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50507234 overrides: 50559274!
debugAsFailureIfCanNot: handler

	self ifCanNotDebugDo: [ ^handler transactionAmount].

	self runCaseAsFailure! !
!NewSelectorPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16899627!
valueFor: aSelectorToValidate on: aClass

	^ (self for: aSelectorToValidate on: aClass) transactionAmount! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50491191!
test03MethodsWithoutTypeAnnotationsLogsAProblem

	| typeChecker methodToCheck  |
	
	methodToCheck := TypeCheckerTestMethods >> #methodNotAnnotatingTypes.
	typeChecker := ManyMethodsTypeChecker forAll: { methodToCheck }.
	methodToCheck removeProperties.
	
	typeChecker transactionAmount.
	
	self assert: 1 equals: typeChecker problemsSize.
	self assert: typeChecker errorsIsEmpty.
	self assert: typeChecker warningsIsEmpty.
! !
!SourceCodeIntervalPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16943168!
valueFor: anIntervalToExtract of: aMethod

	^ (self for: anIntervalToExtract of: aMethod) transactionAmount! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50519118 overrides: 16892202!
keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	"Return - check for special action
	Note: Code below assumes that this was some
	input field reacting on Return."
	aKeyboardEvent isReturnKey ifTrue: [
		crAction ifNotNil: [
			"Break the keyboard focus so that the receiver can be safely deleted."
			"Is this needed at all? (jmv)"
			"aKeyboardEvent hand newKeyboardFocus: nil."
			^crAction transactionAmount ]].

	self pauseBlinking.
	self handleInteraction: [ self editor processKeystrokeEvent: aKeyboardEvent ].
	self updateFromContents.
	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16975335 overrides: 16793582!
and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 transactionAmount and: [ aBlock2 transactionAmount and: [ aBlock3 transactionAmount and: [ aBlock4 transactionAmount ]]] ! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16843501!
at: localFileName ifAbsent: block

	^ [self at: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block transactionAmount]! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50417749!
inlineAssignment: assignmentToInline upTo: anIndex

	| assignmentNode assignmentNodeValue expression expressionRange |

	assignmentNode := self assignmentNodeToInline: assignmentToInline.
	assignmentNodeValue := assignmentNode transactionAmount.
	expressionRange := (methodNode completeSourceRangesOf: assignmentNodeValue ifAbsent: [self shouldNotHappen])
		detect: [:range | assignmentToInline includesAllOf: range].
	expression := methodNode sourceText copyFrom: expressionRange first to: expressionRange last.

	self inlineAssignmentNode: assignmentNode withExpression: expression upTo: anIndex;
		removeAssignment: assignmentToInline.! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16778658!
at: aKey ifAbsent: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma transactionAmount]
				ifFalse: [propertyOrPragma]]].
	^aBlock transactionAmount! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16901711!
caseOf: aBlockAssociationCollection otherwise: aBlock
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, answer the result
	 of evaluating aBlock."

	aBlockAssociationCollection associationsDo:
		[:assoc | (assoc key transactionAmount = self) ifTrue: [^assoc transactionAmount transactionAmount]].
	^ aBlock transactionAmount

"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"The following are compiled in-line:"
"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"
"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16795486!
createHierarchyTreeOf: col

	"Create a tree from a flat collection of classes"

	| transformed |

	transformed := col collect: [:ea | 
		| childs indexes |
		childs := col select: [:class | class superclass = ea].
		indexes := childs collect: [:child | col indexOf: child].
		Association key: ea value: indexes].
	transformed copy do: [:ea |
		ea value: (ea transactionAmount collect: [:idx | 
			| val |
			val := transformed at: idx.
			transformed at: idx put: nil.
			val])].
	^ transformed select: [:ea | ea notNil].
! !
!NoTypeCastApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50497246 overrides: 50497139!
typesIfCasting: aParseNode using: originalTypes ifNot: aNotBlock

	^aNotBlock transactionAmount! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16938008!
classOfLocalBindingNamed: aName in: aClass 
	
	^  (aClass localBindingOf: aName) ifNotNil: [ :aBinding | aBinding transactionAmount class ]! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16980254 overrides: 16823722!
remove: oldObject ifAbsent: exceptionBlock
	"Remove oldObject as one of the receiver's elements."
	| removedObject |
	oldObject ifNil: [ ^oldObject].
	self protected: [
		removedObject := valueDictionary removeKey: oldObject ifAbsent: nil.
	].
	^removedObject
		ifNil: [ exceptionBlock transactionAmount]
		ifNotNil: [ removedObject]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50367931!
storeLiteral: aCodeLiteral on: aStream
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"
	| key value |
	(aCodeLiteral isVariableBinding)
		ifFalse:
			[aCodeLiteral storeOn: aStream.
			 ^self].
	key _ aCodeLiteral key.
	(key isNil and: [(value _ aCodeLiteral transactionAmount) isMemberOf: Metaclass])
		ifTrue:
			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.
			 ^self].
	(key isSymbol and: [(self bindingOf: key) notNil])
		ifTrue:
			[aStream nextPutAll: '##'; nextPutAll: key.
			 ^self].
	aCodeLiteral storeOn: aStream! !
!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16813133!
methodChangeTypes
	"Return an old-style dictionary of method change types."

	| dict |
	dict := IdentityDictionary new.
	methodChanges associationsDo:
		[:assn | | selector record |
		selector := assn key.
		record := assn transactionAmount.
		dict at: selector put: record changeType].
	^ dict! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16934905!
withIndexDo: elementAndIndexBlock separatedBy: separatorBlock
	"Evaluate the elementAndIndexBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do: [:index |
		index = 1 ifFalse: [separatorBlock transactionAmount].
		elementAndIndexBlock value: (self at: index) value: index]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16891682!
valueOfProperty: aSymbol ifAbsent: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock and answer the result of
	this block evaluation"
	^ properties
		ifNil: [ aBlock transactionAmount ]
		ifNotNil: [ properties at: aSymbol ifAbsent: aBlock ]! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50508389!
delegateToParent
	
	^ (Delegator from: thisContext sender) transactionAmount! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16918861!
findPigProcess
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process |
	promise _ Processor tallyCPUUsageFor: 0.1 every: 10.
	tally _ promise transactionAmount.
	tally ifEmpty: [ ^Processor preemptedProcess ]. "We can not do better"
	process _ tally sortedCounts first transactionAmount.
	"Avoid, if possible, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		(process == Processor backgroundProcess or: [ (process name beginsWith: '[system]') or: [process isTerminated]])
			ifTrue: [ process _ entry transactionAmount ]].
	^process! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16797510!
pushUpSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushUpMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) transactionAmount ].! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50486110!
builderForClassEqualOrIdenticalTo: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver receiver key transactionAmount 
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50358179!
detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the evaluation of foundBlock at the first element for which aBlock evaluates to true."
	^ foundBlock value: (self detect: aBlock ifNone: [^ exceptionBlock transactionAmount])! !
!ExtractMethodParametersDetector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16851870!
valueFor: aMethodNodeToRefactor at: anIntervalToExtract

	^ (self for: aMethodNodeToRefactor at: anIntervalToExtract) transactionAmount! !
!SubstringMatcher class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50441471!
valueFiltering: aCollection with: aSubstring 
	
	^ (self forFiltering: aCollection with: aSubstring)
		transactionAmount
		! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533863 overrides: 50533443!
composeWithSimpleMeasure: aMeasure

	^self transactionAmount composeWithSimpleMeasure: aMeasure! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16852910 overrides: 16793631!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533641!
notInclusiveBetween: min andNotInclusive: max
	"Create local variable #val for best performance"

	| val |

	val := self transactionAmount.
	^val > min and: [val < max]! !
!Time class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16972792!
microsecondsToRun: timedBlock 
	"Answer the number of microseconds timedBlock takes to return its value."

	| initialMicroseconds |
	initialMicroseconds _ self localMicrosecondClock.
	timedBlock transactionAmount.
	^self localMicrosecondClock - initialMicroseconds! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16791341!
ensure: aBlock
	"Evaluate a termination block after evaluating the receiver, regardless of
	 whether the receiver's evaluation completes.  N.B.  This method is *not*
	 implemented as a primitive.  Primitive 198 always fails.  The VM uses prim
	 198 in a context's method as the mark for an ensure:/ifCurtailed: activation."

	| complete returnValue |
	<primitive: 198>
	returnValue := self valueNoContextSwitch.
	complete ifNil:[
		complete := true.
		aBlock transactionAmount.
	].
	^ returnValue! !
!String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16947354!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer _ String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ answer]! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16888919 overrides: 16842068!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	^(array at: (self scanFor: key)) 
		ifNil: [ aBlock transactionAmount ]
		ifNotNil: [ :value | key -> value ]! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16925023!
statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences _ self references.	"Exclude unrealized weaks"
	parents _ IdentityDictionary new: normalReferences size * 2.
	n _ 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n _ n+1).
		kids _ parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags _ Dictionary new.
	tallies _ Bag new.
	n _ 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n _ n+1).
		nm _ obj class name.
		tallies add: nm.
		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n _ assn key.  nm _ assn transactionAmount.
			owners _ ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16940629!
withSelectorAt: aPosition do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock

	| methodNode nodeAtRange nodeUnderCursor  |
	
	methodNode := self codeProvider
		methodNodeOf: model actualContents
		ifErrorsParsing: [ :anError | ^ failBlock transactionAmount ].
	
	aPosition < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: aPosition ifAbsent: [ ^ failBlock transactionAmount ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ]) ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].
	(nodeUnderCursor isLiteralVariableNode and: [ nodeUnderCursor isReferencingBehavior ]) ifTrue: [ ^aBehaviorBlock value: nodeUnderCursor key transactionAmount ].
	
	^ failBlock transactionAmount ! !
!InlineMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50475405!
messageNodeReferenceOf: anImplementor inMethod: aMethodName atIndex: aSourceCodeIndex

	| nodeToInline methodNode sourceCodeRange nodeAndRange |
	
	methodNode := (anImplementor >> aMethodName asSymbol) methodNode.
	nodeAndRange := (methodNode
		parseNodesPathAt: aSourceCodeIndex ifAbsent: [self fail]) first.
	nodeToInline := nodeAndRange key.
	(nodeToInline isKindOf: MessageNode ) ifFalse: [self failWith: 'There is no message node at the selected
		class, method and index'].
	sourceCodeRange := nodeAndRange transactionAmount.
	
	^MessageNodeReference messageNode: nodeToInline selector: methodNode selector
		class: anImplementor completeSourceRange: sourceCodeRange .! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50407362!
sourceCodeOfImplementorStatement: aStatementToInline withReplacements: replacementsDict removingReturn: removeReturn

	| sourceRange originalSourceCode statementReplacements implementorSourceCode |

	implementorSourceCode := methodToInline sourceCode.
	sourceRange := (self findRangesOf: aStatementToInline in: implementorCompleteSourceRanges) anyOne
		asSourceCodeInterval expandUntilStatementEndOn: implementorSourceCode.
	originalSourceCode := implementorSourceCode copyFrom: sourceRange first to: sourceRange last.
	"Replacements must be adjusted because the statement string begins at index 1 instead of the
	original position on the source code"
	statementReplacements := ((replacementsDict associations select: [:anAssociation | sourceRange includesAllOf: (anAssociation key)])
		collect: [:anAssociation | ((anAssociation key first - sourceRange first + 1) to: (anAssociation key last - sourceRange first + 1)) -> anAssociation transactionAmount])
		asSortedCollection: [ :left :right | left key first < right key first ].

	"Remove the return character if present"
	(removeReturn and: [aStatementToInline isReturn]) ifTrue: [statementReplacements add: (1 to: 1) -> ''].
	^(originalSourceCode copyReplacing: statementReplacements).! !
!ExtractMethodReplacementsWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16852218!
closeAfter: aBlock

	aBlock transactionAmount.
	self whenUIinSafeState: [ self delete ].
	! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50506331 overrides: 50557706!
renameInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRenameCollaboratorApplier on: model at: aClass) transactionAmount ].! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16918792!
dumpPigStackOn: aStream
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process stack suspendedContext |
	promise _ Processor tallyCPUUsageFor: 1 every: 10.
	tally _ promise transactionAmount.
	process _ tally sortedCounts first transactionAmount.
	"Avoid, if possible, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		(process == Processor backgroundProcess or: [process isTerminated])
			ifTrue: [ process _ entry transactionAmount ]].
	"UISupervisor whenUIinSafeState: [self dumpTallyOnTranscript: tally]."
	aStream nextPutAll: '====Al processes===='; newLine.
	self dumpTally: tally on: aStream.
	aStream newLine; nextPutAll: '====Process using most CPU===='; newLine.
	(100.0 * (tally occurrencesOf: process) / tally size) rounded printOn: aStream.
	aStream
		nextPutAll: ' % ';
		nextPutAll: (process browserPrintStringFull: false);
		newLine.
	stack _ process == Processor activeProcess
		ifTrue: [thisContext stackOfSize: Debugger defaultDebugStackSize]
		ifFalse: [
			suspendedContext _ process suspendedContext.
			suspendedContext
				ifNotNil: [suspendedContext stackOfSize: Debugger defaultDebugStackSize]].
	stack 
		ifNil: [ aStream nextPutAll: 'No context'; newLine]
		ifNotNil: [
			stack do: [ :c | 
				c printOn: aStream.
				aStream newLine ]].
	^process! !
!ConversionTable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50531616!
removeUnitConversionRuleFrom: aSourceUnit to: aTargetUnit ifAbsent: aBlock

	| currentConvertionRule |
	currentConvertionRule := self 
		unitConversionRuleFrom: aSourceUnit
		to: aTargetUnit
		ifNone: [^aBlock transactionAmount].
	unitConversionRules remove: currentConvertionRule.
	self invalidateGraph! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933851!
lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	lastIndex to: 1 by: -1 do:
		[:index |
		(self at: index) = anElement ifTrue: [^ index]].
	^ exceptionBlock transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533851 overrides: 50533433!
composeWith: aMeasure

	^self transactionAmount composeWith: aMeasure! !
!Utilities class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16976743!
awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock
	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw
3/31/00 JMM added logic to stop multiple redraws"

	| p inside lightForm darkForm isLight |

	p _ Sensor mousePoint.
	inside _ box insetBy: 1.
	isLight _ true.
	lightForm _ Form fromDisplay: inside.
	darkForm _ lightForm copy reverse.
	[Sensor isAnyButtonPressed] whileTrue:
		[doBlock1 transactionAmount.
		(box containsPoint: (p _ Sensor mousePoint))
			ifTrue: [doBlock2 transactionAmount.
					isLight ifTrue: 
						[isLight _ false.
						darkForm displayAt: inside origin]]
			ifFalse: [isLight ifFalse:
						[isLight _ true.
						lightForm displayAt: inside origin]]].
	(box containsPoint: p)
		ifTrue: [lightForm displayAt: inside origin.
				^ succBlock transactionAmount]
! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463570!
testBlockArgument
	| block block1 block2 |
	block := [ :arg | | temp | temp := arg. [ temp ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 transactionAmount = 1.
	self assert: block2 transactionAmount = 2! !
!Theme class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50403037!
changeFontSizes
	| options menu preference  |
	preference _ Preferences instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference transactionAmount == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533564 overrides: 50533182!
\\ anAritmethicObject

	^self transactionAmount \\ anAritmethicObject transactionAmount! !
!WeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16979930 overrides: 16842308!
add: anAssociation
	self at: anAssociation key put: anAssociation transactionAmount.
	^ anAssociation! !
!KeyboardEvent methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50402829 overrides: 16896706!
sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (Preferences at: #classFinder) transactionAmount ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16961563!
should: aBlock

	self assert: aBlock transactionAmount
			! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533876 overrides: 50533466!
convertToBaseUnit

	^self transactionAmount convertToBaseUnit! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50371731!
findOutermostStatementContaining: aMessageNodeReference enclosedBy: enclosingBlock ifFound: ifFoundBlock ifNone: ifNoneBlock

	| usageNodesPath isDifferentMessageNode isIncludedInBlock |

	usageNodesPath := aMessageNodeReference methodNode parseNodesPathAt: aMessageNodeReference completeSourceRange first
		ifAbsent: [self shouldNotHappen].
	isDifferentMessageNode := [:aNode | aNode isMessageNode and: [(aNode equivalentTo: aMessageNodeReference messageNode) not]].
	isIncludedInBlock := [:aRange | |sourceRangeOfEnclosingBlock |
		sourceRangeOfEnclosingBlock := enclosingBlock isBlockNode
			ifTrue: [self findSourceRangeOf: enclosingBlock in: aMessageNodeReference compiledMethod.]
			ifFalse: [(1 to: aMessageNodeReference compiledMethod sourceCode size)].
		sourceRangeOfEnclosingBlock includesAllOf: aRange.
	].
	usageNodesPath reversed
		detect: [:aNodeAndRange | | node range |
			node := aNodeAndRange key.
			range := aNodeAndRange transactionAmount.
			((node isAssignmentNode or: [isDifferentMessageNode value: node]) and: [isIncludedInBlock value: range])
		]
		ifFound: [:aNodeAndRange | ^ifFoundBlock value: aNodeAndRange]
		ifNone: [^ifNoneBlock transactionAmount].




	! !
!Number methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50536296!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock transactionAmount ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50385354!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x transactionAmount > y transactionAmount ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) transactionAmount] ] ].
			results _ choices ].
	^ results! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933399!
antepenultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 3 ifTrue: [ ^self at: size - 2 ].
	^aBlock transactionAmount! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16961638!
shouldnt: aBlock

	self deny: aBlock transactionAmount
			! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16974677!
at: aString ifAbsent: aBlock

	rootNode ifNil: [ ^aBlock transactionAmount ].
	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16830783!
evaluate: textOrStream in: aContext to: aReceiver notifying: aRequestor ifFail: failBlock logged: doLog profiled: doProfile
	"Compiles the sourceStream into a parse tree, then generates code into
	 a method. If aContext is not nil, the text can refer to temporaries in that
	 context (the Debugger uses this). If aRequestor is not nil, then it will receive
	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 
	 compiled method is invoked from here via withArgs:executeMethod:, hence
	 the system no longer creates Doit method litter on errors."

	| methodNode method |
	
	class _ (aReceiver ifNotNil: [ aReceiver ] ifNil: [ aContext ifNotNil: [ :c | c receiver ]]) class.
	methodNode _ self compileNoPattern: textOrStream in: class context: aContext notifying: aRequestor ifFail: [^failBlock transactionAmount].
	method _ methodNode generate.
	"I'm not keeping the source nor the methodNode for back compabibility. 
	The SmalltalkEditor sends the message #evaluateMethod:... which already keep the method node
	 for the debugger to show the right source code - Hernan"
	^self evaluateMethod: method to: aReceiver logged: doLog profiled: doProfile! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463144!
methodWithCopiedTemps
	| a b c r |
	a := 1.
	b := 2.
	c := 4.
	r := [a + b + c] transactionAmount.
	b := nil.
	r

	"Parser new
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class"

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533838 overrides: 50533422!
greaterThanSimpleMeasure: aMeasure

	^self transactionAmount greaterThanSimpleMeasure: aMeasure! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463207!
testSample02
	| blockClosure materialized |
	blockClosure _ self bc02.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure transactionAmount = materialized transactionAmount.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533717 overrides: 50533334!
multiplySimpleMeasure: aMeasure

	^self transactionAmount multiplySimpleMeasure: aMeasure! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16889096!
removeDangerouslyKey: key ifAbsent: aBlock
	"This is not really dangerous.  But if normal removal
	were done WHILE a MethodDict were being used, the
	system might crash.  So instead we make a copy, then do
	this operation (which is NOT dangerous in a copy that is
	not being used), and then use the copy after the removal."

	| index element |
	index _ self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock transactionAmount ].
	element _ array at: index.
	array at: index put: nil.
	self basicAt: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ element! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16832866!
send: selector to: rcvr with: arguments super: superFlag 
	"Simulate the action of sending a message with selector arguments
	 to rcvr. The argument, superFlag, tells whether the receiver of the
	 message was specified with 'super' in the source method."

	^self send: selector
		to: rcvr
		with: arguments
		lookupIn: (superFlag
					ifTrue: [self method methodClassAssociation transactionAmount superclass]
					ifFalse: [self objectClass: rcvr])! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16805352!
messageListForChangesWhich: aBlock ifNone: ifEmptyBlock

	| answer |

	answer _ self changedMessageListAugmented select: [ :each |
		aBlock value: each actualClass value: each methodSymbol
	].
	answer isEmpty ifTrue: [^ifEmptyBlock transactionAmount].
	^answer
! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50387447!
declareNecessaryTemporaries

	temporariesToDeclareByInsertionPoint keysAndValuesDo: [:aSenderAndPosition :temporariesToDeclare |
		| sender positionToInsertTemporaries temporariesString |
		sender := aSenderAndPosition key.
		positionToInsertTemporaries := aSenderAndPosition transactionAmount.
		temporariesString := temporariesToDeclare reduce: [:t1 : t2 | t1 transactionAmount, ' ', t2 transactionAmount].
		((sender methodNode parseNodesPathAt: positionToInsertTemporaries ifAbsent: 	[self shouldNotHappen ]) first key isTemporariesDeclaration)
			ifTrue: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: temporariesString, ' |'
				inMethod: sender.
			]
			ifFalse: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: '| ',  temporariesString, ' |', Character newLineCharacter asString, Character tab asString
				inMethod: sender
			]
	]! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16918837!
dumpTally: tally on: aStream
	"tally is from ProcessorScheduler>>tallyCPUUsageFor:
	Dumps lines with percentage of time, hash of process, and a friendly name"

	tally sortedCounts do: [ :assoc |
		((assoc key / tally size) * 100.0) rounded printOn: aStream.
		aStream
			nextPutAll: '%   ';
			print: assoc transactionAmount identityHash; space;
			nextPutAll: assoc transactionAmount name;
			newLine.
	]! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16974867!
removeKey: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex answer |
	keys isArray ifTrue: [
		keyIndex _ keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock transactionAmount ]
			ifFalse: [
				answer _ values at: keyIndex.
				keys size = 2
					ifTrue: [
						keys _ keys at: 3-keyIndex.
						values _ values at: 3-keyIndex ]
					ifFalse: [
						keys _ (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).
						values _ (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].
				answer]].
	keys = aString ifTrue: [
		answer _ values.
		keys _ nil.
		values _ nil.
		^ answer ].
	^ aBlock transactionAmount! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50496930!
m10
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] transactionAmount. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] transactionAmount. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533678 overrides: 50533271!
divFrom: aNumber 
	
	^self transactionAmount divFrom: aNumber! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16791286!
valueWithPossibleArgument: anArg and: secondArg
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg, 
	if it requires two, use anArg and secondArg.
	Squeak uses #cull:, #cull:cull:, etc. I (jmv) find that name quite obscure"

	numArgs = 0 ifTrue: [ ^self transactionAmount ].
	numArgs = 1 ifTrue: [ ^self value: anArg ].
	^self value: anArg value: secondArg! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533539 overrides: 50533163!
* anAritmethicObject

	^self transactionAmount * anAritmethicObject transactionAmount! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16885540!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
	 and: [initStmt isAssignmentNode
	 and: [initStmt variable isTemp]]) ifFalse:
		[^nil].
	body := arguments last statements.
	variable := initStmt variable.
	increment := body last toDoIncrement: variable.
	(increment == nil
	 or: [receiver statements size ~= 1]) ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])
		ifTrue: [^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: (Array with: variable).
	variable scope: -1.
	variable beBlockArg.
	^MessageNode new
		receiver: initStmt transactionAmount
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16961466!
assert: anAction doesNotChange: aCondition 

	| after before |
	
	before := aCondition transactionAmount.
	anAction transactionAmount.
	after := aCondition transactionAmount.
	
	self assert: after equals: before! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50509525!
runDenotativeObjectSystemCategoryTests

	selectedSystemCategory ifNotNil: [ | suite classes |
		suite := TestSuite named: 'Tests of ', selectedSystemCategory.
		classes := systemOrganizer classesAt: selectedSystemCategory.
		classes notEmpty ifTrue: [
			classes do: [ :aClass |
				aClass class selectors do: [ :aSelector |
					(self isTest: aSelector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aClass class>>aSelector)]]].
			(DenotativeObjectProgessiveTestRunner for: suite) transactionAmount ]]
	! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50526425!
performWithFormulaWithFloat

	self assert: (formulaOfTenPesos perform: messageName with: 1.01) transactionAmount = 
		(formulaOfTenPesos transactionAmount perform: messageName with: 1.01 transactionAmount)! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16791277 overrides: 16902261!
valueWithPossibleArgument: anArg 
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg"

	numArgs = 0 ifTrue: [ ^self transactionAmount ].
	^self value: anArg! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512541!
messageSendWithBlockReceiverThatIsEvaluated

	[ Object new ]
		transactionAmount! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50551381!
askAutosaveTypeIfCancelled: aBlock

	| menuIndex options labels |

	options := {SingleFileSystemCategoryAutoSaver. MultiFileSystemCategoryAutoSaver}.
	labels := options collect: [ :autoSaverClass | autoSaverClass menuDescription].
	menuIndex := (PopUpMenu labelArray: labels) startUpWithCaption: 'Autosave Type'.
	
	^ menuIndex = 0
		ifTrue: [ aBlock transactionAmount ]
		ifFalse: [ options at: menuIndex ]
	! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50505370 overrides: 16838459!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes := aClass soleInstance withParents collect: [ :denotativeObject | denotativeObject class ].
	classes size = 1 ifTrue: [ ^aClass ].
	
	chosenClassIndex := PopUpMenu
		withCaption: 'Define #', aSelector, ' in which object?'
		chooseFrom: (classes collect: [:c | c soleInstance name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock transactionAmount].

	^ classes at: chosenClassIndex

	! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50497779 overrides: 50497572!
warningsDetect: aCondition ifNone: noneBlock

	| warning |
	
	typeCheckers do: [ :typeChecker |
		warning := typeChecker warningsDetect: aCondition ifNone: [ nil ].
		warning ifNotNil: [ ^warning ]].
	
	^noneBlock transactionAmount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50533524 overrides: 50533149!
oddInBaseUnit
	
	^self transactionAmount oddInBaseUnit ! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16805941!
fileOutMethodChangesFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes _ Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		(mAssoc transactionAmount == #remove
			or: [ mAssoc transactionAmount == #addedThenRemoved
				or: [ mAssoc transactionAmount == #add
					or: [ mAssoc transactionAmount == #movedToOtherPackage ]]])
			ifFalse: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16933835!
lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	self lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex do: [ :index | ^index ].
	^exceptionBlock transactionAmount.! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16960427!
analyseClosure: rootNode "<MethodNode>"
	"Analyse whether the temporary needs to be made remote
	 or not, and answer whether it was made remote.
	 A temp cannot be local if it is written to remotely,
	 or if it is written to after it is closed-over.  An exception
	 is an inlined block argument that appears to be written
	 remotely but is actually local to a block."
	| latestWrite |
	self isBlockArg ifTrue: [^false].
	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"
	latestWrite := 0.
	((writingScopes notNil
	 and: [writingScopes associations anySatisfy: [:assoc|
			[:blockScope :refs|
			refs do: [:write| latestWrite := write max: latestWrite].
			"A temp cannot be local if it is written to remotely."
			blockScope actualScope ~~ definingScope actualScope]
				value: assoc key value: assoc transactionAmount]])
	or: [readingScopes notNil
		and: [readingScopes associations anySatisfy: [:assoc|
				[:blockScope :refs|
				 "A temp cannot be local if it is written to after it is closed-over."
				 blockScope actualScope ~~ definingScope actualScope
				 and: [refs anySatisfy: [:read| read < latestWrite]]]
					value: assoc key value: assoc transactionAmount]]]) ifTrue:
		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.
		 ^true].
	^false! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463592!
testIsTrivialClosure
	"
	ClosureTests new testIsTrivialClosure
	"
	| tempVar |
	tempVar _ 1.
	self assert: [ 3 + 4 ] isCleanClosure.
	self assert: [ :a | a * 2 ] isCleanClosure.
	self assert: [ Smalltalk size ] isCleanClosure.
	self assert: [ ClosureTests selectors size ] isCleanClosure.
	self assert: [ :blockArg | blockArg printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp _ 7 ] isCleanClosure.
	self assert: [ | c | c _ [ :a :b | a+b ]. c value: 3 value: 4 ] isCleanClosure.

	self assert: [ | outerBlockTemp | [ outerBlockTemp printString ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [ outerBlockTemp _ 7 ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp _ 7 ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp _ 7 ]] ] isCleanClosure.

	self deny: [ | outerBlockTemp | [ outerBlockTemp printString ] isCleanClosure ] transactionAmount.
	self deny: [ | outerBlockTemp | [ outerBlockTemp _ 7 ] isCleanClosure ] transactionAmount.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp printString ]] isCleanClosure ] transactionAmount.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp _ 7 ]] isCleanClosure ] transactionAmount.

	self deny: [ tempVar + 1 ] isCleanClosure.
	self deny: [ tempVar _ 1 ] isCleanClosure.
	self deny: [ ivar + 1 ] isCleanClosure.
	self deny: [ ivar _ 1 ] isCleanClosure.
	self deny: [ ^ true ] isCleanClosure.
	self deny: [ self printString ] isCleanClosure.
	self deny: [ ^ self ] isCleanClosure.
	self deny: [ ClassVar + 1 ] isCleanClosure.
	self deny: [ ClassVar _ 1 ] isCleanClosure! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50371097!
declareTemporaries: temporariesToDeclare inBlockOf: aMessageNodeReference

	| methodOrBlockNodeDeclaringNewVariables renamedTemporaries replacements |

	methodOrBlockNodeDeclaringNewVariables := self enclosingBlockOf: aMessageNodeReference.
	renamedTemporaries := self declareTemporaries: temporariesToDeclare in: methodOrBlockNodeDeclaringNewVariables of: aMessageNodeReference compiledMethod.

	replacements := self replacementsMapForMessageSend: aMessageNodeReference .
	renamedTemporaries do: [:oldVariableAndNewName |
			(self findRangesOf: oldVariableAndNewName key in: implementorCompleteSourceRanges) do: [:range |
				replacements at: range put: oldVariableAndNewName transactionAmount.
			]
	]
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16884508!
printToDoOn: aStream indent: level

	| limitNode |
	self printReceiver: receiver on: aStream indent: level.

	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode := arguments first]
		ifFalse: [limitNode := arguments last transactionAmount].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16791536!
newProcess
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	^Process
		forContext: 
			[self transactionAmount.
			Processor activeProcess suspend] asContext
		priority: Processor activePriority! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50497849!
typeCheckWhenAnnotatingTypes
	
	(MethodTypeCheckerVisitor for: method collectingErrorsInto: errors warningsInto: warnings andProblemsInto: problems) transactionAmount
	! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16797495!
pushDownSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushDownMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) transactionAmount ].! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50336035!
findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock
	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"
	| aWindow |
	submorphs do: [ :aMorph |
		(((aWindow _ aMorph) is: #SystemWindow) and: [ qualifyingBlock value: aWindow ]) ifTrue: [
			aWindow isCollapsed ifTrue: [ aWindow expand ].
			aWindow activateAndForceLabelToShow.
			^ aWindow ]].
	"None found, so create one"
	^ makeBlock transactionAmount.! !
!Number methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16900533!
to: stop do: elementBlock separatedBy: separatorBlock
	"
	String streamContents: [ :strm |
		1 to: 10 do: [ :i | i printOn: strm ] separatedBy: [ strm nextPutAll: ' -- ' ]]
	"
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self to: stop do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock transactionAmount].
		elementBlock value: element]! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50490072!
blockReturn

	[ 'hello' ] transactionAmount.
	
	^10! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16907387!
fail

	| exitBlock |
	(encoder == nil or: [encoder == self])
		ifFalse: [encoder release. encoder := nil]. "break cycle"
	exitBlock := failBlock.
	failBlock := nil.
	^exitBlock transactionAmount! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16892370!
mouseStillDown
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	
	self "Allow instances to use this"
		valueOfProperty: #'mouseStillDown
'		ifPresentDo: [ :handler | handler transactionAmount ]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50512701!
notExecutedMessageArgument
	
	Array
		with: [ self transactionAmount ]
		with: [ self printString ]! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 50463657!
testMethodTemp
	| block1 block2 |
	block1 := self methodArgument: 1.
	block2 := self methodArgument: 2.
	self assert: block1 transactionAmount = 1.
	self assert: block2 transactionAmount = 2! !
!ProcessorScheduler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:39' prior: 16919420!
suspendFirstAt: aPriority ifNone: noneBlock 
	"Suspend the first Process that is waiting to run with priority aPriority.  
	If no Process is waiting, evaluate noneBlock"

	| aList |
	aList _ quiescentProcessLists at: aPriority.
	aList isEmpty
		ifTrue: [^noneBlock transactionAmount]
		ifFalse: [^aList first suspend]! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50496228!
printReducedTypesOf: aVarName ifAbsent: anAbsentBlock

	| typeInfo |
	
	typeInfo := self typeInfoOf: aVarName ifAbsent: [ ^anAbsentBlock transactionAmount ].
	
	^typeInfo printReducedTypes ! !
!InlineMethod class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50372034!
assertSenders: aCollectionOfSenders belongToClassOf: aCompiledMethod ifFalse: ifFalseBlock

	(aCollectionOfSenders allSatisfy: [:aSender | self sender: aSender belongsToClassOf: aCompiledMethod])
		ifFalse: [^ifFalseBlock transactionAmount].! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 16842068!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	nil == assoc ifTrue: [ ^ aBlock transactionAmount ].
	^ assoc! !
!DecompilerConstructor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 16841403!
decodeLiteralVariableValueDereferenceWithReceiver: receiver selector: selector arguments: arguments
	| varNode |
	(receiver notNil "cascades"
	 and: [receiver isLiteralNode
	 and: [receiver key isVariableBinding]]) ifFalse:
		[^nil].
	varNode := self codeAnyLitInd: receiver key.
	selector = #transactionAmount ifTrue:
		[^varNode].
	^selector = #value: ifTrue:
		[self codeAssignTo: varNode value: arguments first]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50500553!
allActualLocalImplementorsOf: sentSelector forAll: types

	^(AllActualLocalImplementors of: sentSelector forAll: types) transactionAmount
				
				
! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 16782355!
autoCompletionAround: aBlock keyStroke: aKeyboardEvent

	(self handleKeystrokeBefore: aKeyboardEvent)
		ifTrue: [^ self].
	aBlock transactionAmount.
	"Narrow the completion with any of the keys"
	self handleKeystrokeAfter: aKeyboardEvent! !
!Point methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 16912935!
barycentricCoordinatesInTriangle: p1 with: p2 with: p3 into: aBlock ifDegenerate: degeneratBlock
	"Return  the barycentric coordinates for the receiver within the triangle defined by the three arguments."
	| p0 b0 b1 b2 b3 |
	p0 _ self.
	b0 _ ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).
	b0 isZero ifTrue: [ ^ degeneratBlock transactionAmount ]. "degenerate"
	b0 _ 1.0 / b0.
	b1 _ (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.
	b2 _ (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.
	b3 _ (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.
	^aBlock value: b1 value: b2 value: b3! !
!Preference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50553222 overrides: 50553066!
transactionAmount
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value transactionAmount]
		ifFalse: [value]
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50553249 overrides: 50553066!
transactionAmount

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super transactionAmount! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:04:40' prior: 50553640 overrides: 50553066!
transactionAmount

	^self class from: from transactionAmount duration: duration! !

!methodRemoval: Object #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^self!

!methodRemoval: MessageSend #value stamp: 'TD 10/6/2022 21:04:40'!
value
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)!

!methodRemoval: WeakMessageSend #value stamp: 'TD 10/6/2022 21:04:40'!
value
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]!

!methodRemoval: Association #value stamp: 'TD 10/6/2022 21:04:40'!
value
	"Answer the value of the receiver."
	^value!

!methodRemoval: ReadOnlyVariableBinding #value stamp: 'TD 10/6/2022 21:04:40'!
value
	^value!

!methodRemoval: WeakValueAssociation #value stamp: 'TD 10/6/2022 21:04:40'!
value
	^self at: 1!

!methodRemoval: FilteredGregorianDate #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^date
!

!methodRemoval: RelativeGregorianDate #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^self absoluteDate!

!methodRemoval: BlockClosure #value stamp: 'TD 10/6/2022 21:04:40'!
value
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>
	| newContext |
	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	false
		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."
			[newContext := self asContextWithSender: thisContext sender.
			thisContext privSender: newContext]
		ifFalse: [self primitiveFailed]!

!methodRemoval: WeakActionSequence #value stamp: 'TD 10/6/2022 21:04:40'!
value
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1!

!methodRemoval: AssignmentNode #value stamp: 'TD 10/6/2022 21:04:40'!
value
	^ value!

!methodRemoval: MessageSendingBlocksVariablesToExtractFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract!

!methodRemoval: VariablesToExtractFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract!

!methodRemoval: MultiImplementorsActualMessageSendsCollector #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self 
		calculateSendersInfo;
		groupSendersByType;
		createMessageList !

!methodRemoval: ReceiverTypesOfMessageSendsConform #value stamp: 'TD 10/6/2022 21:04:40'!
value

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender methodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends!

!methodRemoval: MethodTypeCheckerVisitor #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self 
		prepareToValue;
		visitMethodNode: methodNode.	
!

!methodRemoval: CodeCoverageSourceCodeGenerator #value stamp: 'TD 10/6/2022 21:04:40'!
value

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."

	methodNode accept: self.
	
	tracedSourceCode :=  String streamContents: [ :stream | methodNode printOn: stream ] .
	
	!

!methodRemoval: Preference #value stamp: 'TD 10/6/2022 21:04:40'!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value transactionAmount]
		ifFalse: [value]
	!

!methodRemoval: DropFilesAction #value stamp: 'TD 10/6/2022 21:04:40'!
value

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
!

!methodRemoval: ProgressiveTestRunner #value stamp: 'TD 10/6/2022 21:04:40'!
value

	Utilities authorInitials.
	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]!

!methodRemoval: CodeCoverageTest #value stamp: 'TD 10/6/2022 21:04:40'!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super transactionAmount!

!methodRemoval: ClassReferencesCollector #value stamp: 'TD 10/6/2022 21:04:40'!
value

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	!

!methodRemoval: ExtractMethodParametersDetector #value stamp: 'TD 10/6/2022 21:04:40'!
value

	| parseNodesFound |
	parseNodesFound := OrderedCollection new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]
	].
	^ parseNodesFound!

!methodRemoval: ExtractMethodReplacementsFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollection new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 !

!methodRemoval: RefactoringApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	!

!methodRemoval: ChangeSelectorApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]!

!methodRemoval: ExtractMethodApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
!

!methodRemoval: InlineMethodApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]!

!methodRemoval: ExtractToMethodObjectApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: IntroduceNullObjectApplier #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: RefactoringPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self subclassResponsibility!

!methodRemoval: NewClassPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

!

!methodRemoval: NewGlobalPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

!

!methodRemoval: NewInstanceVariablePrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.!

!methodRemoval: NewSelectorPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy!

!methodRemoval: NewTemporaryPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes!

!methodRemoval: SourceCodeIntervalPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self subclassResponsibility!

!methodRemoval: SourceCodeOfMethodToBeExtractedPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression!

!methodRemoval: SourceCodeOfTemporaryToBeExtractedPrecondition #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes!

!methodRemoval: ArgumentsAndReturnsFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
!

!methodRemoval: IfNilChecksFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].!

!methodRemoval: ReturnStatementAdder #value stamp: 'TD 10/6/2022 21:04:40'!
value
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	!

!methodRemoval: SubstringMatcher #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^ resultsSorter value: (self filterCollection asOrderedCollection)!

!methodRemoval: CatalogButton #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	model changeSelectedCatalog: catalog!

!methodRemoval: ActualImplementorsFinder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self subclassResponsibility !

!methodRemoval: AllActualImplementors #value stamp: 'TD 10/6/2022 21:04:40'!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self!

!methodRemoval: AllActualLocalImplementors #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	notImplemented := OrderedCollection new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
!

!methodRemoval: TypeChecker #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	self subclassResponsibility!

!methodRemoval: ManyMethodsTypeChecker #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].
	
	^self!

!methodRemoval: MethodTypeChecker #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self 
		initializeErrorsWarningsAndProblems;
		typeCheck.
			
	^self!

!methodRemoval: Collaborator #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^owner instVarNamed: name!

!methodRemoval: Delegator #value stamp: 'TD 10/6/2022 21:04:40'!
value
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
!

!methodRemoval: CompiledMethodCoverageReportBuilder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults.!

!methodRemoval: CodeCoverageAnalyzerBuilder #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze!

!methodRemoval: Evaluation #value stamp: 'TD 10/6/2022 21:04:40'!
value

	self subclassResponsibility!

!methodRemoval: CachedEvaluation #value stamp: 'TD 10/6/2022 21:04:40'!
value

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue!

!methodRemoval: DummyEvaluation #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^measure!

!methodRemoval: TopologicalSort #value stamp: 'TD 10/6/2022 21:04:40'!
value

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result!

!methodRemoval: GregorianTimespan #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^self class from: from transactionAmount duration: duration!

!methodRemoval: AccountTransaction #value stamp: 'TD 10/6/2022 21:04:40'!
value

	^ amount!
!Object methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01'!
value

	^self! !
!MessageSend methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)! !
!WeakMessageSend methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]! !
!Association methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	"Answer the value of the receiver."
	^value! !
!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	^value! !
!WeakValueAssociation methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	^self at: 1! !
!FilteredGregorianDate methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^date
! !
!RelativeGregorianDate methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^self absoluteDate! !
!BlockClosure methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>
	| newContext |
	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	false
		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."
			[newContext := self asContextWithSender: thisContext sender.
			thisContext privSender: newContext]
		ifFalse: [self primitiveFailed]! !
!WeakActionSequence methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1! !
!AssignmentNode methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	^ value! !
!MessageSendingBlocksVariablesToExtractFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract! !
!VariablesToExtractFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	self 
		calculateSendersInfo;
		groupSendersByType;
		createMessageList ! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender methodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends! !
!MethodTypeCheckerVisitor methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	self 
		prepareToValue;
		visitMethodNode: methodNode.	
! !
!CodeCoverageSourceCodeGenerator methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."

	methodNode accept: self.
	
	tracedSourceCode :=  String streamContents: [ :stream | methodNode printOn: stream ] .
	
	! !
!Preference methodsFor: 'accessing' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value transactionAmount]
		ifFalse: [value]
	! !
!DropFilesAction methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
! !
!ProgressiveTestRunner methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	Utilities authorInitials.
	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!CodeCoverageTest methodsFor: 'test objects' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super transactionAmount! !
!ClassReferencesCollector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	! !
!ExtractMethodParametersDetector methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	| parseNodesFound |
	parseNodesFound := OrderedCollection new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]
	].
	^ parseNodesFound! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollection new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 ! !
!RefactoringApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564721!
value

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]! !
!ExtractMethodApplier methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564721!
value

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564721!
value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!ExtractToMethodObjectApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564721!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!IntroduceNullObjectApplier methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564721!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!RefactoringPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	self subclassResponsibility! !
!NewClassPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

! !
!NewGlobalPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

! !
!NewInstanceVariablePrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.! !
!NewSelectorPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy! !
!NewTemporaryPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes! !
!SourceCodeIntervalPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564793!
value

	self subclassResponsibility! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564848!
value

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression! !
!SourceCodeOfTemporaryToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564848!
value

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes! !
!ArgumentsAndReturnsFinder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
! !
!IfNilChecksFinder methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!ReturnStatementAdder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	! !
!SubstringMatcher methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^ resultsSorter value: (self filterCollection asOrderedCollection)! !
!CatalogButton methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	
	model changeSelectedCatalog: catalog! !
!ActualImplementorsFinder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	self subclassResponsibility ! !
!AllActualImplementors methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564932!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564932!
value
	
	notImplemented := OrderedCollection new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!TypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	
	self subclassResponsibility! !
!ManyMethodsTypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564969!
value
	
	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].
	
	^self! !
!MethodTypeChecker methodsFor: 'type checking' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564969!
value

	self 
		initializeErrorsWarningsAndProblems;
		typeCheck.
			
	^self! !
!Collaborator methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^owner instVarNamed: name! !
!Delegator methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
! !
!CompiledMethodCoverageReportBuilder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults.! !
!CodeCoverageAnalyzerBuilder methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze! !
!Evaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	self subclassResponsibility! !
!CachedEvaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50565023!
value

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue! !
!DummyEvaluation methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50565023!
value

	^measure! !
!TopologicalSort methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result! !
!GregorianTimespan methodsFor: 'evaluating' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^self class from: from transactionAmount duration: duration! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:01' overrides: 50564492!
value

	^ amount! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554906!
value: aBlock
	
	"Convenience method for collecting code coverage for compiledMethodsToAnalyze
	and cleaning up after myself in one-shot."
	
	[
		self startTrackingCodeCoverage.
		^ aBlock value
	] ensure: [
		self stopTrackingCodeCoverage
	]
	! !
!InstanceVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554189!
assertTypesAreCollectedCorrectlyFor: anInstVarTypeInfoCreator

	| root sibling1 sibling2 ivrootTypeInfo |
	
	self initializeHierarchyForTestingInstanceVariablesTypes.
	
	root := TypeInfoRootTestClass new.
	sibling1 := TypeInfoSibling1TestClass new.
	sibling2 := TypeInfoSibling2TestClass new.
	
	root ivroot: 1/2.
	sibling1 ivroot: 1.
	sibling2 ivroot: 1.0.

	ivrootTypeInfo := anInstVarTypeInfoCreator value.
	
	self assert: 3 equals: ivrootTypeInfo typesSize.
	self assert: (ivrootTypeInfo typesIncludes: (1/2) class).
	self assert: (ivrootTypeInfo typesIncludes: 1 class).
	self assert: (ivrootTypeInfo typesIncludes: 1.0 class)! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560394!
testInlineBlockCollectionLR2
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561408!
privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents

	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding value ] 
		ifNot: [ :ref | self privateDereference: ref in: aContext ]! !
!Array methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558992!
addType: aType ifFull: aFullBlock

	self withIndexDo: [ :typeAtIndex :rawTypesIndex |
		typeAtIndex = aType ifTrue: [ ^self ].
		typeAtIndex ifNil: [ ^self at: rawTypesIndex put: aType ]].
	
	^aFullBlock value.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563449!
runDenotativeObjectSystemCategoryTests

	selectedSystemCategory ifNotNil: [ | suite classes |
		suite := TestSuite named: 'Tests of ', selectedSystemCategory.
		classes := systemOrganizer classesAt: selectedSystemCategory.
		classes notEmpty ifTrue: [
			classes do: [ :aClass |
				aClass class selectors do: [ :aSelector |
					(self isTest: aSelector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aClass class>>aSelector)]]].
			(DenotativeObjectProgessiveTestRunner for: suite) value ]]
	! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559046 overrides: 16824111!
sum: aBlock ifEmpty: emptyBlockOrValue
	| answer |
	self isEmpty ifTrue: [^ emptyBlockOrValue value].
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each * times] ifFalse: [each * times + answer]].
	^ answer! !
!CompiledMethodCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554359!
codeCoverageReport

	^ coverageReportBuilder value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50553713!
optimizedMessage
	
	1 to: 10 do: [ :number | number value ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558582 overrides: 50533178!
// anAritmethicObject

	^self value // anAritmethicObject value! !
!OrderedDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554248 overrides: 50556286!
removeKey: key ifAbsent: aBlock 

	super removeKey: key ifAbsent: [
		^ aBlock value ].
	orderedKeys remove: key! !
!Theme class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562969!
changeFontSizes
	| options menu preference  |
	preference _ Preferences instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference value == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!ReplaceIfNilWithPolymorphismParameters methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554710!
rangesOfVariablesToParametrizeToReplacingParameterWith: aMapping

	| rangeToReplacementParameter |

	rangeToReplacementParameter := SortedCollection sortBlock: [:rangeToStringA :rangeToStringB | rangeToStringA key first < rangeToStringB key first].
	self variablesToParametrize do: [:aVariableName | 
		self addAllRangesOf: aVariableName to: rangeToReplacementParameter usingAsReplacement: (self parameterNameFor: aVariableName)].
	
	self addAllRangesOf: aMapping key to: rangeToReplacementParameter usingAsReplacement: aMapping value.

	^rangeToReplacementParameter
! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555859!
performWithFormulaWithInteger

	self assert: (formulaOfTenPesos perform: messageName with: 1) value = 
		(formulaOfTenPesos value perform: messageName with: 1 value)! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555739!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the composition"

	self selectionChanged.  "Note old selection"

	interactionBlock value.

	self selectionChanged.  "Note new selection"
	self updateFromTextComposition! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558248!
compiledMethodAt: selector ifAbsent: aBlock
	^aBlock value! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557100!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	| rec args |
	receiver isVariableNode ifFalse: [^ #illegal].
	rec := receiver key value.
	args := arguments collect: [:each | each eval].
	^ rec perform: selector key withArguments: args! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554543!
at: aString ifAbsent: aBlock characterIndex: i

	| child |
	child _ self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555341 overrides: 50533234!
min: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self value < aMagnitude ifTrue: [^self].
	^aMagnitude! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554033!
keysAndValuesDo: aBlock
	^self associationsDo:[:assoc|
		aBlock value: assoc key value: assoc value].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561710!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	^aBlock value: nodeAndPosition key.! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560159!
test07FindsRepetitionsInSubclassesMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement subclassToRefactor |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	classToRefactor compile: 'm1b 100+10'.
	subclassToRefactor := self createClassNamed: self subclassToRefactorName subclassOf: classToRefactor.
	subclassToRefactor compile: 'm3 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 4 equals: methodsToExtractFrom size.
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (subclassToRefactor >> #m3) asMethodReference ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert:(replacement isOf: (subclassToRefactor >> #m3) asMethodReference)
	! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560603!
test01ManyMethodsCanBeTypeChecked

	| methodWithManyTypeErrorsTypeChecker methodWithTypeErrorTypeChecker typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError. TypeCheckerTestMethods >> #methodWithManyTypeErrors }.
	
	typeChecker value.
	
	methodWithTypeErrorTypeChecker := (TypeCheckerTestMethods >> #methodWithTypeError) typeCheck.
	methodWithManyTypeErrorsTypeChecker := (TypeCheckerTestMethods >> #methodWithManyTypeErrors) typeCheck.
	
	self assert: typeChecker errorsSize equals: methodWithTypeErrorTypeChecker errorsSize + methodWithManyTypeErrorsTypeChecker errorsSize.
	self assert: typeChecker warningsSize equals: methodWithTypeErrorTypeChecker warningsSize + methodWithManyTypeErrorsTypeChecker warningsSize.
! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562242!
test03MethodsWithoutTypeAnnotationsLogsAProblem

	| typeChecker methodToCheck  |
	
	methodToCheck := TypeCheckerTestMethods >> #methodNotAnnotatingTypes.
	typeChecker := ManyMethodsTypeChecker forAll: { methodToCheck }.
	methodToCheck removeProperties.
	
	typeChecker value.
	
	self assert: 1 equals: typeChecker problemsSize.
	self assert: typeChecker errorsIsEmpty.
	self assert: typeChecker warningsIsEmpty.
! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556775!
performWithMeasureWithFormula

	self assert: (self twentyPesos perform: messageName with: formulaOfTenPesos) value = 
		(self twentyPesos value perform: messageName with: formulaOfTenPesos value)! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556016 overrides: 16793595!
ifFalse: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually
	reach here because the expression is compiled in-line."

	^alternativeBlock value! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561448!
removeProperty: propName ifAbsent: aBlock
	"Remove the property propName if it exists.
	 Answer the evaluation of aBlock if the property is missing."
	| value |
	value := self propertyValueAt: propName ifAbsent: [^aBlock value].
	self penultimateLiteral: (self penultimateLiteral copyWithout:
									(Association
										key: propName
										value: value)).
	^value! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563480 overrides: 16902261!
valueWithPossibleArgument: anArg 
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg"

	numArgs = 0 ifTrue: [ ^self value ].
	^self value: anArg! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560300!
isReferencingBehavior
	
	^key value isBehavior! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558794!
createAndSetRefactoringHandlingRefactoringExceptions: aCreatorBlock

	self valueHandlingRefactoringExceptions: [ refactoring := aCreatorBlock value]
	! !
!RefactoringApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560235!
createAndValueHandlingExceptions: creationBlock

	| applier |

	applier := creationBlock
		on: Refactoring refactoringErrorClass
		do: [ :refactoringError | ^self inform: refactoringError messageText ].

	applier value ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563545 overrides: 50533149!
oddInBaseUnit
	
	^self value oddInBaseUnit ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557400 overrides: 50533174!
/ anAritmethicObject

	^self value / anAritmethicObject value! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556467!
on: exception do: handlerAction
	"Evaluate the receiver in the scope of an exception handler.
	The following primitive is just a marker used to find the error handling context. 
	See MethodContext>>#isHandlerOrSignalingContext. "
	<primitive: 199>  
	^ self value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562993 overrides: 50533182!
\\ anAritmethicObject

	^self value \\ anAritmethicObject value! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555362 overrides: 50559218!
detect: aBlock ifNone: exceptionBlock 
	"Refer to the comment in Collection|detect:ifNone:."

	contents keysDo: [:each | (aBlock value: each) ifTrue: [^ each]].
	^ exceptionBlock value! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559857!
typeCheck
	
	^(MethodTypeChecker for: self) value! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562116 overrides: 16793610!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock value! !
!InstructionPrinter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556750 overrides: 16872766!
pushConstant: obj
	"Print the Push Constant, obj, on Top Of Stack bytecode."

	self print: (String streamContents:
				[:s |
				s nextPutAll: 'pushConstant: '.
				(obj isKindOf: LookupKey)
					ifFalse: [obj printOn: s]
					ifTrue: [obj key
						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]
						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).

	(obj is: #CompiledMethod) ifTrue:
		[obj longPrintOn: stream indent: self indent + 2.
		^self].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560796!
runDenotativeObjectMethodTest

	(self isTest: currentCompiledMethod selector) 
		ifTrue: [ | suite |
			suite := TestSuite named: currentCompiledMethod methodClass soleInstance name, ' ', currentCompiledMethod selector asString.
			suite addTest: (DenotativeObjectTestCase for: currentCompiledMethod).
			(DenotativeObjectProgessiveTestRunner for: suite) value ]
		ifFalse: [ self send ].
	! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561602!
waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 
	specified time has passed."

	^ self waitWhile: [aBlock value not] for: aSymbolOrNil maxMilliseconds: anIntegerOrNil! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555395!
at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(self isInBounds: index) ifTrue: [^self at: index].
	^exceptionBlock value! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563397!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
	 and: [initStmt isAssignmentNode
	 and: [initStmt variable isTemp]]) ifFalse:
		[^nil].
	body := arguments last statements.
	variable := initStmt variable.
	increment := body last toDoIncrement: variable.
	(increment == nil
	 or: [receiver statements size ~= 1]) ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])
		ifTrue: [^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: (Array with: variable).
	variable scope: -1.
	variable beBlockArg.
	^MessageNode new
		receiver: initStmt value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554256!
contextualPushDownInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushDownInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass ) value ]! !
!CompiledMethodCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559373!
test008_AnalizesTheWrappedMethodWhenCodeCoverageIsEnabled
	
	| reportBuilder |
	self createAnalyzerFor: self compiledMethodAtM1Selector.
	compiledMethodAnalyzer install.
	fakeCodeCoverageAnalyzer enable.
	reportBuilder := compiledMethodAnalyzer registerNewCoverageReportBuilder.
	
	compiledMethodAnalyzer run: #m1 with: #() in: fakeCodeCoverageAnalyzer .
	
	self
		assert: 100
		equals: reportBuilder value percentCovered.! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555020!
test42ExtractsManyRepetitionsOnSameMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder value.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 
 'm2

	^ 10' equals: (classToRefactor >> #m2) sourceCode.
	self assert: 'm1 self m2. self m2' equals: (classToRefactor >> #m1) sourceCode.
	! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555295!
findReplacementsWith: newMessage

	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: methodToExtractCodeFrom to: newMessage.
	finder value! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561423!
findSourceRangeOfCloserStatementIn: listOfAncestors ifNone: noneBlock

	^ (listOfAncestors
		detect: [ :assoc | assoc key isBlockNode ]
		ifFound: [ :assoc | listOfAncestors before: assoc ifNone: noneBlock ]
		ifNone: noneBlock) value! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559722!
format: aStream noPattern: noPattern ifFail: failBlock
	^(self parser
		parse: aStream
		class: class
		noPattern: noPattern
		context: context
		notifying: requestor
		ifFail: [^failBlock value]) preen! !
!IdentityDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561816 overrides: 50555705!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock."
 
	self associationsDo: 
		[:association | value == association value ifTrue: [^ association key]].
	^ exceptionBlock value! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560648!
chooseDefiningInstanceVariableAlphabeticallyWith: aCaption thenDo: aBlock ifNone: noneBlock

	| vars index |
	"Put up a menu of the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	vars _ self instVarNames sorted.
	vars isEmpty ifTrue: [^ noneBlock value ].

	index _ (PopUpMenu labelArray: vars lines: #()) startUpWithCaption: aCaption.
	index = 0 ifTrue: [^ self].
	aBlock value: (vars at: index)! !
!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562460!
methodChangeTypes
	"Return an old-style dictionary of method change types."

	| dict |
	dict := IdentityDictionary new.
	methodChanges associationsDo:
		[:assn | | selector record |
		selector := assn key.
		record := assn value.
		dict at: selector put: record changeType].
	^ dict! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557680!
extractMethodToMethodObject

	| classToRefactor messageName |

	messageName := model selectedMessageName.
	classToRefactor := model selectedClassOrMetaClass.

	messageName ifNotNil: [ | compiledMethod|
		compiledMethod := classToRefactor compiledMethodAt: messageName.

		(ExtractToMethodObjectApplier extract: compiledMethod) value.].! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554468!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558242!
blockWithWrittenTemporaryVariable

	[ |a| a :=1 ] value! !
!TranscriptTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560275!
assertTranscriptContentsAdded: expectedAddedString after: aBlock
	
	| transcriptContentsBeforeBlockEvaluation |
	
	transcriptContentsBeforeBlockEvaluation := Transcript contents.
	aBlock value.
	
	self assert: transcriptContentsBeforeBlockEvaluation, expectedAddedString equals: Transcript contents! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560341!
deleteAction
	"Handles deleting action, which happens when the user presses backspace or delete key within me"
	| deleteActionBlock |
	deleteActionBlock _ self valueOfProperty: #deleteAction  ifAbsent: [ nil ].
	deleteActionBlock isNil
		ifTrue: [ self flash ]
		ifFalse: [ deleteActionBlock value ].
	^self! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562071 overrides: 16823312!
do: aBlock 
	contents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563774!
findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock
	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"
	| aWindow |
	submorphs do: [ :aMorph |
		(((aWindow _ aMorph) is: #SystemWindow) and: [ qualifyingBlock value: aWindow ]) ifTrue: [
			aWindow isCollapsed ifTrue: [ aWindow expand ].
			aWindow activateAndForceLabelToShow.
			^ aWindow ]].
	"None found, so create one"
	^ makeBlock value.! !
!CompiledMethodCoverageTracker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561104!
coverAll: sourceRanges evaluating: aBlock

	"Register that the evaluation of aBlock covered sourceRanges.
	Return the result of evaluating aBlock."
	
	^ [ | result |
		result _ aBlock value.
		self coverAll: sourceRanges by: result ]
	   ifCurtailed: [ self coverAll: sourceRanges ] ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563217 overrides: 50533334!
multiplySimpleMeasure: aMeasure

	^self value multiplySimpleMeasure: aMeasure! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561182!
unusedTempNames
	| unused |
	unused := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | name |
		(assn value isUnusedTemp) ifTrue:
			[name := assn value key.
			 name ~= Encoder doItInContextName ifTrue: [unused add: name]]].
	^ unused! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560127!
checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes 
	
	| implementorsFinder |
	
	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverTypes.
	implementorsFinder value.
	
	implementorsFinder notImplementedIsEmpty ifFalse: [ 
		errors add: (TypeCheckingError on: methodReference node: aMessageNode of: methodNode notImplemented: implementorsFinder notImplemented)].
! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560387 overrides: 50557730!
assert: aBooleanOrBlock

	aBooleanOrBlock value ifFalse: [self signalFailure: 'Assertion failed']
			! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561728!
testInlineBlockCollectionEM1
	| a1 b1 i1 a2 b2 i2 we wb |
	b1 := OrderedCollection new.
	i1 := 1.
	[a1 := i1.
	 i1 <= 3] whileTrue:
		[b1 add: [a1].
		i1 := i1 + 1].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollection new.
	i2 := 1.
	we := [a2 := i2. i2 <= 3].
	wb := [b2 add: [a2]. i2 := i2 + 1].
	we whileTrue: wb. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557131 overrides: 16892239!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action value.
		self delete]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560246 overrides: 50533167!
+ anAritmethicObject

	^self value + anAritmethicObject value! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557739 overrides: 16793670!
or: aBlock1 or: aBlock2 or: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value or: [ aBlock3 value ] ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557928 overrides: 50533410!
unit
	
	^self value unit! !
!Point methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563942!
barycentricCoordinatesInTriangle: p1 with: p2 with: p3 into: aBlock ifDegenerate: degeneratBlock
	"Return  the barycentric coordinates for the receiver within the triangle defined by the three arguments."
	| p0 b0 b1 b2 b3 |
	p0 _ self.
	b0 _ ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).
	b0 isZero ifTrue: [ ^ degeneratBlock value ]. "degenerate"
	b0 _ 1.0 / b0.
	b1 _ (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.
	b2 _ (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.
	b3 _ (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.
	^aBlock value: b1 value: b2 value: b3! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555846!
whileFalse: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is false."

	^ [self value] whileFalse: [aBlock value]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559486!
test04DoesNotIncludeComments

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. "10"'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554619 overrides: 50533393!
atBaseUnit: aBaseUnit ifNone: aBlock

	^self value atBaseUnit: aBaseUnit ifNone: aBlock! !
!String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562639!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer _ String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563200 overrides: 50533422!
greaterThanSimpleMeasure: aMeasure

	^self value greaterThanSimpleMeasure: aMeasure! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557407 overrides: 50565581!
at: index ifAbsent: exceptionBlock

	| i |
	index < 1 ifTrue: [ ^exceptionBlock value ].
	i _ 0.
	self do: [ :link |
		(i _ i + 1) = index ifTrue: [ ^ link ]].
	^ exceptionBlock value! !
!CachedEvaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561538!
computeValue

	^evaluation value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563326!
removeKey: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex answer |
	keys isArray ifTrue: [
		keyIndex _ keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [
				answer _ values at: keyIndex.
				keys size = 2
					ifTrue: [
						keys _ keys at: 3-keyIndex.
						values _ values at: 3-keyIndex ]
					ifFalse: [
						keys _ (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).
						values _ (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].
				answer]].
	keys = aString ifTrue: [
		answer _ values.
		keys _ nil.
		values _ nil.
		^ answer ].
	^ aBlock value! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562089!
methodsWithAnyInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one, even historically"
	| slips |
	slips _ Set new.
	self changedClasses do: [:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					(aClass changeRecordsAt: mAssoc key) do: [ :chg | | aTimeStamp |
						aTimeStamp _ chg stamp.
						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])
							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].
	^ slips! !
!SubstringMatcher class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562573!
valueFiltering: aCollection with: aSubstring 
	
	^ (self forFiltering: aCollection with: aSubstring)
		value
		! !
!Semaphore methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557532!
critical: mutuallyExcludedBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in
	the process of running the critical: message. If the receiver is, evaluate
	mutuallyExcludedBlock after the other critical: message is finished."
	
	| caught |
	"We need to catch eventual interruptions very carefully. 
	The naive approach of just doing, e.g.,:
		self wait.
		aBlock ensure:[self signal].
	will fail if the active process gets terminated while in the wait.
	However, the equally naive:
		[self wait.
		aBlock value] ensure:[self signal].
	will fail too, since the active process may get interrupted while
	entering the ensured block and leave the semaphore signaled twice.
	To avoid both problems we make use of the fact that interrupts only
	occur on sends (or backward jumps) and use an assignment (bytecode)
	right before we go into the wait primitive (which is not a real send and
	therefore not interruptable either)."

	caught := false.
	^[
		caught := true.
		self wait.
		mutuallyExcludedBlock value
	] ensure: [ caught ifTrue: [self signal] ]
! !
!WeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563000 overrides: 16842308!
add: anAssociation
	self at: anAssociation key put: anAssociation value.
	^ anAssociation! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557141!
typesOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^(self instanceVariablesTypes typeInfoOf: anInstVarName ifAbsent: [ ^aBlock value ]) types 	
	! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557417!
resume: value through: firstUnwindCtxt
	"Unwind thisContext to self and resume with value as result of last send.
	 Execute any unwind blocks while unwinding.
	 ASSUMES self is a sender of thisContext."

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: value to: self].
	ctxt _ firstUnwindCtxt ifNil: [thisContext findNextUnwindContextUpTo: self].
	[ctxt isNil] whileFalse:
		[(ctxt tempAt: 2) ifNil:
			[ctxt tempAt: 2 put: true.
			 unwindBlock _ ctxt tempAt: 1.
			 thisContext terminateTo: ctxt.
			 unwindBlock value].
		 ctxt _ ctxt findNextUnwindContextUpTo: self].
	thisContext terminateTo: self.
	^value
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554108!
temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name :: value ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556331!
test04ProblemsDetectIfNone

	| typeCheckProblem typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker value.
	
	self assert: 1 equals: typeChecker problemsSize.
	
	typeCheckProblem := typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ self fail ].
	self assert: typeCheckProblem receiver isMessageNode.	
	self assert: #printString equals: typeCheckProblem selector key.
! !
!DecompilerConstructor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563906!
decodeLiteralVariableValueDereferenceWithReceiver: receiver selector: selector arguments: arguments
	| varNode |
	(receiver notNil "cascades"
	 and: [receiver isLiteralNode
	 and: [receiver key isVariableBinding]]) ifFalse:
		[^nil].
	varNode := self codeAnyLitInd: receiver key.
	selector = #value ifTrue:
		[^varNode].
	^selector = #value: ifTrue:
		[self codeAssignTo: varNode value: arguments first]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556908!
assignBlockTemporary: aValue
	
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	
	[ |a|
		a _ aValue.
		1 ] value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554097!
block
	
	[ 1 ] value! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562314!
inlineAssignment: assignmentToInline upTo: anIndex

	| assignmentNode assignmentNodeValue expression expressionRange |

	assignmentNode := self assignmentNodeToInline: assignmentToInline.
	assignmentNodeValue := assignmentNode value.
	expressionRange := (methodNode completeSourceRangesOf: assignmentNodeValue ifAbsent: [self shouldNotHappen])
		detect: [:range | assignmentToInline includesAllOf: range].
	expression := methodNode sourceText copyFrom: expressionRange first to: expressionRange last.

	self inlineAssignmentNode: assignmentNode withExpression: expression upTo: anIndex;
		removeAssignment: assignmentToInline.! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554639!
replaceAssignments

	| encoder rangesToReplacement nilAssignmentsFinder nullObjectNew methodNode selectorsChecked |

	nullObjectNew := (nullClass name, ' new').
	nilAssignmentsFinder := ParseNodeEnumerator ofBlock: [ :node |
		(self isAssignmentToNil: node) ifTrue: [ | ranges assignmentRange nilRange |
			ranges := encoder rangeForNode: node value ifAbsent: [self shouldNotHappen].
			assignmentRange := encoder rangeForNode: node ifAbsent: [self shouldNotHappen].
			nilRange := ranges detect: [:range | assignmentRange rangeIncludes: range first].
			rangesToReplacement add: (Association key: nilRange value: nullObjectNew)].
		
		(self isAssignmentToNonNil: node) ifTrue: [ 
			rangesToReplacement add: (self rangeToReplaceToReplacementFrom: methodNode of: node)]].
	selectorsChecked := Set new.
	replacementParameters do: [:replacementParameter | | refactoredSource  |
		(selectorsChecked includes: replacementParameter methodNode selector) ifFalse: [
			selectorsChecked add: replacementParameter methodNode selector.
			rangesToReplacement := SortedCollection sortBlock: [:intA :intB | intA key first < intB key first].
			methodNode := replacementParameter methodNode.
			encoder := methodNode encoder.
			methodNode accept: nilAssignmentsFinder.
			refactoredSource := replacementParameter methodSourceCode copyReplacing: rangesToReplacement.
			methodNode methodClass compile: refactoredSource]]! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563817!
fail

	| exitBlock |
	(encoder == nil or: [encoder == self])
		ifFalse: [encoder release. encoder := nil]. "break cycle"
	exitBlock := failBlock.
	failBlock := nil.
	^exitBlock value! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557969!
methodsWithInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one"
	| slips |
	slips _ OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
				(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
					method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
					method ifNotNil: [ | aTimeStamp |
						((aTimeStamp _ method timeStamp) notNil and: [
							(aTimeStamp beginsWith: myInits) not])
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'
	"! !
!UpdatingLabelMorph class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556199 overrides: 16895515!
initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (Preferences at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!ReturnStatementAdder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558394!
valueTo: aCompiledMethod
	
	(self new to: aCompiledMethod) value.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558724 overrides: 50533261!
addSimpleMeasure: aMeasure

	^self value addSimpleMeasure: aMeasure! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558480 overrides: 16793648!
or: alternativeBlock 
	"Nonevaluating disjunction -- answer value of alternativeBlock."

	^alternativeBlock value! !
!WeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554732!
finalizeValues: finiObjects
	"Remove all associations with key == nil and value is in finiObjects.
	This method is folded with #rehash for efficiency."
	| oldArray assoc newIndex |
	oldArray _ array.
	array _ Array new: oldArray size.
	tally _ 0.
	1 to: array size do:[:i|
		assoc _ oldArray at: i.
		assoc ifNotNil:[
			(assoc key == nil and:[finiObjects includes: assoc value]) ifFalse:[
				newIndex _ self scanForNil: assoc key.
				self atNewIndex: newIndex put: assoc].
		].
	].! !
!InlineMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562753!
messageNodeReferenceOf: anImplementor inMethod: aMethodName atIndex: aSourceCodeIndex

	| nodeToInline methodNode sourceCodeRange nodeAndRange |
	
	methodNode := (anImplementor >> aMethodName asSymbol) methodNode.
	nodeAndRange := (methodNode
		parseNodesPathAt: aSourceCodeIndex ifAbsent: [self fail]) first.
	nodeToInline := nodeAndRange key.
	(nodeToInline isKindOf: MessageNode ) ifFalse: [self failWith: 'There is no message node at the selected
		class, method and index'].
	sourceCodeRange := nodeAndRange value.
	
	^MessageNodeReference messageNode: nodeToInline selector: methodNode selector
		class: anImplementor completeSourceRange: sourceCodeRange .! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560933 overrides: 50533353!
remainderCompoundMeasure: aMeasureBag

	^self value remainderCompoundMeasure: aMeasureBag! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558544!
removeKey: aString ifAbsent: aBlock
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| answer |
	rootNode ifNil: [ ^aBlock value ].
	answer _ rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.
	rootNode isEmpty ifTrue: [
		rootNode _ nil ].
	^answer! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558076!
whileFalse
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is false."
 
	^ [self value] whileFalse: []! !
!TypeCheckingResultSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558738 overrides: 16886869!
contents: aString notifying: aRequestor 

	| result |

	result := super contents: aString notifying: aRequestor.
	methodTypeChecker := methodTypeChecker value.
	self calculateList.
	
	^result 
! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563374!
valueWithPossibleArgument: anArg and: secondArg
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg, 
	if it requires two, use anArg and secondArg.
	Squeak uses #cull:, #cull:cull:, etc. I (jmv) find that name quite obscure"

	numArgs = 0 ifTrue: [ ^self value ].
	numArgs = 1 ifTrue: [ ^self value: anArg ].
	^self value: anArg value: secondArg! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560969!
repeatWithGCIf: testBlock
	| ans |
	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"
	ans := self value.
	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].
	^ans! !
!CodeCoverageSourceCodeGenerator class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558820!
valueFor: aCompiledMethod 

	"Convenience method for generating traced source code for a compiled method"
	
	^ (self for: aCompiledMethod) value.! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560457!
newSourceOf: aMethodAndRangesToChange 
	
	| newSource ranges methodToChange |
	
	methodToChange := aMethodAndRangesToChange key.
	ranges := aMethodAndRangesToChange value.
	newSource := methodToChange sourceCode copyReplacing: ranges with: newVariable.
	
	^newSource
	! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563353!
m10
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] value. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] value. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!ContentPack methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559158!
exportInto: aDirectory

	| featureName |
	featureName _ 'Graphics-Files-Additional'.
	(FeatureRequirement name: featureName) isAlreadySatisfied
		ifFalse: [
			self error: 'Please load "', featureName, '".'].

	aDirectory assureExistence.

	self associations do: [ :assoc |
		| klass thisDirectory fullPath | 
			klass _ assoc value class.
			thisDirectory _ aDirectory / assoc key.
			fullPath _  aDirectory // assoc key.

		self flag: #note. "Add support for new file export type mappings here. --cbr"
		klass = ContentPack
			ifTrue: [ assoc value exportInto: thisDirectory ].
		
		klass = ColorForm
			ifTrue: [ assoc value writePNGfile: fullPath ].
			
		klass = Form
			ifTrue: [ assoc value writePNGfile: fullPath ]
	]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556382 overrides: 50533159!
sameUnitAs: aMeasure

	^self value sameUnitAs: aMeasure! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50553650!
methodsWithoutComments
	"Return a collection representing methods in the receiver which have no precode comments"

	| slips |
	slips _ OrderedCollection new.
	self changedClasses do:
		[:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: 
				[:mAssoc | (#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse:
					[(aClass selectors includes:  mAssoc key) ifTrue:
						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutComments) name: 'methods lacking comments'
	"! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556840!
hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma value)
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50555157!
globals
	"
	Smalltalk  globals
	"
	
	| globals |
	globals _ IdentityDictionary new.
	self associationsDo: [ :assoc |
		assoc value class isMeta not ifTrue: [ globals add: assoc ]].
	^globals! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559983!
criteriaToSortSourceRangeBetween: parseNodeWithSourceRangeOne and: parseNodeWithSourceRangeTwo

	| sourceRangeOne sourceRangeTwo |
	sourceRangeOne _ parseNodeWithSourceRangeOne value.
	sourceRangeTwo _ parseNodeWithSourceRangeTwo value.
	^ sourceRangeOne first > sourceRangeTwo first
		or: [ sourceRangeOne first = sourceRangeTwo first
			and: [ sourceRangeOne last <= sourceRangeTwo last ] ]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560789!
shouldnt: aBlock description: aString

	self deny: aBlock value description: aString
			! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559869!
implicitSelfReturnWhenSelfIsReferenced
	
	self value.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554365 overrides: 50533110!
even
	
	^self value even! !
!Number methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563078!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock value ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554687!
cascade
	
	Object
		new;
		value! !
!SourceCodeIntervalPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562260!
valueFor: anIntervalToExtract of: aMethod

	^ (self for: anIntervalToExtract of: aMethod) value! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562620!
ensure: aBlock
	"Evaluate a termination block after evaluating the receiver, regardless of
	 whether the receiver's evaluation completes.  N.B.  This method is *not*
	 implemented as a primitive.  Primitive 198 always fails.  The VM uses prim
	 198 in a context's method as the mark for an ensure:/ifCurtailed: activation."

	| complete returnValue |
	<primitive: 198>
	returnValue := self valueNoContextSwitch.
	complete ifNil:[
		complete := true.
		aBlock value.
	].
	^ returnValue! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557624!
translate: aStream noPattern: noPattern doIt: doIt ifFail: failBlock

	^self parser
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		doIt: doIt
		context: context
		notifying: requestor
		ifFail: [^failBlock value]! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557570!
assertIsValidAssigmentToExtract: anAssignmentNode 
	
	self assertIsValidToExtract: anAssignmentNode variable.
	self assertIsValidToExtract: anAssignmentNode value ! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559108!
moveToInstanceOrClassMethod

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(MoveToInstanceOrClassMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) value ].! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557254 overrides: 50562010!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectRenameApplier for: aBehavior theNonMetaClass) value ].! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557481!
whileNotNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self value == nil] whileFalse: [aBlock value]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558896 overrides: 50556231!
assert: aBoolean description: aStringOrBlock
	aBoolean ifFalse: [
		failureString _ aStringOrBlock value.
		self logFailure: failureString.
		TestResult failure sunitSignalWith: failureString]
			! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556462 overrides: 50533488!
to: stop

	^self value to: stop! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554626!
methodChanges

	| methodChangeDict |
	methodChangeDict _ Dictionary new.
	changeRecords associationsDo: [ :assn | | changeTypes |
		changeTypes _ assn value methodChangeTypes.
		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].
	^ methodChangeDict! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50553916!
m3
"
self new m3
"
	| a1 t1 t2 |
	
	t1 := 1.
	
	a1  := [  |t3| 
	t3 := 'hola'.
	t1 := 1. t1 + 1.
	t2 := 2 ].

	a1 value.
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50558561 overrides: 50533451!
convertTo: aUnit

	^self value convertTo: aUnit! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561140!
messageSendSelectorKeywordRangesOf: aSelector ifAbsent: aBlock
	
	| ranges sortedRanges |
	
	ranges := sourceRanges keys 
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ] 
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].
		
	ranges isEmpty ifTrue: [ ^aBlock value ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].
	
	^sortedRanges ! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561239!
disableClassCachedStateDuring: aBlockClosure 
	
	[
		self disableClassCache.
		^ aBlockClosure value
	] ensure: [ self initialize ]
	! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554462!
removeType: aType ifAbsent: anAbsentBlock

	^anAbsentBlock value ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556260!
flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars

	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."

	| plusIndent |

	plusIndent := indentChars.
	classHierarchy do: [:assoc |
		| class childs |
		class := assoc key.
		col add: indent , class name.
		childs := assoc value.
		self
			flattenHierarchyTree: childs
			on: col
			indent: indent , plusIndent
			by: indentChars].
	^ col! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560263!
builderForEqualOrIdenticalToClass: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key value
		on: aMessageNode receiver receiver receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50562036!
with: otherCollection do: twoArgBlock separatedBy: separatorBlock

	| beforeFirst |

	beforeFirst := true.
	self with: otherCollection do: [ :selfElement :otherCollectionElement |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		twoArgBlock value: selfElement value: otherCollectionElement ].


! !
!WeakSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560851 overrides: 50559316!
remove: oldObject ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: oldObject.
	(array at: index) == flag ifTrue: [ ^ aBlock value ].
	array at: index put: flag.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^oldObject! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50556286!
removeKey: key ifAbsent: aBlock 
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	assoc
		ifNil: [^ aBlock value].
	array at: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ assoc value! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557783!
testSample03
	| blockClosure materialized |
	blockClosure _ self bc03.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure value = materialized value.
	self assert: blockClosure value = materialized value.
	self assert: blockClosure value = materialized value.! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50554060 overrides: 50559733!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isString ifFalse: [
		^super indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ self findString: subString startingAt: start.
	index = 0 ifTrue: [ ^exceptionBlock value ].
	^index! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50559760!
tempsAndBlockArgs
	| tempNodes |
	tempNodes := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | var |
		var := assn value.
		(var isTemp
		 and: [var isMethodArg not
		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:
			[tempNodes add: var]].
	^tempNodes! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557695!
beSilentDuring: aBlock
	"Temporarily suppress information about what is going on"
	| wasSilent result |
	wasSilent _ self isSilent.
	self beSilent: true.
	result _ aBlock value.
	self beSilent: wasSilent.
	^result! !
!Editor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50560417!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50557305!
typeCheck
	
	^(ManyMethodsTypeChecker forClass: self) value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50563490!
messageSendWithBlockReceiverThatIsEvaluated

	[ Object new ]
		value! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:01' prior: 50561551!
testValue

	"Example from http://en.wikipedia.org/wiki/Topological_sorting"

	| graph result |

	graph :=
		Graph edges: (
			OrderedCollection new
				add: (Edge from: 7 to: 11);
				add: (Edge from: 7 to: 8);
				add: (Edge from: 11 to: 2);
				add: (Edge from: 11 to: 9);
				add: (Edge from: 11 to: 10);
				add: (Edge from: 5 to: 11);
				add: (Edge from: 3 to: 8);
				add: (Edge from: 3 to: 10);
				add: (Edge from: 8 to: 9);
				yourself).

	result := (TopologicalSort for: graph) value asOrderedCollection.

	self assert: 8 equals: result size.
	self assert: (result includesAllOf: #(3 5 7 11 8 2 9 10))! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561117!
m04_two_temps_one_temp_in_remote_vector

	| t1 t2 |
	
	t1 := 1.
	[ t2 := t1 +  1.0 ] value.
	
	^t2! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562306!
at: localFileName ifAbsent: block

	^ [self at: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block value]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555662!
whileTrue
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is true."
 
	^ [self value] whileTrue: []! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554918 overrides: 50533475!
equalsCompoundMeasure: aMeasureBag

	^self value = aMeasureBag! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559274!
debugAsFailureIfCanNot: handler
	
	self ifCanNotDebugDo: [ ^handler value].
	
	(self class selector: testSelector) runCaseAsFailure! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561673!
testSample10
	| blockClosure1 blockClosure2 blockClosure3 value materialized1 materialized2a materialized2b materialized3a materialized3b materialized3c |

	blockClosure1 _ self bc10.
	blockClosure2 _ blockClosure1 withFirstArg: 1.
	blockClosure3 _ (blockClosure1 withFirstArg: 1) withFirstArg: 2.
	value _ blockClosure1 value: 1 value: 2.
	self assert: (blockClosure2 value: 2) = value.
	self assert: blockClosure3 value = value.

	materialized1 _ blockClosure1 veryDeepCopy.
	materialized2a _ materialized1 withFirstArg: 1.
	materialized2b _ blockClosure2 veryDeepCopy.
	materialized3a _ (materialized1 withFirstArg: 1) withFirstArg: 2.
	materialized3b _ materialized2b withFirstArg: 2.
	materialized3c _ blockClosure3 veryDeepCopy.
	self assert: (materialized1 value: 1 value: 2) = value.
	self assert: (materialized2a value: 2) = value.
	self assert: (materialized2b value: 2) = value.
	self assert: materialized3a value = value.
	self assert: materialized3b value = value.
	self assert: materialized3c value = value.
! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557899!
ultimateSourceCodeAt: selector ifAbsent: aBlock
	"Return the source code at selector, deferring to superclass if necessary"

	^ self
		sourceCodeAt: selector
		ifAbsent: [
			superclass
				ifNil: [aBlock value]
				ifNotNil: [superclass ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555305!
assignmentToRemoteTemporary
	
	| localTemp remoteTemp |
	
	localTemp := 1.
	
	[ remoteTemp := localTemp printString ] value.
	
	^remoteTemp ! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559848!
typesOfVariableNamed: aVarName ifAbsent: aBlockClosure 
	
	"I have not been compiled yet, so there is no info about parameters or temps - Hernan"
	^aBlockClosure value! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559057!
correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection _ requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first - delta to: interval last - delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector _ UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction value].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~= $:
	   and: [correctSelector last = $:])
		ifTrue: [abortAction value]
		ifFalse: [correctSelector]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559903!
convertToDoLoop
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]"
	| leaveOnStack initStmt toDoStmt limitStmt |
	leaveOnStack := false.
	(stack notEmpty
	 and: [(stack last == #CaseFlag) not and: [ stack last isAssignmentNode]])
		ifTrue:
			[initStmt := stack last.
			 (toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			 stack removeLast.
			 statements removeLast; addLast: toDoStmt.
			 leaveOnStack := true]
		ifFalse:
			[statements size < 2 ifTrue:
				[^self].
			initStmt := statements at: statements size-1.
			(toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			statements removeLast; removeLast; addLast: toDoStmt].
	initStmt variable scope: -1.  "Flag arg as block temp"

	"Attempt further conversion of the pattern
		limitVar := limitExpr.
		startExpr to: limitVar by: incConst do: [:var | ...statements...]
	to
		startExpr to: limitExpr by: incConst do: [:var | ...statements...].
	The complication here is that limitVar := limitExpr's value may be used, in which case it'll
	be statements last, or may not be used, in which case it'll be statements nextToLast."
	statements size < 2 ifTrue:
		[leaveOnStack ifTrue:
			[stack addLast: statements removeLast].
			 ^self].
	limitStmt := statements last.
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable isTemp
		and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
			[limitStmt := statements at: statements size-1.
			((limitStmt isMemberOf: AssignmentNode)
				and: [limitStmt variable isTemp
				and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
					[leaveOnStack ifTrue:
						[stack addLast: statements removeLast].
					^self]].

	(self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset) ifFalse:
		[^self].
	toDoStmt arguments at: 1 put: limitStmt value.
	limitStmt variable scope: -2.  "Flag limit var so it won't print"
	statements last == limitStmt
		ifTrue: [statements removeLast]
		ifFalse: [statements removeLast; removeLast; addLast: toDoStmt]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560522!
runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!InlineTemporaryVariable class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554583!
findTemporaryNamed: temporaryName atUsage: usageInterval inMethodNode: aMethodNode

	| oldVariableNodeAndUsageInterval parseNodesPath |

	parseNodesPath := aMethodNode parseNodesPathAt: usageInterval first ifAbsent: [self signalSelectedIntervalIsNotATemporary].
	oldVariableNodeAndUsageInterval := parseNodesPath
		detect: [:anAssociation |
			| parseNode |
			parseNode := anAssociation key.
			(parseNode isTemp and: [parseNode isNamed: temporaryName])]
		ifNone:[self signalSelectedIntervalIsNotATemporary].

	^{oldVariableNodeAndUsageInterval key. oldVariableNodeAndUsageInterval value}.
! !
!Preference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563967 overrides: 50553066!
transactionAmount
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557805!
getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(Preferences at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock value].
	^ response asString! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562581 overrides: 50533443!
composeWithSimpleMeasure: aMeasure

	^self value composeWithSimpleMeasure: aMeasure! !
!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555010!
informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock value].
	Utilities informUserDuring:[:barBlock|
		progress _ barBlock.
		aBlock value].
	progress _ nil.! !
!NewSelectorPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562235!
valueFor: aSelectorToValidate on: aClass

	^ (self for: aSelectorToValidate on: aClass) value! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557184!
on: aRectangle ifCovered: partiallyOrTotallyCoveredBlock uncoveredPartsDo: uncoveredPartBlock else: notCoveredAtAllBlock
	"Find rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included.
	
	If aRectangle is not covered at all, or for whatever reason we don't know, evaluate notCoveredAtAllBlock.
	Othewise evaluate partiallyOrTotallyCoveredBlock once, and also evaluate uncoveredPartBlock for each part in aRectangle we don't cover."

	^ notCoveredAtAllBlock value! !
!InlineMethodMessageSendsSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554831!
addMessageNodeReference: aMessageNodeReference ifIncluded: anIncludedBlock

	(messageList includes: aMessageNodeReference)
		ifTrue: [anIncludedBlock value]
		ifFalse: [messageList add: aMessageNodeReference]! !
!NewGlobalPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560306!
valueFor: aNewName in: aSystem  

	^(self for: aNewName in: aSystem) value! !
!EffectiveTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558401!
addToAfterMessageTypeCasts: aTypeCastBlockBuilder ifReturns: anArgumentBlock
	
	anArgumentBlock isBlockNode 
		ifTrue: [ anArgumentBlock returns 
			ifTrue: [ afterMessageTypeCasts add: aTypeCastBlockBuilder value ]].
! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562268 overrides: 16892202!
keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	"Return - check for special action
	Note: Code below assumes that this was some
	input field reacting on Return."
	aKeyboardEvent isReturnKey ifTrue: [
		crAction ifNotNil: [
			"Break the keyboard focus so that the receiver can be safely deleted."
			"Is this needed at all? (jmv)"
			"aKeyboardEvent hand newKeyboardFocus: nil."
			^crAction value ]].

	self pauseBlinking.
	self handleInteraction: [ self editor processKeystrokeEvent: aKeyboardEvent ].
	self updateFromContents.
	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562654 overrides: 50563893!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	^(array at: (self scanFor: key)) 
		ifNil: [ aBlock value ]
		ifNotNil: [ :value | key -> value ]! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563550!
fileOutMethodChangesFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes _ Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		(mAssoc value == #remove
			or: [ mAssoc value == #addedThenRemoved
				or: [ mAssoc value == #add
					or: [ mAssoc value == #movedToOtherPackage ]]])
			ifFalse: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558119 overrides: 50556026!
indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563037!
findOutermostStatementContaining: aMessageNodeReference enclosedBy: enclosingBlock ifFound: ifFoundBlock ifNone: ifNoneBlock

	| usageNodesPath isDifferentMessageNode isIncludedInBlock |

	usageNodesPath := aMessageNodeReference methodNode parseNodesPathAt: aMessageNodeReference completeSourceRange first
		ifAbsent: [self shouldNotHappen].
	isDifferentMessageNode := [:aNode | aNode isMessageNode and: [(aNode equivalentTo: aMessageNodeReference messageNode) not]].
	isIncludedInBlock := [:aRange | |sourceRangeOfEnclosingBlock |
		sourceRangeOfEnclosingBlock := enclosingBlock isBlockNode
			ifTrue: [self findSourceRangeOf: enclosingBlock in: aMessageNodeReference compiledMethod.]
			ifFalse: [(1 to: aMessageNodeReference compiledMethod sourceCode size)].
		sourceRangeOfEnclosingBlock includesAllOf: aRange.
	].
	usageNodesPath reversed
		detect: [:aNodeAndRange | | node range |
			node := aNodeAndRange key.
			range := aNodeAndRange value.
			((node isAssignmentNode or: [isDifferentMessageNode value: node]) and: [isIncludedInBlock value: range])
		]
		ifFound: [:aNodeAndRange | ^ifFoundBlock value: aNodeAndRange]
		ifNone: [^ifNoneBlock value].




	! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559391 overrides: 16935879!
= aDictionary
	"Two dictionaries are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same set of keys.
	 (c) for each (common) key, they have the same value".

	self == aDictionary ifTrue: [^ true].	"Any object is equal to itself"
	(aDictionary is: #Dictionary) ifFalse: [^false].
	self size = aDictionary size ifFalse: [^false].
	self associationsDo: [:assoc|
		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value
			ifFalse: [^false]].
	^true

! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561902 overrides: 50533187!
^ aPower

	^self value ^ aPower! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562506!
findPigProcess
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process |
	promise _ Processor tallyCPUUsageFor: 0.1 every: 10.
	tally _ promise value.
	tally ifEmpty: [ ^Processor preemptedProcess ]. "We can not do better"
	process _ tally sortedCounts first value.
	"Avoid, if possible, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		(process == Processor backgroundProcess or: [ (process name beginsWith: '[system]') or: [process isTerminated]])
			ifTrue: [ process _ entry value ]].
	^process! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563588!
analyseClosure: rootNode "<MethodNode>"
	"Analyse whether the temporary needs to be made remote
	 or not, and answer whether it was made remote.
	 A temp cannot be local if it is written to remotely,
	 or if it is written to after it is closed-over.  An exception
	 is an inlined block argument that appears to be written
	 remotely but is actually local to a block."
	| latestWrite |
	self isBlockArg ifTrue: [^false].
	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"
	latestWrite := 0.
	((writingScopes notNil
	 and: [writingScopes associations anySatisfy: [:assoc|
			[:blockScope :refs|
			refs do: [:write| latestWrite := write max: latestWrite].
			"A temp cannot be local if it is written to remotely."
			blockScope actualScope ~~ definingScope actualScope]
				value: assoc key value: assoc value]])
	or: [readingScopes notNil
		and: [readingScopes associations anySatisfy: [:assoc|
				[:blockScope :refs|
				 "A temp cannot be local if it is written to after it is closed-over."
				 blockScope actualScope ~~ definingScope actualScope
				 and: [refs anySatisfy: [:read| read < latestWrite]]]
					value: assoc key value: assoc value]]]) ifTrue:
		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.
		 ^true].
	^false! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563513 overrides: 16838459!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes := aClass soleInstance withParents collect: [ :denotativeObject | denotativeObject class ].
	classes size = 1 ifTrue: [ ^aClass ].
	
	chosenClassIndex := PopUpMenu
		withCaption: 'Define #', aSelector, ' in which object?'
		chooseFrom: (classes collect: [:c | c soleInstance name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex

	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555140 overrides: 50533428!
lessThanSimpleMeasure: aMeasure

	^self value lessThanSimpleMeasure: aMeasure! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561174 overrides: 16793546!
and: alternativeBlock 
	"Nonevaluating conjunction -- answer the value of alternativeBlock since
	the receiver is true."

	^alternativeBlock value! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554295 overrides: 16793658!
or: aBlock1 or: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value ]
! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555407!
testSample11
	| blockClosures materialized |

	blockClosures _ self bc11.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self deny: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self deny: blockClosures first value = materialized first value.

	blockClosures _ self bc11.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures first value = materialized first value.! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555764 overrides: 16823478!
select: aBlock 
	"Refer to the comment in Collection|select:."

	| newCollection |
	newCollection _ self species new.
	contents associationsDo: [:each |
		(aBlock value: each key)
			ifTrue: [newCollection add: each key withOccurrences: each value]].
	^ newCollection! !
!SystemWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560863 overrides: 50567332!
on: aRectangle ifCovered: partiallyOrTotallyCoveredBlock uncoveredPartsDo: uncoveredPartBlock else: notCoveredAtAllBlock
	"Find rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included.
	
	If aRectangle is not covered at all, or for whatever reason we don't know, evaluate notCoveredAtAllBlock.
	Othewise evaluate partiallyOrTotallyCoveredBlock once, and also evaluate uncoveredPartBlock for each part in aRectangle we don't cover."

	 | bounds r e r2 |
	self isOrAnyOwnerIsRotated ifTrue: [
		^ notCoveredAtAllBlock value ].

	color mightBeTranslucent ifTrue: [
		^ notCoveredAtAllBlock value ].

	"Due to possible anti aliasing, and possible conversion to integer, we can't be really sure
	about the 2 outer pixels at each edge."
	bounds _ self displayBounds insetBy: 2.
	bounds ifNil: [
		^ notCoveredAtAllBlock value ].

	(aRectangle intersects: bounds) ifFalse: [
		^ notCoveredAtAllBlock value ].

	"Solid rectangle.
	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"
	partiallyOrTotallyCoveredBlock value.
	aRectangle areasOutside: bounds do: [ :rect | uncoveredPartBlock value: rect ].

	Theme current roundWindowCorners ifTrue: [
		r _ Theme current roundedWindowRadius * 1.1.										"A bit more than actual radius because we use Bezier, not arc."
		e _ self externalizeDistanceToWorld: r@r.
		r2 _ aRectangle intersect: (bounds topLeft extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds topRight - (e x@0) extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds bottomLeft - (0@ e y)extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		r2 _ aRectangle intersect: (bounds bottomRight - e extent: e).
		r2 hasPositiveExtent ifTrue: [ uncoveredPartBlock value: r2 ].
		].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560668!
blockWithTemporaryVariables
	
	[ | a b |
		a := 1.
		b := 2 ] value! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556436!
removeAllUnreferencedInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveAllUnreferencedInstanceVariablesApplier on: model for: aClass) value ].! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50553901!
after: target ifNone: exceptionBlock
	"Answer the element after target.  Answer the result of evaluating
	the exceptionBlock if there are no elements after it."

	| index |
	index _ self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = self size 
			ifTrue: [exceptionBlock value]
			ifFalse: [self at: index + 1]]! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563632!
testIsTrivialClosure
	"
	ClosureTests new testIsTrivialClosure
	"
	| tempVar |
	tempVar _ 1.
	self assert: [ 3 + 4 ] isCleanClosure.
	self assert: [ :a | a * 2 ] isCleanClosure.
	self assert: [ Smalltalk size ] isCleanClosure.
	self assert: [ ClosureTests selectors size ] isCleanClosure.
	self assert: [ :blockArg | blockArg printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp _ 7 ] isCleanClosure.
	self assert: [ | c | c _ [ :a :b | a+b ]. c value: 3 value: 4 ] isCleanClosure.

	self assert: [ | outerBlockTemp | [ outerBlockTemp printString ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [ outerBlockTemp _ 7 ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp _ 7 ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp _ 7 ]] ] isCleanClosure.

	self deny: [ | outerBlockTemp | [ outerBlockTemp printString ] isCleanClosure ] value.
	self deny: [ | outerBlockTemp | [ outerBlockTemp _ 7 ] isCleanClosure ] value.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp printString ]] isCleanClosure ] value.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp _ 7 ]] isCleanClosure ] value.

	self deny: [ tempVar + 1 ] isCleanClosure.
	self deny: [ tempVar _ 1 ] isCleanClosure.
	self deny: [ ivar + 1 ] isCleanClosure.
	self deny: [ ivar _ 1 ] isCleanClosure.
	self deny: [ ^ true ] isCleanClosure.
	self deny: [ self printString ] isCleanClosure.
	self deny: [ ^ self ] isCleanClosure.
	self deny: [ ClassVar + 1 ] isCleanClosure.
	self deny: [ ClassVar _ 1 ] isCleanClosure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557527 overrides: 50533404!
measures

	^self value measures! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555649!
valueOfProperty: aSymbol ifAbsentPut: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock to obtain the value to be
	stored and answered."

	^ self valueOfProperty: aSymbol ifAbsent: [
		self setProperty: aSymbol toValue: aBlock value ]! !
!ArithmeticObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559230!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock value ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561216!
keysAndValuesRemove: keyValueBlock
	"Removes all entries for which keyValueBlock returns true."
	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."

	| removals |
	removals _ OrderedCollection new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc value)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563923!
allActualLocalImplementorsOf: sentSelector forAll: types

	^(AllActualLocalImplementors of: sentSelector forAll: types) value
				
				
! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562294 overrides: 16793582!
and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value and: [ aBlock3 value and: [ aBlock4 value ]]] ! !
!Number methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563793!
to: stop do: elementBlock separatedBy: separatorBlock
	"
	String streamContents: [ :strm |
		1 to: 10 do: [ :i | i printOn: strm ] separatedBy: [ strm nextPutAll: ' -- ' ]]
	"
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self to: stop do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555869!
cumulativeCounts
	"Answer with a collection of cumulative percents covered by elements so far."
	| s n |
	s _ self size / 100.0.
	n _ 0.
	^ self sortedCounts asArray collect: [ :a |
		n _ n + a key.
		(n / s roundTo: 0.1) -> a value]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558987 overrides: 50533197!
floor
	
	^self value floor
	! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561124!
repeat
	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."

	[self value. true] whileTrue! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558186!
testSample07
	| blockClosures materialized |

	blockClosures _ self bc07.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self deny: blockClosures third value = materialized third value.
	self assert: blockClosures second value = materialized second value.
	self deny: blockClosures first value = materialized first value.
	self deny: blockClosures third value = materialized third value.
	self deny: blockClosures first value = materialized first value.

	blockClosures _ self bc07.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures third value = materialized third value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures third value = materialized third value.
	self assert: blockClosures first value = materialized first value.! !
!ProgressiveCodeCoverageTestRunner class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558829!
run: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer 
	
	(self for: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer)
		value! !
!Set methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559316 overrides: 16823722!
remove: oldObject ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: oldObject.
	(array at: index) ifNil: [ ^ aBlock value ].
	array at: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ oldObject! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555072!
findDeepSubmorphThat: block1 ifAbsent: block2 
	self
		allMorphsDo: [:m | (block1 value: m)
				== true ifTrue: [^ m]].
	^ block2 value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563841!
notExecutedMessageArgument
	
	Array
		with: [ self value ]
		with: [ self printString ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559243 overrides: 50533123!
isCompoundMeasure

	^self value isCompoundMeasure! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557311!
valueWithPossibleArgs: anArray
	"Generally, prefer #valueWithPossibleArgument: and #valueWithPossibleArgument:and:
	for performance."
	^ numArgs = 0
		ifTrue: [ self value ]
		ifFalse: [
			self valueWithArguments:
				(numArgs = anArray size
					ifTrue: [ anArray ]
					ifFalse: [
						numArgs > anArray size
							ifTrue: [ anArray , (Array new: numArgs - anArray size) ]
							ifFalse: [
								anArray
									copyFrom: 1
									to: numArgs ]]) ].! !
!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561258 overrides: 50558519!
visitAssignmentNode: anAssignmentNode
	anAssignmentNode value accept: self.
	anAssignmentNode variable isTemp
		ifTrue:
			[written ifNil: [written := IdentitySet new].
			 written add: anAssignmentNode variable]
		ifFalse:
			[anAssignmentNode variable accept: self]! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555916!
processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	acceptOn = #any ifTrue: [self acceptContents].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556220 overrides: 16901788!
hash

	^self value hash! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559186!
declaredTemporariesFor: aParseNode ofSender: aSender

	^temporariesDeclarationsByNode keys
		detect: [:senderAndNode | senderAndNode key = aSender and: [senderAndNode value equivalentTo: aParseNode]]
		ifFound: [ :key | temporariesDeclarationsByNode at: key]
		ifNone: [| temporariesAndArgsDict |

			temporariesAndArgsDict := self temporariesAndArgsInScopeOf: aParseNode ofSender: aSender.
			temporariesDeclarationsByNode at: (aSender -> aParseNode) put: temporariesAndArgsDict.
			temporariesAndArgsDict].


	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556095!
withMessageSendKeywordPositionsOf: aSelector do: aMessageSendNodeBlock ifAbsent: aBlock

	| positions sortedPositions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: aMessageSendNodeBlock.

	positions isEmpty ifTrue: [ ^aBlock value ].
	sortedPositions := positions asSortedCollection.

	^sortedPositions ! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560631!
immutableValue
	"It is necessary to turn it absolute so that it is immutable."

	^self value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560367 overrides: 50533203!
roundTo: aNumber
	
	^self value roundTo: aNumber
! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558873 overrides: 50555705!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value = (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock value! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562487!
valueOfProperty: aSymbol ifAbsent: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock and answer the result of
	this block evaluation"
	^ properties
		ifNil: [ aBlock value ]
		ifNotNil: [ properties at: aSymbol ifAbsent: aBlock ]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557706!
renameInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RenameInstanceVariableApplier on: model at: aClass) value ].! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560940!
addType: aType ifFull: aFullBlock

	^aFullBlock value.! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556479!
isAssignmentToNonNil: aNode

	^(aNode isAssignmentNode and: [aNode variable name =  instVar]) and: [aNode value isNilPseudoVariable not].! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561792!
penultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 2 ifTrue: [ ^self at: size-1 ].
	^aBlock value! !
!ParseNodeVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558519!
visitAssignmentNode: anAssignmentNode
	"N.B.  since assigment happens after the value is evaluated the value is visited first."
	anAssignmentNode value accept: self.
	anAssignmentNode variable accept: self! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563693!
declareTemporaries: temporariesToDeclare inBlockOf: aMessageNodeReference

	| methodOrBlockNodeDeclaringNewVariables renamedTemporaries replacements |

	methodOrBlockNodeDeclaringNewVariables := self enclosingBlockOf: aMessageNodeReference.
	renamedTemporaries := self declareTemporaries: temporariesToDeclare in: methodOrBlockNodeDeclaringNewVariables of: aMessageNodeReference compiledMethod.

	replacements := self replacementsMapForMessageSend: aMessageNodeReference .
	renamedTemporaries do: [:oldVariableAndNewName |
			(self findRangesOf: oldVariableAndNewName key in: implementorCompleteSourceRanges) do: [:range |
				replacements at: range put: oldVariableAndNewName value.
			]
	]
	! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558412!
computeEndOfNodeEnclosingAssignment

	endOfNodeEnclosingAssignment := (methodNode parseNodesPathAt: assignmentToInlineRange first
		ifAbsent: [self shouldNotHappen])
			detect: [:nodeAndRange | nodeAndRange key isBlockNode]
			ifFound: [:nodeAndRangeOfAssignment | nodeAndRangeOfAssignment value last ]
			ifNone: [methodNode sourceText size].




! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560574!
fileOutMethods: aCollection on: aStream
	"FileOut all methods with selectors taken from aCollection"
	| categories |
	categories := Dictionary new.
	aCollection do:[:sel|
		| cat |
		cat := self organization categoryOfElement: sel.
		cat = self class removedCategoryName ifFalse:[
			(categories includesKey: cat) 
				ifFalse:[ categories at: cat put: Set new ].
			(categories at: cat) add: sel].
	].
	categories associationsDo:[:assoc|
		assoc value do: [ :sel |
			aStream newLine.
			(self sourceCode at: sel) fileOutOn: aStream.
		].
	].! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562058 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level

	key isVariableBinding
		ifTrue:
			[key key isNil
				ifTrue:
					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]
				ifFalse:
					[aStream nextPutAll: '##'; nextPutAll: key key]]
		ifFalse:
			[key storeOn: aStream]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560321!
contextualPushUpInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushUpInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass) value ]! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560565!
findSourceRangesOfNode: aParseNode using: completeSourceRanges

	^(completeSourceRanges associations detect: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode]) value! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554985!
selectSelectorsThatSatisfy: aSelectorsSelectionCondition while: aClosure
	
	| currentSelectorsSelectionCondition |
	
	currentSelectorsSelectionCondition := selectorSelectionCondition.
	[ selectorSelectionCondition := aSelectorsSelectionCondition.
	aClosure value ] ensure: [ selectorSelectionCondition := currentSelectorsSelectionCondition ].! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554751!
parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		"Protect against possible parsing failure"
		doIt ifTrue: [
			(sourceCode beginsWith: Scanner doItInSelector)
				ifTrue: [encoder selector: Scanner doItInSelector]
				ifFalse: [
					(sourceCode beginsWith: Scanner doItSelector)
						ifTrue: [encoder selector: Scanner doItSelector]]].
		self init: myStream notifying: aRequestor failBlock: [^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ requestor text string asPlainString readStream ].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555705!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast."
 
	self associationsDo: 
		[:association | value = association value ifTrue: [^association key]].
	^exceptionBlock value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559835!
renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier for: aClassToRefactor) value! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555683 overrides: 16935701!
do: aBlock 
	super do: [:assoc | aBlock value: assoc value]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556872!
positionsForLiteralNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litSet at: aName ifAbsent: [ ^aBlock value ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559671!
singleCompleteSourceRangeOf: requestedParseNode ifPresent: sourceRangePresentBlock ifAbsent: sourceRangeAbsentBlock
	"Finds the source range associated with the requested parse node.
	If it is present, evaluates sourceRangePresentBlock with the result.
	Otherwise, it evaluates sourceRangeAbsentBlock.
	Raises an error if the requested parse node has multiple source ranges"
	| sourceRanges |

	sourceRanges := self
		completeSourceRangesOf: requestedParseNode
		ifAbsent: [^sourceRangeAbsentBlock value].

	^sourceRanges size > 1
		ifTrue: [self error: 'there are multiple source ranges for the parse node: ' , requestedParseNode printString ]
		ifFalse: [sourceRangePresentBlock value: sourceRanges anyOne].! !
!ExtractMethodParametersDetector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562565!
valueFor: aMethodNodeToRefactor at: anIntervalToExtract

	^ (self for: aMethodNodeToRefactor at: anIntervalToExtract) value! !
!Array methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556730!
removeType: aType ifAbsent: anAbsentBlock

	| typeIndex |
	
	typeIndex := self indexOf: aType ifAbsent: [ ^anAbsentBlock value ].
	
	self replaceFrom: typeIndex to: self size - 1 with: self startingAt: typeIndex + 1.
	self at: self size put: nil! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561347!
testSample06
	| blockClosures materialized firstRun |

	blockClosures _ self bc06.
	firstRun _ blockClosures second value.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures third value = materialized third value.
	self assert: blockClosures first value = materialized first value.
	self assert: firstRun = materialized second value.
	self deny: blockClosures second value = materialized second value.

	blockClosures _ self bc06.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first value = materialized first value.
	self assert: blockClosures second value = materialized second value.
	self assert: blockClosures third value = materialized third value.
	self assert: blockClosures first value = materialized first value.
	self deny: firstRun = materialized second value.
	self assert: blockClosures second value = materialized second value.! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561659!
valueOfProperty: aSymbol ifPresentDo: aBlock ifAbsent: absentBlock
	"If the receiver has a property of the given name, evaluate
	aBlock on behalf of the value of that property, if not evaluate absentBlock"

	| value |
	
	value := self valueOfProperty: aSymbol ifAbsent: [^ absentBlock value ].
	
	^aBlock value: value! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555939!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the size of the composition"

	"Also couple the editor to Morphic keyboard events"

	| oldEditor oldContents |
	oldEditor _ editor.
	oldContents _ contents.
	interactionBlock value.
	oldContents == contents
		ifTrue: [ "this will not work if the composition changed"
			editor _ oldEditor	"since it may have been changed while in block"].
	self redrawNeeded! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562027 overrides: 50559003!
removeInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRemoveCollaboratorApplier on: model for: aClass) value ].! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560516!
m1_read_temp

	| t1 |
	
	t1 := 1.
	[t1 + 1 ] value.
	
	^t1! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557958!
performWithFormulas

	self assert: (formulaOfTenPesos perform: messageName with: formulaOfTwentyPesos) value = 
		(formulaOfTenPesos value perform: messageName with: formulaOfTwentyPesos value)! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560080!
m1_write_temp_outside_block

	| t1 |
	
	t1 := 1.
	[ t1 + 1 ] value.
	
	t1 := 2.
	
	^t1! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556011 overrides: 50533390!
amount
	
	^self value amount! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559823 overrides: 50533230!
max: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self value < aMagnitude ifTrue: [^aMagnitude].
	^self! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556988 overrides: 16793631!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer with the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock value! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557236!
validateObjectCreation: defTokens 

	| denotativeObjectName nameIndex |
	
	nameIndex := defTokens findFirst: [ :token | token beginsWith: '#' ].
	nameIndex = 0 ifTrue: [ self error: self objectNameMustBeSymbolErrorDescription ].
	
	denotativeObjectName := (defTokens at: nameIndex) copyWithoutAll: '#()'.
	(NewDenotativeObjectPrecondition for: denotativeObjectName asSymbol in: Smalltalk undeclared: Undeclared) value.
! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554864 overrides: 50365963!
nextPut: anObject 
	"Ensure that the limit is not exceeded"

	^position >= limit
		ifTrue: [limitBlock value]
		ifFalse: [super nextPut: anObject]! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559564!
testAverageIfEmptyEvaluatesEmptyBlockWhenTheCollectionIsEmpty

	| emptyBlock |
	
	emptyBlock _ [ 0 ].

	self 
		assert: (#() average: [ :each | each asInteger ] ifEmpty: emptyBlock)
		equals: emptyBlock value! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563893!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	| index assoc |
	index _ self findElementOrNil: key.
	assoc _ array at: index.
	nil == assoc ifTrue: [ ^ aBlock value ].
	^ assoc! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554428!
defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preferences name: #standardListFont category: #font value: font.
	Preferences name: #standardMenuFont category: #font value: font.
	Preferences name: #standardCodeFont category: #font value: font.
	Preferences name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preferences name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557881!
removeKey: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma key]
				ifFalse: [propertyOrPragma keyword])
			== aKey ifTrue:
			[^method removeProperty: aKey]].
	^aBlock value! !
!Integer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556923!
timesRepeat: aBlock 
	"Evaluate the argument, aBlock, the number of times represented by
	the receiver."

	| count |
	count _ 1.
	[count <= self]
		whileTrue: 
			[aBlock value.
			count _ count + 1]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554563!
should: aBlock description: aString

	self assert: aBlock value description: aString
			! !
!MorphicAlarm methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558588!
valueAtTime: millisecondClock

	|  nArgs |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondClock]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondClock) ]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558700 overrides: 50497559!
problemsDetect: aCondition ifNone: noneBlock
	
	| problem |
	
	typeCheckers do: [ :typeChecker |
		problem := typeChecker problemsDetect: aCondition ifNone: [ nil ].
		problem ifNotNil: [ ^problem ]].
	
	^noneBlock value! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556231!
assert: aBlock description: aStringOrBlock
    "Throw an assertion error if aBlock does not evaluates to true."

    aBlock value 
        ifFalse: [ AssertionFailure signal: aStringOrBlock value ]! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554239!
error
	self 
		rangeType: #excessCode
		start: (ranges isEmpty ifTrue: [1] ifFalse: [ranges last end + 1])
		end: source size.
	errorBlock value! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563310!
dumpTally: tally on: aStream
	"tally is from ProcessorScheduler>>tallyCPUUsageFor:
	Dumps lines with percentage of time, hash of process, and a friendly name"

	tally sortedCounts do: [ :assoc |
		((assoc key / tally size) * 100.0) rounded printOn: aStream.
		aStream
			nextPutAll: '%   ';
			print: assoc value identityHash; space;
			nextPutAll: assoc value name;
			newLine.
	]! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555537!
test14ErrorsCollectsAllTypeCheckersErrors

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker value.
	
	self assert: typeChecker errors notEmpty ! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562500!
delegateToParent
	
	^ (Delegator from: thisContext sender) value! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562355!
caseOf: aBlockAssociationCollection otherwise: aBlock
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, answer the result
	 of evaluating aBlock."

	aBlockAssociationCollection associationsDo:
		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].
	^ aBlock value

"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"The following are compiled in-line:"
"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"
"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559512!
clippingByCurrentMorphDo: aBlock
	"Do clipping only if currentMorph says so"

	| prevClipRect prevClippingMorphRect |

	currentMorph clipsSubmorphsReally ifFalse: [ ^aBlock value ].

	prevClipRect _ self clipRect.
	prevClippingMorphRect _ clippingMorphDisplayBounds.
	clippingMorphDisplayBounds _ self boundingRectOfCurrentMorphAfterDraw insetBy: 1.
	self setClipRect: (prevClipRect
		ifNil: [clippingMorphDisplayBounds]
		ifNotNil: [prevClipRect intersect: clippingMorphDisplayBounds]).
	self clipCurrentMorph: true.
	aBlock ensure: [
		self clipCurrentMorph: false.
		self setClipRect: prevClipRect.
		clippingMorphDisplayBounds _ prevClippingMorphRect ]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561830!
literalScannedAs: scannedLiteral notifying: requestor
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	(scannedLiteral isVariableBinding)
		ifFalse: [^ scannedLiteral].
	key _ scannedLiteral key.
	value _ scannedLiteral value.
	key ifNil: [
		(self bindingOf: value) ifNotNil: [ :assoc |
				 (assoc value isKindOf: Behavior)
					ifTrue: [^ nil->assoc value class]].
		requestor notify: 'No such metaclass'.
		^false].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil:[ :assoc | ^assoc].
			Undeclared at: key put: nil.
			 ^Undeclared bindingOf: key].
	requestor notify: '## must be followed by a non-local variable name'.
	^false

"	Form literalScannedAs: 14 notifying: nil 14
	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm
	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form
	Form literalScannedAs: ##Form notifying: nil   Form->Form
	Form literalScannedAs: ###Form notifying: nil   nilE->Form class
"! !
!Editor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559604!
wordSelectAndEmptyCheck: returnBlock
	"Ensure selecting the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectWord.  "Select exactly a whole word"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563025!
should: aBlock

	self assert: aBlock value
			! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561132 overrides: 50533218!
> aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^aMagnitude < self value! !
!DropFilesAction methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562202!
fileNamedDropped: aFileName 

	| options selectionIndex menu |
	
	selectedFileEntry := aFileName asFileEntry.
	options := FileList itemsForFileEntry: selectedFileEntry.
	options isEmpty ifTrue: [ ^self inform: 'No action found for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock value
	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559410!
afterCompiling: aSourceCode do: aBlock for: aReceiver in: anEvaluationContext ifFail: aFailBlock
	
	| methodNode method sourceCode compiler |

	sourceCode := self doItSourceCodeFor: aSourceCode in: anEvaluationContext.
	
	methodNode _ [
		compiler _ Compiler new.
		compiler		
			compileDoIt: sourceCode
			in: aReceiver class
			context: anEvaluationContext
			notifying: self
			ifFail: [ ^ aFailBlock value ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method _ methodNode generate.
	method methodNode: methodNode.

	^aBlock value: compiler value: method value: aReceiver value: anEvaluationContext 
! !
!ToolsCatalog methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556698 overrides: 50440917!
browse: aToolName

	(tools at: aToolName) value! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555986!
tempNodes 
	| tempNodes |
	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].
	scopeTable associationsDo:
		[:assn |
		(assn value is: #Array)
			ifTrue: [assn value do: [:temp| tempNodes add: temp]]
			ifFalse: [assn value isTemp ifTrue: [tempNodes add: assn value]]].
	^tempNodes
	"jmv: perhaps better not include remote temps...
	^ tempNodes reject:
		[ : a |  a isUnusedTemp ]"! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561308!
methodWithCopiedAndAssignedTemps
	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |
	a := 1. "1w"
	b := 2. "1w"
	c := 4. "1w"
	t := 0. "1w"
	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".
	r1 "5w" := blk "5r" value.
	b "5w" := -100.
	r2 "5w" := blk "5r" value.
	^r1 "5r" -> r2 "5r" -> t "5r"

	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read
	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"


	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!NewInstanceVariablePrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554371!
valueOf: anInstanceVariableName for: aClass

	^(self of: anInstanceVariableName for: aClass) value! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563184!
methodWithCopiedTemps
	| a b c r |
	a := 1.
	b := 2.
	c := 4.
	r := [a + b + c] value.
	b := nil.
	r

	"Parser new
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class"

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!Mutex methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554884!
critical: aBlock onReentry: reentryBlock
	"Evaluate aBlock protected by the receiver.
	This method allows using the receiver either as a reentrant or non-reentrant Mutex.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ] onReentry: ['Reentry attempt!!' print]. 3 print ]. 'Done'.
	"

	| activeProcess |
	activeProcess _ Processor activeProcess.
	activeProcess == owner ifTrue: [^reentryBlock value].
	^semaphore critical: [
		owner _ activeProcess.
		aBlock ensure: [owner _ nil]].! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555327!
test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker value.
	
	typeChecker errorsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail

	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554499!
withRangesOf: nodeAtRange including: aPosition do: aBlock

	| currentNodeRange ranges |

	currentNodeRange := nodeAtRange value.
	ranges := currentNodeRange isInterval ifTrue: [ Array with: currentNodeRange ] ifFalse: [ currentNodeRange ].

	ranges do: [ :aRange | (aRange includes: aPosition) ifTrue: [ aBlock value: aRange ]].

	! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560001 overrides: 50497593!
errorsDetect: aCondition ifNone: noneBlock

	| errors |
	
	typeCheckers do: [ :typeChecker |
		errors := typeChecker errorsDetect: aCondition ifNone: [ nil ].
		errors ifNotNil: [ ^errors ]].
	
	^noneBlock value! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554924 overrides: 16822860!
addAll: aCollection
	"Refer to the comment in Collection|addAll:."

	(aCollection is: #Bag) ifFalse: [^ super addAll: aCollection].
	aCollection contents associationsDo: [ :each |
		self add: each key withOccurrences: each value].
	^ aCollection! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561644!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(SafelyRemoveClassApplier on: self of: aBehavior theNonMetaClass) value ].! !
!Graph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558604!
removeNode: anObject ifAbsent: aBlock

	| nodesWithoutNode edgesWithoutNode |

	(nodes includes: anObject) ifFalse: [^aBlock value].

	nodesWithoutNode := nodes reject: [:node | node = anObject].
	edgesWithoutNode := edges reject: [:edge | edge isIncidentTo: anObject].

	^self class edges: edgesWithoutNode nodes: nodesWithoutNode! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559040!
messageWithArgument: anArgument
	
	anArgument value! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557870 overrides: 16793610!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock value! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556408!
at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."
	"
		Smalltalk at: #zork ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'zork absent' print ]
		Smalltalk at: #Number ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'Number absent' print ]
	"

	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock value ].
	^ presentBlock value: assoc value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560144!
at: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys isArray ifTrue: [
		keyIndex _ keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [ values at: keyIndex ]].
	keys = aString ifTrue: [ ^ values ].
	^ aBlock value! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559582!
test05ProblemsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker value.
	
	typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563756!
typeCheckWhenAnnotatingTypes
	
	(MethodTypeCheckerVisitor for: method collectingErrorsInto: errors warningsInto: warnings andProblemsInto: problems) value
	! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559359!
test07ErrorsDetectIfNone

	| typeChecker error |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithManyTypeErrors }.
	typeChecker value.
	
	error := typeChecker errorsDetect: [ :anError | true ] ifNone: [ self fail ].
	self assert: #date equals: error selector key ! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562127!
popIntoTemporaryVariable: offset
	| maybeTVTag tempVector start |
	maybeTVTag := stack last.
	((maybeTVTag isMemberOf: Association)
	 and: [maybeTVTag key == #pushNewArray]) ifTrue:
		[blockStartsToTempVars notNil "implies we were intialized with temp names."
			ifTrue: "Use the provided temps"
				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp
							 and: [tempVector isIndirectTempVector
							 and: [tempVector remoteTemps size = maybeTVTag value size]])]
			ifFalse: "Synthesize some remote temps"
				[tempVector := maybeTVTag value.
				 offset + 1 <= tempVars size
					ifTrue:
						[start := 2.
						 tempVector at: 1 put: (tempVars at: offset + 1)]
					ifFalse:
						[tempVars := (Array new: offset + 1)
										replaceFrom: 1
										to: tempVars size
										with: tempVars.
						start := 1].
				 start to: tempVector size do:
					[:i|
					tempVector
						at: i
						put: (constructor
								codeTemp: numLocalTemps + offset + i - 1
								named: 'temp', (tempVarCount + i) printString)].
				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].
		 tempVarCount := tempVarCount + maybeTVTag value size.
		 stack removeLast.
		 ^self].
	self pushTemporaryVariable: offset; doStore: statements! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558309!
performWithFractionWithFormula

	self assert: (1/3 perform: messageName with: formulaOfTenPesos) value = 
		((1/3) value perform: messageName with: formulaOfTenPesos value)! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561968!
profilerFriendlyCall: aBlock
	"In AndreasSystemProfiler, usually primitives are reported as children of the wrong node.
	The reason is that while the primitive is recorded, it is only taken into account at next suspension point.
	
	For long running primitives, and maybe only while profiling, this method provides a workaround.
	Evaluate and compare

		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 timesTwoPower: 10000]].
		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 profilerFriendlyTimesTwoPower: 10000]].

	Also see #runProfilerProcess, and this more complex example (you might want to make it use #profilerFriendlyCall:)
		AndreasSystemProfiler spyOn:[10000 timesRepeat: [3.14159 printString]]

	Keep in mind there is a performance penaly each time this method is called.
	Consider doing it only for long-running primitives, or only while profiling code.
	"

	"The apparently useless loop is to ensure we have a suspension point in this method, after block evaluation.
	Suspension points are activation of message sends and bytecode back jumps."
	| primResult primWasCalled |
	primWasCalled _ false.
	[ primWasCalled ] whileFalse: [
		primResult _ aBlock value.
		primWasCalled _ true ].
	^primResult! !
!SortedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559012 overrides: 50556026!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	| sortBlockToUse firstCandidate |
	self isEmpty ifTrue: [^ exceptionBlock value].
	sortBlockToUse _ sortBlock ifNil: [[:a :b | a <= b ]].
	"if first element to check is it, answer so."
	firstCandidate _ self at: start.
	firstCandidate = anElement ifTrue: [ ^ start ].
	"if first element to check is already too late, answer 'NotHere' "
	(sortBlockToUse value: anElement value: firstCandidate) ifTrue: [
		^ exceptionBlock value ].
	"Ok. Look for it."
	^self
		findBinaryIndex: [ :some | 
			some = anElement
				ifTrue: [0]
				ifFalse: [ (sortBlockToUse value: anElement value: some) ifTrue: [-1] ifFalse: [1]]]
		do: [ :i | i ]
		ifNone: [ :i1 :i2 | exceptionBlock value ]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557383!
allActualSendersOn: sentSelector forAll: types whenSomeAreNotImplemented: someNotImplementedBlock whenNoImplementors: noImplementorsBlock
	
	| collector |
	
	collector := MultiImplementorsActualMessageSendsCollector 
		on: sentSelector 
		forAll: types
		whenSomeAreNotImplemented: someNotImplementedBlock 
		whenNoImplementors: noImplementorsBlock.
		
	collector value.
	
	^collector 
	! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563224!
removeDangerouslyKey: key ifAbsent: aBlock
	"This is not really dangerous.  But if normal removal
	were done WHILE a MethodDict were being used, the
	system might crash.  So instead we make a copy, then do
	this operation (which is NOT dangerous in a copy that is
	not being used), and then use the copy after the removal."

	| index element |
	index _ self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock value ].
	element _ array at: index.
	array at: index put: nil.
	self basicAt: index put: nil.
	tally _ tally - 1.
	self fixCollisionsFrom: index.
	^ element! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561019!
quickSend: selector to: rcvr with: arguments super: superFlag
	"Send the given selector with arguments in an environment which closely resembles
	 the non-simulating environment, with an interjected unwind-protected block to catch
	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to
	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."
	| oldSender contextToReturnTo result lookupClass |
	contextToReturnTo := self.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: rcvr].
	[oldSender := thisContext sender swapSender: self.
	 result := self object: rcvr perform: selector withArguments: arguments inClass: lookupClass.
	 thisContext sender swapSender: oldSender] ifCurtailed:
		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
		contextToReturnTo pc: contextToReturnTo previousPc.	"skip to front of return bytecode causing this unwind"
		contextToReturnTo willReturnTopFromMethod ifTrue:
			"If it was a returnTop, push the value to be returned.
			Otherwise the value is implicit in the bytecode"
			[contextToReturnTo push: (thisContext sender tempAt: 1)].
		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
		contextToReturnTo].
	contextToReturnTo push: result.
	^contextToReturnTo! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555964!
testSample01
	| blockClosure materialized |
	blockClosure _ self bc01.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure value = materialized value.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559621 overrides: 50533141!
negative

	^self value negative! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554347 overrides: 50533417!
compareGreaterThan: aNumber

	^self value compareGreaterThan: aNumber! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554021 overrides: 50565785!
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do:
		[:index |
		index = 1 ifFalse: [separatorBlock value].
		elementBlock value: (self at: index)]! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554398!
fileOutMethodAdditionsFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes _ Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		mAssoc value == #add
			ifTrue: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!RenameTemporaryTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560212!
test08RenameChangesReferencesFromOldVariableToNewVariable

	| methodNode oldVariable newVariable rename newMethodNode assigmentNode |
	
	oldVariable := 'old'.
	newVariable := 'new'.
	
	methodNode := self methodNodeOf: 'm1 | ', oldVariable, ' | ', oldVariable, ' := 1 + ', oldVariable.
	
	rename := RenameTemporary from: oldVariable to: newVariable in: methodNode.
	newMethodNode := rename methodNodeAfterApply.
	
	assigmentNode := newMethodNode block statements first.
	self assert: newVariable equals: assigmentNode variable name.
	self assert: newVariable equals: assigmentNode value arguments first name.! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558298!
test12HasErrorsReturnsTrueIfATypeCheckerHasErrors

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker value.
	
	self assert: typeChecker hasErrors ! !
!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560762!
compileAll: newClass from: oldClass
	"Something about this class has changed.  Locally retained methods must be recompiled.
	NOTE:  You might think that if this changeSet is in force, then we can just note
	the new methods but a lower change set may override and be in force which
	would mean that only the overriding copies go recompiled.  Just do it."

	methodChanges associationsDo:
		[:assn | | sel changeType changeRecord newMethod |
		sel := assn key.
		changeRecord := assn value.
		changeType := changeRecord changeType.
		(changeType == #add or: [changeType == #change]) ifTrue:
			[newMethod := newClass
				recompileNonResidentMethod: changeRecord currentMethod
				atSelector: sel from: oldClass.
			changeRecord noteNewMethod: newMethod]]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560066 overrides: 50533114!
evenInBaseUnit
	
	^self value evenInBaseUnit ! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561957 overrides: 16793683!
or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value or: [ aBlock3 value or: [ aBlock4  value ]]].
! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558141!
pushDownInstanceVariable

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushDownInstanceVariableApplier on: model at: aClass ) value].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559816 overrides: 16901764!
respondsTo: aSymbol

	^(super respondsTo: aSymbol) or:[self value respondsTo: aSymbol]! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559136!
m1_temps_not_in_block_read_temp

	| n1 n2 t1 |
	
	t1 := 1.
	[t1 + 1 ] value.
	
	n1 := n2 := 'hola'.
	n1 size + n2 size.
	
	^t1! !
!CPUWatcher methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555722!
findThePig
	"tally has been updated. Look at it to see if there is a bad process.
	This runs at a very high priority, so make it fast"
	| countAndProcess | 
	countAndProcess _ tally sortedCounts first.
	(countAndProcess key / tally size > threshold) ifTrue: [ | proc |
		proc _ countAndProcess value.
		proc == Processor backgroundProcess ifTrue: [ ^self ].	"idle process? OK"
		self catchThePig: proc
	].
! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50553943!
at: aKey ifAbsentPut: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma value]
				ifFalse: [propertyOrPragma]]].
	^method propertyValueAt: aKey put: aBlock value! !
!RelativeGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555314!
absoluteDate
	"It is necessary to send #value for not assume that the dates of the time line filter are absolute ,
	and also it is necessary to send #value to the timespan in order to obtain a relative timespan"
	
	^(timeLineFilter next: timespan value) value! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557749!
before: target ifNone: exceptionBlock
	"Answer the receiver's element immediately before target. Answer
	the result of evaluating the exceptionBlock if there are no elements before it."

	| index |
	index _ self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = 1 
			ifTrue: [exceptionBlock value]
			ifFalse: [self at: index - 1]]! !
!ClassReferencesCollector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50553687!
valueOf: aClassToLookForReferences

	^(self of: aClassToLookForReferences) value! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556350!
introduceNullObject

	| classToRefactor |

	classToRefactor := model selectedClassOrMetaClass.

	classToRefactor ifNotNil: [(IntroduceNullObjectApplier applyOn: classToRefactor) value.].! !
!ClassDefinitionNodeAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558088!
superclass
	
	^superClassNode key value ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559248!
printWithClosureAnalysisToDoOn: aStream indent: level

	| limitNode |
	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	limitNode := (arguments last == nil
				or: [arguments last isAssignmentNode not])
					ifTrue: [arguments first]
					ifFalse: [arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printWithClosureAnalysisKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559733!
indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock
	"Answer the index of the receiver's first element, such that that element 
	equals the first element of sub, and the next elements equal 
	the rest of the elements of sub. Begin the search at element 
	start of the receiver. If no such match is found, answer the result of 
	evaluating argument, exceptionBlock."
	| first index |
	sub isEmpty ifTrue: [^ exceptionBlock value].
	first _ sub first.
	start to: self size - sub size + 1 do:
		[:startIndex |
		(self at: startIndex) = first ifTrue:
			[index _ 1.
			[(self at: startIndex+index-1) = (sub at: index)]
				whileTrue:
				[index = sub size ifTrue: [^startIndex].
				index _ index+1]]].
	^ exceptionBlock value! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560681!
performWithFloatWithFormula

	self assert: (1.01 perform: messageName with: formulaOfTenPesos) value =
		(1.01 value perform: messageName with: formulaOfTenPesos value)
	! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554810!
testInlineBlockCollectionLR3
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559452 overrides: 50533480!
equalsSimpleMeasure: aMeasure

	^self value = aMeasure! !
!CompiledMethod class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555974!
field: aFieldName from: tokens ifAbsentOrNil: aBlock

	| fieldValue fieldIndex |
	
	fieldIndex _ tokens indexOf: aFieldName ifAbsent: [ ^aBlock value ].
	fieldValue _ tokens at: fieldIndex + 1 ifAbsent: [ ^aBlock value ].
	
	^ fieldValue ifNil: aBlock! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561067!
browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references _ OrderedCollection new.
	(LookupKey allSubInstances select:
		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:
		['AnOb*' match: x value class name]]) 
		do: [:x | references addAll: (Smalltalk allCallsOn: x)].
	Smalltalk 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!CompiledMethodCoverageReportBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561615!
selectBooleanSourceRanges: aCondition
	
	"Select the boolean source range declarations passing the covered boolean values referenced by them to aCondition.
	Return both the declarations that satisfies aCondition and their usages."
	
	| selectedDeclarations |
	selectedDeclarations := booleanValuesByDeclaration associations
		select: [ :sourceRangeAndCoveredValues | aCondition value: sourceRangeAndCoveredValues value ]
		thenCollect: [ :sourceRangeAndCoveredValues | sourceRangeAndCoveredValues key ].
	
	^ self collectWithUsages: selectedDeclarations! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50557218 overrides: 50533339!
quoFrom: aNumber

	^self value quoFrom: aNumber
! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50563931!
autoCompletionAround: aBlock keyStroke: aKeyboardEvent

	(self handleKeystrokeBefore: aKeyboardEvent)
		ifTrue: [^ self].
	aBlock value.
	"Narrow the completion with any of the keys"
	self handleKeystrokeAfter: aKeyboardEvent! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559574!
withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each value]! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562829 overrides: 50568165!
renameInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRenameCollaboratorApplier on: model at: aClass) value ].! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50554414 overrides: 16842308!
add: anAssociation
	^ self at: anAssociation key put: anAssociation value! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50553972!
isFalse: aBooleanOrBlock description: aFailureDescription

	self isTrue: aBooleanOrBlock value not description: aFailureDescription ! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560960!
hasVariableBindingTo: aClass 
	
	self literalsDo: [ :aLiteral |
		(aLiteral isVariableBinding and: [ aLiteral value = aClass ]) ifTrue: [ ^true ]].
	
	^false! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50561580!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer _ String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!Heap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558926 overrides: 16935088!
remove: oldObject ifAbsent: aBlock
	"Remove oldObject as one of the receiver's elements. If several of the 
	elements are equal to oldObject, only one is removed. If no element is 
	equal to oldObject, answer the result of evaluating anExceptionBlock. 
	Otherwise, answer the argument, oldObject."
	1 to: tally do:[:i| 
		(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].
	^aBlock value! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555819 overrides: 16823478!
select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new 
	dictionary, only those associations for which aBlock evaluates to true."

	| newCollection |
	newCollection _ self species new.
	self associationsDo: 
		[:each | 
		(aBlock value: each value) ifTrue: [newCollection add: each]].
	^newCollection! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50559804!
assert: anAction changes: aCondition by: aDifference 
	
	| after before |
	
	before := aCondition value.
	anAction value.
	after := aCondition value.
	
	self assert: after equals: before + aDifference! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50558179!
cascadeNodeWithBlockReceiverThatIsEvaluated

	[ self value ]
		class;
		value! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50560713!
testNegated

	self assert: formulaOfTenPesos negated value = formulaOfTenPesos value negated.
	self assert: formulaOfTenPesos negated negated value = formulaOfTenPesos value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562599!
notInclusiveBetween: min andNotInclusive: max
	"Create local variable #val for best performance"

	| val |

	val := self value.
	^val > min and: [val < max]! !
!WeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50556175 overrides: 16782112!
storeOn: aStream
	aStream 
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll:' key: '.
	self key storeOn: aStream.
	aStream nextPutAll: ' value: '.
	self value storeOn: aStream.
	aStream nextPut: $)! !
!IntroduceNullObjectApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50555265 overrides: 16923803!
requestRefactoringParameters

	self chooseInstanceVariable.

	instanceVariable ifNil: [^self].

	ifNilChecks := (IfNilChecksFinder on: classToRefactor for: instanceVariable) value.

	ifNilChecks ifEmpty: [^self inform: ('There are no ifNil checks on ', instanceVariable)].

	form := IntroduceNullObjectForm open: self.! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562539!
builderForClassEqualOrIdenticalTo: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver receiver key value 
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!NoTypeCastApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:02' prior: 50562407 overrides: 50497139!
typesIfCasting: aParseNode using: originalTypes ifNot: aNotBlock

	^aNotBlock value! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557730!
assert: aBlock
	"Throw an assertion error if aBlock does not evaluates to true."

	aBlock value ifFalse: [AssertionFailure signal: 'Assertion failed']! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556004 overrides: 50533247!
addCompoundMeasure: aMeasureBag

	^self value addCompoundMeasure: aMeasureBag! !
!Utilities class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562920!
awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock
	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw
3/31/00 JMM added logic to stop multiple redraws"

	| p inside lightForm darkForm isLight |

	p _ Sensor mousePoint.
	inside _ box insetBy: 1.
	isLight _ true.
	lightForm _ Form fromDisplay: inside.
	darkForm _ lightForm copy reverse.
	[Sensor isAnyButtonPressed] whileTrue:
		[doBlock1 value.
		(box containsPoint: (p _ Sensor mousePoint))
			ifTrue: [doBlock2 value.
					isLight ifTrue: 
						[isLight _ false.
						darkForm displayAt: inside origin]]
			ifFalse: [isLight ifFalse:
						[isLight _ true.
						lightForm displayAt: inside origin]]].
	(box containsPoint: p)
		ifTrue: [lightForm displayAt: inside origin.
				^ succBlock value]
! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556161!
propertyKeysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[aBlock value: propertyOrPragma key value: propertyOrPragma value]]! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562588 overrides: 16793631!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock value! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559707 overrides: 16935688!
collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	| newCollection |
	newCollection _ self species new: self size.
	self associationsDo: [ :each |
		newCollection at: each key put: (aBlock value: each value) ].
	^newCollection! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556063 overrides: 16842308!
add: anAssociation
	self at: anAssociation key put: anAssociation value.
	^ anAssociation! !
!CodeCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560748!
test012_DoesNotAllowRequestingTheCodeCoverageReportForACompiledMethodThatWasNotAnalyzed

	self setupCodeCoverageAnalyzerForM1Method;
		startTrackingCodeCoverage;
		stopTrackingCodeCoverage.
	
	self assertRaisesCompiledMethodWasNotAnalizedError:  [ codeCoverageAnalyzer report reportForCompiledMethod: Object>>#value ]! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557263 overrides: 16935088!
remove: aLink ifAbsent: aBlock  
	"Remove aLink from the receiver. If it is not there, answer the result of
	evaluating aBlock."

	| tempLink |
	aLink == firstLink
		ifTrue: [firstLink _ aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink _ nil]]
		ifFalse: [tempLink _ firstLink.
				[tempLink ifNil: [^aBlock value].
				 tempLink nextLink == aLink]
					whileFalse: [tempLink _ tempLink nextLink].
				tempLink nextLink: aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink _ tempLink]].
	aLink nextLink: nil.
	^aLink! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553981 overrides: 50533152!
positive

	^self value positive! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554267!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	Note: There can be multiple keys with the same value. Only one is returned."
 
	self associationsDo: 
		[:association | value == association value ifTrue: [^association key]].
	^exceptionBlock value! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563848!
testMethodTemp
	| block1 block2 |
	block1 := self methodArgument: 1.
	block2 := self methodArgument: 2.
	self assert: block1 value = 1.
	self assert: block2 value = 2! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554144!
rangesForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563812!
blockReturn

	[ 'hello' ] value.
	
	^10! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557714!
methodClass
	"answer the class that I am installed in"
	^(self literalAt: self numLiterals) value.! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556934!
inlineAssignmentNode: anAssignmentNode withExpression: anExpression upTo: anIndex

	| assignmentNodeValue |

	assignmentNodeValue := anAssignmentNode value.
	assignmentNodeValue isMessageNode
		ifTrue: [
			assignmentNodeValue isUnaryMessageSend
				ifTrue: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isInfix
				ifTrue: [self inlineTemporaryNodeWithBinaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isKeywordMessageSend
				ifTrue: [self inlineTemporaryNodeWithKeywordMessageExpression: anExpression
					upTo: anIndex].

		]
		ifFalse: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression upTo: anIndex].! !
!CompiledMethodCoverageReport methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558974!
selectSourceRangesByCoverageRatio: aBlock
	
	^ coverageRatioBySourceRange associations
		select: [ :sourceRangeAndCoverageRatio | aBlock value: sourceRangeAndCoverageRatio value ]
		thenCollect: [ :sourceRangeAndCoverageRatio | sourceRangeAndCoverageRatio key ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556981 overrides: 50533171!
- anAritmethicObject

	^self value - anAritmethicObject value! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556445!
propertyValueAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
		 and: [propertyOrPragma key == aKey]) ifTrue:
			[^propertyOrPragma value]].
	^aBlock value! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557596!
testInlineBlockCollectionLR1
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | col add: [ each ] ].
	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558771!
addActualImplementorsOf: anOldSelector forTypes: receiverTypes to: implementors andActualSendersTo: senders inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: anOldSelector in: aType) 
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].
	
	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector value.
	
	senders addAll: actualSendersCollector messageList.
	
	! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554554!
packageOfClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock value ].
	^ InstalledPackages
		detect: [:ea | ea includesClass: aClass]
		ifNone: errorBlock! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562473!
withIndexDo: elementAndIndexBlock separatedBy: separatorBlock
	"Evaluate the elementAndIndexBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do: [:index |
		index = 1 ifFalse: [separatorBlock value].
		elementAndIndexBlock value: (self at: index) value: index]! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561507!
assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges value anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range)
				and: [(methodNode positionsForTemporaryVariable: variableToInline ifAbsent: [#()]) 
					anySatisfy: [:tempReferenceInterval | range includesAllOf: tempReferenceInterval]]
				and: [assignmentToTemporaryPositions anySatisfy: [:tempAssignmentPosition | tempAssignmentPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558254!
testSample08
	| blockClosures materialized |

	blockClosures _ self bc08.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first value = materialized first value.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third value = materialized third value.
	self deny: (blockClosures second value: 7) = (materialized second value: 7).
	self deny: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).

	blockClosures _ self bc08.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first value = materialized first value.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third value = materialized third value.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555452!
rangesIn: aBlockRange toReplacementParametersFrom: replacementParameter with: anExtraMapping

	| rangesInsideBlockRange rangesOffsetToBlock variableToParametrizeRangeToReplacingParameter offset |

	variableToParametrizeRangeToReplacingParameter := replacementParameter rangesOfVariablesToParametrizeToReplacingParameterWith: anExtraMapping.
	rangesInsideBlockRange := variableToParametrizeRangeToReplacingParameter select: [:rangeToReplacement |
		aBlockRange includes: rangeToReplacement key first].
	offset := aBlockRange first - 1.
	rangesOffsetToBlock := rangesInsideBlockRange collect: [:rangeToReplacement |
		Association key: rangeToReplacement key - offset value: rangeToReplacement value].

	^rangesOffsetToBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555897!
withTopParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |
	
	nodeAndPosition :=self topParseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].

	^aBlock value: nodeAndPosition key
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555258!
blockWithReadAndWrittenTemporaryVariable

	[ |a| a := 1. a ] value! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558888 overrides: 16983276!
pastEndPut: anObject
	collection size >= limit ifTrue: [limitBlock value].  "Exceptional return"
	^ super pastEndPut: anObject! !
!ReadOnlyVariableBinding methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553705 overrides: 16881493!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' ->(ReadOnlyVariableBinding) ';
		print: self value.! !
!TemporaryVariableDeclarationRemover methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561195!
sourceTextWithoutTemporaryFromParseNode: aParseNode
withTemporaryDeclarationLineRemover: aTemporaryDeclarationLineRemovingBlock
	
	^aParseNode temporaries size = 1 
		ifTrue: aTemporaryDeclarationLineRemovingBlock value
		ifFalse: [ self sourceTextWithoutTemporaryDeclaration ].! !
!Association methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559145 overrides: 16881481!
= anAssociation

	self == anAssociation ifTrue: [ ^ true ].
	^ super = anAssociation and: [value = anAssociation value]! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556242!
evaluateCopyOf: aBlock
	aBlock copy value! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555522!
at: key ifAbsentOrNil: aBlock
	"In a WeakValueDictionary, normally nil values (i.e. collected values) are considered the same as if the key/value was never added. Hence, this convenience method."
	
	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ aBlock value ].
	^ assoc value ifNil: [ aBlock value ]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559633!
grabProcessorFor: milliseconds onTimeout: timeoutBlock
	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.
	If not finished after milliseconds, evaluate timeoutBlock and restore original priority.
	Use with care!!"
	"Based on #valueUnpreemptively"
	
	| activeProcess oldPriority result done |
	activeProcess _ Processor activeProcess.
	oldPriority _ activeProcess priority.
	done _ false.
	
	activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.
	milliseconds ifNotNil: [
		[
			(Delay forMilliseconds: milliseconds) wait.
			done ifFalse: [
				activeProcess
					suspend;
					priority: oldPriority.
				timeoutBlock value.
				"The timeoutBlock might terminate it, or even resume it!!"
				activeProcess isSuspended ifTrue: [
					activeProcess resume ]]
		] forkAt: Processor highIOPriority named: '#grabProcessorFor:onTimeout:' ].

	result _ self ensure: [
		done _ true.
		activeProcess priority: oldPriority].
	
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !
!LayoutMorph class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556882!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row _ LayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556225!
raiseErrorFromBlock

	[ self error: self errorMessageForTesting ] value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558694!
emptyBlock
	
	[] value! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557329!
printTemporaries: tempSequence on: aStream doPrior: aBlock
	"Print any in-scope temporaries.  If there are any evaluate aBlock
	 prior to printing.  Answer whether any temporaries were printed."
	| tempStream seen |
	tempSequence ifNil:
		[^false].
	tempStream := String writeStream.
	"This is for the decompiler which canmot work out which optimized block a particular temp is
	 local to and hence may produce diplicates as in
		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"
	seen := Set new.
	tempSequence do:
		[:tempNode |
		tempNode isIndirectTempVector
			ifTrue:
				[tempNode remoteTemps do:
					[:tempVariableNode|
					 (tempVariableNode scope >= 0
					  and: [(seen includes: tempNode key) not]) ifTrue:
						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]
			ifFalse:
				[(tempNode scope >= -1
				  and: ["This is for the decompiler which may create a block arg when converting
						a while into a to:do: but won't remove it form temporaries"
					   tempNode isBlockArg not
				  and: [(seen includes: tempNode key) not]]) ifTrue:
					[tempStream space; nextPutAll: (seen add: tempNode key)]]].
	tempStream position = 0 ifTrue:
		[^false].
	aBlock value.
	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.
	^true! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555880!
m1_read_write_temp

	| t1 |
	
	t1 := 1.
	[ t1 := t1 + 1 ] value.
	
	^t1! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560735!
whileTrue: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is true."

	^ [self value] whileTrue: [aBlock value]! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554283!
findAnyDisplayDepthIfNone: aBlock
	"Return any display depth that is supported on this system.
	If there is none, evaluate aBlock."
	#(32 16 8 4 2 1 -32 -16 -8 -4 -2 -1) do:[:bpp|
		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].
	].
	^aBlock value! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554312!
resumeEvaluating: aBlock
	"Unwind thisContext to self and resume with aBlock value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: aBlock value to: self].
	ctxt := thisContext.
	[
		ctxt := ctxt findNextUnwindContextUpTo: self.
		ctxt isNil
	] whileFalse: [
		(ctxt tempAt: 2) isNil ifTrue:
			[
				ctxt tempAt: 2 put: true.
				unwindBlock := ctxt tempAt: 1.
				thisContext terminateTo: ctxt.
				unwindBlock value
			]
	].
	thisContext terminateTo: self.
	^aBlock value! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562338!
at: aKey ifAbsent: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma value]
				ifFalse: [propertyOrPragma]]].
	^aBlock value! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556704 overrides: 16823722!
remove: oldObject ifAbsent: exceptionBlock 
	"Refer to the comment in Collection|remove:ifAbsent:."

	| count |
	count _ contents at: oldObject ifAbsent: [^ exceptionBlock value].
	count = 1
		ifTrue: [contents removeKey: oldObject]
		ifFalse: [contents at: oldObject put: count - 1].
	^ oldObject! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562666!
statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences _ self references.	"Exclude unrealized weaks"
	parents _ IdentityDictionary new: normalReferences size * 2.
	n _ 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n _ n+1).
		kids _ parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags _ Dictionary new.
	tallies _ Bag new.
	n _ 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n _ n+1).
		nm _ obj class name.
		tallies add: nm.
		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n _ assn key.  nm _ assn value.
			owners _ ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554046!
withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !
!DenotativeObjectTestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562227 overrides: 50567038!
debugAsFailureIfCanNot: handler

	self ifCanNotDebugDo: [ ^handler value].

	self runCaseAsFailure! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561653!
messageSendWithMessageSendReceiver

	(OrderedCollection new)
		value! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563469!
performWithFormulaWithFloat

	self assert: (formulaOfTenPesos perform: messageName with: 1.01) value = 
		(formulaOfTenPesos value perform: messageName with: 1.01 value)! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559595!
associationForClass
	| assoc |
	assoc _ Smalltalk associationAt: class name ifAbsent: [ nil ].
	^assoc value == class
		ifTrue: [ assoc ]
		ifFalse: [ Association new value: class ]! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557660!
machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray selector |
	selector _ machinePref caseOf: {
			[#default]		 		-> [#machineDefault].
			[#slow] 				-> [#machineSlow].
			[#smalltalk80] 				-> [#machineSmalltalk80] }
		otherwise: [ #default ].
	prefArray _ self perform: selector.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556742!
classOfBindingOf: aName
												
	^ (self bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563439!
assert: anAction doesNotChange: aCondition 

	| after before |
	
	before := aCondition value.
	anAction value.
	after := aCondition value.
	
	self assert: after equals: before! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561464!
endRequest

	^requestExitBlock value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561575 overrides: 16902975!
printOn: aStream

	self value printOn: aStream! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561270!
renameTemporary: aTemporaryNode at: aMethodNode

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryNode at: aMethodNode ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier value ].
! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560436!
should: aBlock raise: anExceptionHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	| passed |
	passed := [aBlock value.  false]
		on: anExceptionHandlingCondition
		do: [:ex | assertionsBlock value: ex.  ex return: true].
	passed ifFalse: [self failWith: aFailDescription]! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555673!
testSample04
	| blockClosure materialized |
	blockClosure _ self bc04.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure value = materialized value.! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555131!
typesOf: aVarName ifAbsent: aBlock

	| varTypeInfo |
	
	varTypeInfo := self typeInfoOf: aVarName ifAbsent: [ ^aBlock value ].
	
	^varTypeInfo types! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563368 overrides: 50533271!
divFrom: aNumber 
	
	^self value divFrom: aNumber! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557580 overrides: 50533276!
divideCompoundMeasure: aMeasureBag

	^self value divideCompoundMeasure: aMeasureBag! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557617 overrides: 50533470!
convertTo: aTargetUnit using: aMeasureConverter

	^self value convertTo: aTargetUnit using: aMeasureConverter! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554514 overrides: 16920246!
ifNil: nilBlock ifNotNil: ifNotNilBlock
	"Evaluate the block for nil because I'm == nil"

	^ nilBlock value! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562010!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(RenameClassApplier for: aBehavior theNonMetaClass) value ].! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558530 overrides: 50566889!
removeKey: key ifAbsent: errorBlock 
	"The interpreter might be using this MethodDict while
	this method is running!!  Therefore we perform the removal
	in a copy, and then atomically become that copy"
	| copy |
	copy _ self copy.
	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].
	self become: copy! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562386!
createHierarchyTreeOf: col

	"Create a tree from a flat collection of classes"

	| transformed |

	transformed := col collect: [:ea | 
		| childs indexes |
		childs := col select: [:class | class superclass = ea].
		indexes := childs collect: [:child | col indexOf: child].
		Association key: ea value: indexes].
	transformed copy do: [:ea |
		ea value: (ea value collect: [:idx | 
			| val |
			val := transformed at: idx.
			transformed at: idx put: nil.
			val])].
	^ transformed select: [:ea | ea notNil].
! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557586!
waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
	[aBlock value] whileTrue: [self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil].! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554378!
checkForSlips
	"Return a collection of method refs with possible debugging code in them."
	| slips |
	slips _ OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				method _ aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					method hasReportableSlip
						ifTrue: [slips add: (MethodReference method: method)]]]]].
	^ slips! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559880!
test02ClassesCanBeTypeChecked

	| typeChecker typeCheckers |
	
	typeChecker := MethodTypeCheckerTest typeCheck.
	
	typeChecker value.
	
	typeCheckers := MethodTypeCheckerTest selectors collect: [ :aSelector |  (MethodTypeCheckerTest >> aSelector) typeCheck].
	typeCheckers := typeCheckers, (MethodTypeCheckerTest class selectors collect: [ :aSelector | (MethodTypeCheckerTest >> aSelector) typeCheck ]).
	
	self assert: typeChecker errorsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker errorsSize ]).
	self assert: typeChecker warningsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker warningsSize ]).
! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561636!
binaryAt: localFileName ifAbsent: block

	^ [self binaryAt: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block value]! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559340!
testMethodArgument
	| temp block |
	temp := 0.
	block := [ [ temp ] ].
	temp := 1.
	block := block value.
	temp := 2.
	self assert: block value = 2! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557496!
loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		self 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #value)	 " We want the raw value "]! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555549 overrides: 50556026!
indexOf: anUnicodeCodePoint startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	startByteIndex _ self byteIndexAt: start.
	foundByteIndex _ String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer _ self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556070!
messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	| ranges sortedRanges |

	ranges := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].

	ranges isEmpty ifTrue: [ ^aBlock value ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].

	^sortedRanges ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563496!
askAutosaveTypeIfCancelled: aBlock

	| menuIndex options labels |

	options := {SingleFileSystemCategoryAutoSaver. MultiFileSystemCategoryAutoSaver}.
	labels := options collect: [ :autoSaverClass | autoSaverClass menuDescription].
	menuIndex := (PopUpMenu labelArray: labels) startUpWithCaption: 'Autosave Type'.
	
	^ menuIndex = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ options at: menuIndex ]
	! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560034 overrides: 16977821!
sizeCodeForValue: encoder
	self reserve: encoder.
	(key isVariableBinding and: [key isSpecialReadBinding]) 
		ifFalse:
			[^encoder sizePushLiteralVar: index].
	readNode := MessageNode new 
		receiver: (encoder encodeLiteral: key)
		selector: (encoder encodeSelector: #value)
		arguments: #()
		precedence: #value precedence.
	^readNode sizeCodeForValue: encoder! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556154!
runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) value
	
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561441!
cascadeNodeWithBlockReceiverThatIsNotEvaluated

	[ self value ]
		class;
		hash! !
!FixedGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555753 overrides: 50521654!
= anObject

	| valuedObject |

	self == anObject ifTrue: [^true].
	anObject isGregorianDate ifFalse: [^false].
	valuedObject := anObject value.

	^dayNumber = valuedObject dayNumber and: [ monthOfYear = valuedObject monthOfYear ]! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558320!
on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordUnder: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].
	
	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor methodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := (methodNode parseNodesPathAt: aSelectionInterval first ifAbsent: 	[self shouldNotHappen.])
						detect: [:aNodeAndRange | aNodeAndRange key isAssignmentNode]
						ifNone: [noTempFoundBlock value].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange value using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock value.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !
!StandardFileStream class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561878!
retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt _ self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock value.! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555908!
m4_many_temps_in_remote_vector

	| t1 t2 t3 |
	
	[ t1 := 1 ] value.
	[ t2 := 'hello' ] value.
	
	t3 := t1 + t2 size.
	
	^t3! !
!HierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555234 overrides: 16911810!
getMenu
	"Answer the menu for this view"

	menuGetter ifNil: [^ nil].
	(menuGetter is: #MessageSend) ifTrue: [
		^menuGetter value ].
	menuGetter numArgs = 0 ifTrue: [
		^ mainView perform: menuGetter ].
	^ self error: 'The menuGetter has an unsupported number of arguments'! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555167 overrides: 50337880!
doesNotUnderstand: aMessage

	^aMessage sendTo: self value! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561398!
performWithFormulaWithFraction

	self assert: (formulaOfTenPesos perform: messageName with: (1/3)) value = 
		(formulaOfTenPesos value perform: messageName with: (1/3) value)! !
!ReceptiveAccountTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554699!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555636!
builderForClassNotEqualOrNotIdenticalTo: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver receiver key value 
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments second 
		rejectingDuring: aMessageNode arguments first
		! !
!InlineMethodWithActualScope class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556786!
addActualImplementorsOf: aSelectorToInline forTypes: receiverTypes to: implementors 
	andActualMessageSendsTo: messageSends inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: aSelectorToInline in: aType) 
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].
	
	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector value.
	
	actualSendersCollector messageList do: [:aMethodNodeReference | 
		"The message list contains a mix of dummy method references (that work as separator titles
		in the message list window), actual real method node references and possible senders"
		
	aMethodNodeReference isMessageListTitle 
			ifTrue: [ | titleMessageNode |
				titleMessageNode := MessageNodeReference messageNode: nil selector: aMethodNodeReference selector 
					class: aMethodNodeReference actualClass completeSourceRange: #().
				titleMessageNode stringVersion: aMethodNodeReference stringVersion.
				messageSends add: titleMessageNode 
			] 
			ifFalse: [ | messageNodeReferences |
				messageNodeReferences _ self findReferencesToSelector: aSelectorToInline in: aMethodNodeReference.
				messageSends addAll: ((aMethodNodeReference isPossibleSender)
					ifTrue: [messageNodeReferences collect: [:messageNodeReference | 
							messageNodeReference asPossibleMessageNodeReference ]]
					ifFalse: [messageNodeReferences])
				].
	].
	
	! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560333!
valueIn: aMessageNode excluding: aVariableName 
	
	^(self new initializeToFindIn: aMessageNode excluding: aVariableName) value! !
!Morph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563826!
mouseStillDown
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	
	self "Allow instances to use this"
		valueOfProperty: #'mouseStillDown
'		ifPresentDo: [ :handler | handler value ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555509!
withNodeUnderCursorDo: aDoBlock ifAbsent: anAbsentBlock

	self 
		withMethodNodeAndClassDo: [ :currentMethodNode :currentClass |
			currentMethodNode 
				withParseNodeIncluding: self startIndex
				do: aDoBlock
				ifAbsent: anAbsentBlock ] 
		ifErrorsParsing: [ :arg1 | anAbsentBlock value ].! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558094 overrides: 16793556!
and: aBlock1 and: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value ]! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558042!
createSuperclassOf: aDenotativeObject onCancel: aBlock

	| denotativeObjectParent categoryName superclass superclassName |
	
	denotativeObjectParent := aDenotativeObject parentIfNone: [ ^Object ].
	
	superclassName := ClassNameRequestMorph request: 'Class for ', denotativeObjectParent name orCancel: [ ^aBlock value ].
	(Smalltalk classNamed: superclassName) ifNotNil: [ :alreadyExistingSuperclass |
		(PopUpMenu 
			confirm: superclassName, ' already exist. Do you want to recreate or reuse it?' 
			trueChoice: 'Recreate it' 
			falseChoice: 'Reuse it') ifFalse: [ ^alreadyExistingSuperclass ]].
		
	categoryName := StringRequestMorph 
		request: 'Enter category name' 
		initialAnswer: denotativeObjectParent category 
		orCancel: [ ^aBlock value ].	
		
	superclass := self createSuperclassOf: denotativeObjectParent onCancel: aBlock.
	
	^denotativeObjectParent createClassNamed: superclassName asSymbol subclassOf: superclass category: categoryName! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553719!
rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext
	"Answer the indices in the source code for the supplied pc.
	 If the context is the actve context (is at the hot end of the stack)
	 then its pc is the current pc.  But if the context isn't, because it is
	 suspended sending a message, then its current pc is the previous pc."

	| pc end |
	pc _ self method abstractPCForConcretePC:
		(contextIsActiveContext
			ifTrue: [ contextsConcretePC ]
			ifFalse: [
				(self method pcPreviousTo: contextsConcretePC) ifNil: [ contextsConcretePC ]]).
	(self abstractSourceMap includesKey: pc) ifTrue: [
		^self abstractSourceMap at: pc].
	sortedSourceMap ifNil: [
		sortedSourceMap _ self abstractSourceMap.
		sortedSourceMap _ (sortedSourceMap keys
			collect: [ :key | key -> (sortedSourceMap at: key)])
				asSortedCollection ].
	sortedSourceMap
		findBinaryIndex: [ :assoc | pc - assoc key ]
		do: [ :i | ^(sortedSourceMap at: i) value ]
		ifNone: [ :lower :upper |
			lower = 0 ifTrue: [ ^1 to: 0 ].
			upper <= sortedSourceMap size ifTrue: [
				^(sortedSourceMap at: upper) value ].    "No match, but  a nearby element."
			end _ sortedSourceMap detectMax: [ :each |
				each value last ].
			end _ end value last.
			^end + 1 to: end ].

	"| method source scanner map |
	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.
	method := Debugger >> #pcRange.
	source := method getSourceFromFile asString.
	scanner := InstructionStream on: method.
	map := method debuggerMap.
	Array streamContents:
		[:ranges|
		[scanner atEnd] whileFalse:
			[| range |
			 range := map rangeForPC: scanner pc contextIsActiveContext: true.
			 ((map abstractSourceMap includesKey: scanner abstractPC)
			  and: [range first ~= 0]) ifTrue:
				[ranges nextPut: (source copyFrom: range first to: range last)].
			scanner interpretNextInstructionFor: InstructionClient new]]"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553676 overrides: 50533145!
odd
	
	^self value odd! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560294!
cancel
	self delete.
	cancelBlock ifNotNil: [cancelBlock value]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563031 overrides: 50533466!
convertToBaseUnit

	^self value convertToBaseUnit! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557224!
packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock value ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodCategory: categoryName ofClass: aClass]
		ifNone: errorBlock! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560087!
test10WarningsDetectIfNone

	| typeChecker typeWarning |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError. }.
	typeChecker value.
	
	typeWarning := typeChecker warningsDetect: [ :aTypeWarning | true ] ifNone: [ self fail ].
	self assert: typeWarning receiver isMessageNode.	
	self assert: #first equals: typeWarning selector key.
! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558679!
is: aRange equalTo: sourceInterval or: intervalToReplace 
	
	"When selecting literals like 1, the range first is one less than the initial character of the literal - Hernan"
	
	^aRange = sourceInterval 
		or: [ aRange = intervalToReplace
		or: [ aRange first + 1 = sourceInterval first and: [ aRange value last = sourceInterval last]]]! !
!CodeCoverageAnalyzerBuilder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556866!
valueFrom: aTestSuite 
	
	^ (self from: aTestSuite) value! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563130!
shouldnt: aBlock

	self deny: aBlock value
			! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558035 overrides: 16892057!
dropFiles: aDropFilesEvent

	(DropFilesAction for: aDropFilesEvent) value! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555279!
properties

	| propertyStream propertyOrPragma "<Association|Pragma>" |
	propertyStream := WriteStream on: (Array new: self basicSize * 2).
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma value]].
	^IdentityDictionary newFromPairs: propertyStream contents! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557765!
test06WarningsCollectsAllTypeCheckersWarnings

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError }.
	typeChecker value.
	
	self assert: typeChecker warnings notEmpty! !
!CompiledMethodCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557115!
test007_DoesNotAnalyzeTheWrappedMethodWhenCodeCoverageIsDisabled
	
	| reportBuilder |
	self createAnalyzerFor: self compiledMethodAtM1Selector.
	compiledMethodAnalyzer install.
	reportBuilder := compiledMethodAnalyzer registerNewCoverageReportBuilder.
	
	compiledMethodAnalyzer run: #m1 with: #() in: self.
	
	self
		assert: 0
		equals: reportBuilder value percentCovered.! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559119 overrides: 50561594!
addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectAddCollaboratorApplier on: model for: aClass) value ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560103!
runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553694 overrides: 50496276!
typeInfoOf: anInstVarName ifAbsent: anAbsentBlock

	(class definesInstanceVariableNamedInHierarchy: anInstVarName) ifFalse:[ ^anAbsentBlock value ].
	
	^ self typeInfoInHierarchyOf: anInstVarName! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562720!
withSelectorAt: aPosition do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock

	| methodNode nodeAtRange nodeUnderCursor  |
	
	methodNode := self codeProvider
		methodNodeOf: model actualContents
		ifErrorsParsing: [ :anError | ^ failBlock value ].
	
	aPosition < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: aPosition ifAbsent: [ ^ failBlock value ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ]) ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].
	(nodeUnderCursor isLiteralVariableNode and: [ nodeUnderCursor isReferencingBehavior ]) ifTrue: [ ^aBehaviorBlock value: nodeUnderCursor key value ].
	
	^ failBlock value ! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557150!
test05DoesNotIncludeNotExtractableSourceCode

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 100'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556304!
stringToEvalSending: aSymbol to: aDenotativeObject onCancel: aCancelBlock

	| externalCollaborators |
	
	externalCollaborators := (aDenotativeObject class >> aSymbol) methodNode arguments collect: [ :anArgumentNode |
		StringRequestMorph request: 'Enter collaborator ', anArgumentNode name orCancel: [^aCancelBlock value] ].
	
	^String streamContents: [ :stream |
		stream 
			nextPutAll: aDenotativeObject name;
			space.
			
		aSymbol numArgs = 0
			ifTrue: [ stream nextPutAll: aSymbol ]
			ifFalse: [ 
				aSymbol keywords withIndexDo: [ :keyword :index |
					stream 
						nextPutAll: keyword;
						nextPutAll: ' (';
						nextPutAll: (externalCollaborators at: index);
						nextPutAll: ') ' ]]]
					
	! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558636 overrides: 50555185!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor 
	
	(DenotativeObjectRenameCollaboratorApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553794!
testSample05
	| blockClosure materialized |
	blockClosure _ self bc05.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure value = materialized value.
	self assert: blockClosure value = materialized value.
	self assert: blockClosure value = materialized value.! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558943!
test03FindsRepetitionsBeforeSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (8 to: 9) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563122!
antepenultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 3 ifTrue: [ ^self at: size - 2 ].
	^aBlock value! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563246!
send: selector to: rcvr with: arguments super: superFlag 
	"Simulate the action of sending a message with selector arguments
	 to rcvr. The argument, superFlag, tells whether the receiver of the
	 message was specified with 'super' in the source method."

	^self send: selector
		to: rcvr
		with: arguments
		lookupIn: (superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: rcvr])! !
!PopUpMenu class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557040 overrides: 16903501!
confirm: queryString orCancel: cancelBlock
	"Put up a yes/no/cancel menu with caption aString. Answer true if  
	the response is yes, false if no. If cancel is chosen, evaluate  
	cancelBlock. This is a modal question--the user must respond yes or no."

	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"

	| menu choice |
	menu _ self labelArray: {'Yes'. 'No'. 'Cancel'} lines: #() icons: #(acceptIcon cancelIcon collapseIcon).
	choice _ menu startUpWithCaption: queryString.
	choice = 1 ifTrue: [^ true].
	choice = 2 ifTrue: [^ false].
	^ cancelBlock value! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554606 overrides: 16911810!
getMenu
	"Answer the menu for this view"

	menuGetter ifNil: [^ nil].
	(menuGetter is: #MessageSend) ifTrue: [
		^menuGetter value ].
	menuGetter numArgs = 0 ifTrue: [
		^ mainView perform: menuGetter ].
	^ self error: 'The menuGetter has an unsupported number of arguments'! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555585!
preenLocalIfNotNilArg
	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| varsToHide |
	varsToHide := Set new.
	self nodesDo:
		[:node| | variable |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not
		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:
			[node arguments last arguments isEmpty
				ifTrue: [node arguments last arguments: { variable }.
						varsToHide add: variable]
				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].
			 node receiver receiver: node receiver receiver value]].
	varsToHide notEmpty ifTrue:
		[self nodesDo:
			[:node|
			((node == self or: [node isBlockNode])
			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:
				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554305 overrides: 50569968!
assert: aBooleanOrBlock

	aBooleanOrBlock value ifFalse: [self error: 'Assertion failed']
			! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559128 overrides: 16920259!
ifNotNil: ifNotNilBlock ifNil: nilBlock 
	"If I got here, I am nil, so evaluate the block nilBlock"

	^ nilBlock value! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560813!
test09ProblemsCollectsTypeCheckersProblems

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker value.
	
	self assert: typeChecker problems notEmpty
! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559435!
at: index ifAbsentPut: block
	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"

	| v |
	index <= self size ifTrue: [
		^ (v _ self at: index)
			ifNotNil: [v]
			ifNil: [self at: index put: block value]
	].
	[self size < index] whileTrue: [self add: nil].
	^ self at: index put: block value! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563276!
declareNecessaryTemporaries

	temporariesToDeclareByInsertionPoint keysAndValuesDo: [:aSenderAndPosition :temporariesToDeclare |
		| sender positionToInsertTemporaries temporariesString |
		sender := aSenderAndPosition key.
		positionToInsertTemporaries := aSenderAndPosition value.
		temporariesString := temporariesToDeclare reduce: [:t1 : t2 | t1 value, ' ', t2 value].
		((sender methodNode parseNodesPathAt: positionToInsertTemporaries ifAbsent: 	[self shouldNotHappen ]) first key isTemporariesDeclaration)
			ifTrue: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: temporariesString, ' |'
				inMethod: sender.
			]
			ifFalse: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: '| ',  temporariesString, ' |', Character newLineCharacter asString, Character tab asString
				inMethod: sender
			]
	]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557921 overrides: 50533373!
remainderSimpleMeasure: aMeasure

	^self value remainderSimpleMeasure: aMeasure! !
!KeyboardEvent methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563007 overrides: 16896706!
sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (Preferences at: #classFinder) value ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559473!
readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = DoItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock value ]].
	
	self step.
	token := buffer contents.! !
!MethodVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558907!
methodWithParameterOfClassToRemove: p1

	| tempNotInRemoteVector tempInRemoteVector |
	
	tempNotInRemoteVector := p1.
	[ tempInRemoteVector := p1 ] value.
	
	^10! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555098 overrides: 50566954!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557176!
whileNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self value == nil] whileTrue: [ aBlock value ]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558496!
variableGetterBlockIn: aContext

	| temps tempIndex ivars |
	(self varNodeType = 4 and: [self key isVariableBinding]) ifTrue: [
		^[self key value]
	].
	aContext ifNil: [^nil].
	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].
	self varNodeType = 1 ifTrue: [
		ivars := aContext receiver class allInstVarNames.
		tempIndex := ivars indexOf: self name ifAbsent: [^nil].
		^[aContext receiver instVarAt: tempIndex]
	].
	self varNodeType = 2 ifTrue: [
		temps := aContext tempNames.
		tempIndex := temps indexOf: self name ifAbsent: [^nil].
		^[aContext tempAt: tempIndex]
	].
	^nil
! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560596!
valueIn: aMessageNode

	^(self new initializeToFindIn: aMessageNode) value! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555000 overrides: 16793616!
ifTrue: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually 
	reach here because the expression is compiled in-line."

	^alternativeBlock value! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555570!
testInlineBlockCollectionSD1
	| a1 b1 a2 b2 |
	b1 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a1 := i.
		b1 add: [a1]].
	b1 := b1 asArray collect: [:b | b value].
	b2 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a2 := i.
		b2 add: [a2]] yourself. "defeat optimization"
	b2 := b2 asArray collect: [:b | b value].
	self assert: b1 = b2! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560691!
encodeVariable: name sourceRange: range ifUnknown: action
	| varNode |
	varNode := scopeTable
					at: name
					ifAbsent: 
						[(self lookupInPools: name 
							ifFound: [:assoc | varNode := self global: assoc name: name])
							ifTrue: [varNode]
							ifFalse: [^action value]].
	range ifNotNil:
		[name first canBeGlobalVarInitial ifTrue:
			[globalSourceRanges addLast: { name. range. false }]].

	(varNode isTemp and: [varNode scope < 0]) ifTrue:
		[^OutOfScopeNotification signal
			ifTrue: [action value]
			ifFalse: [self notify: 'out of scope']].
	^varNode! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557373!
performWithIntegerWithFormula

	self assert: (1 perform: messageName with: formulaOfTenPesos) value = 
		(1 value perform: messageName with: formulaOfTenPesos value)! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557009!
completeSourceRangesOf: requestedParseNode ifAbsent: emptySourceRangesBlock
	"Returns the source ranges associated with the requested parse node."

	| completeSourceRanges |

	completeSourceRanges := Set new.

	"There may be more than one equivalent key in the complete source ranges map
	if more than one block declare a temporary variable with the same name - Fernando"
	self completeSourceRangesDo: [:parseNode :sourceRanges |
		(parseNode equivalentTo: requestedParseNode) ifTrue: [completeSourceRanges addAll: sourceRanges]].

	completeSourceRanges isEmpty ifFalse: [^completeSourceRanges ] ifTrue: [^emptySourceRangesBlock value].
	! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556111!
testBlockTemp
	| block block1 block2 |
	block := [ :arg | [ arg ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 value = 1.
	self assert: block2 value = 2! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560825!
blockExtentsInto: aDictionary from: initialPC to: endPC scanner: scanner numberer: numbererBlock
	"Support routine for startpcsToBlockExtents"
	| extentStart blockSizeOrLocator |
	self flag: 'belongs in DebuggerMethodMap'.
	extentStart := numbererBlock value.
	[scanner pc <= endPC] whileTrue:
		[blockSizeOrLocator := scanner interpretNextInstructionFor: BlockStartLocator new.
		 blockSizeOrLocator isInteger ifTrue:
			[self
				blockExtentsInto: aDictionary
				from: scanner pc
				to: scanner pc + blockSizeOrLocator - 1
				scanner: scanner
				numberer: numbererBlock]].
	aDictionary at: initialPC put: (extentStart to: numbererBlock value).
	^aDictionary! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563091!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].
			results _ choices ].
	^ results! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556718!
builderForIsKindOf: aMessageNode 
	
	^IsKindOfTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key value
		on: aMessageNode receiver receiver
		during: aMessageNode arguments first 
		rejectingDuring: aMessageNode arguments second! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557798!
multipleOcurrencesOfTheSameBlockNode
	
	[ 1 ] value.
	[ 1 ] value.! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558461!
commonSupertypeIfNoTypes: aBlock

	| types commonSupertypes commonSupertype |
	
	types := self types.
	types := types reject: [ :aType | aType = UndefinedObject ].
	types isEmpty ifTrue: [ ^aBlock value ].
	types size = 1 ifTrue: [ ^types anyOne ].
	
	"I have to convert types to Array becuase inst var types can be a Set - Hernan"
	commonSupertypes := self allSupertypesOf: types.
	commonSupertype := self commonLowestTypeIn: commonSupertypes.
	
	^commonSupertype ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558917 overrides: 50533222!
>= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(self value < aMagnitude) not! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559327!
builderForNotEqualOrNotIdenticalToClass: aMessageNode
	
	^EqualsTypeCastApplierBuilder 
		to: aMessageNode receiver arguments first key value
		on: aMessageNode receiver receiver receiver 
		during: aMessageNode arguments second 
		rejectingDuring: aMessageNode arguments first! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553681!
renameGlobal
	
	(RenameGlobalApplier on: self for: '') value! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560313 overrides: 16906481!
currentValueIn: aContext

	aContext ifNil: [^nil].
	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) value printString
	

! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560450 overrides: 16920241!
ifNil: aBlock
	"A convenient test, in conjunction with Object ifNil:"

	^ aBlock value! !
!True methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560638 overrides: 16793569!
and: aBlock1 and: aBlock2 and: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value and: [ aBlock3 value ]]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561543!
allActualImplementorsOf: aSelector forAll: types

	^(AllActualImplementors of: aSelector forAll: types) value! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557284!
restart
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: nil to: self].
	self privRefresh.
	ctxt := thisContext.
	[	ctxt := ctxt findNextUnwindContextUpTo: self.
		ctxt isNil
	] whileFalse: [
		(ctxt tempAt: 2) ifNil:[
			ctxt tempAt: 2 put: true.
			unwindBlock := ctxt tempAt: 1.
			thisContext terminateTo: ctxt.
			unwindBlock value].
	].
	thisContext terminateTo: self.
	self jump.
! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554536 overrides: 50501129!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^ Array with: key value class! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556394!
rangesForVariable: aName checkingType: nodeTypeCheckBlock ifAbsent: anAbsentBlock

	| variableNode |
	
	variableNode := scopeTable at: aName ifAbsent: [ ^anAbsentBlock value ].
	(nodeTypeCheckBlock value: variableNode) ifFalse: [ ^anAbsentBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: anAbsentBlock ! !
!CodeCoverageSourceCodeGenerator methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559774 overrides: 50568194!
visitAssignmentNode: anAssignmentNode

	"Add tracing to assignment nodes.
	I consider an assignment node covered when its right hand side is evaluated.
	
	Implemenation Details
	===============
	
	Note that I do not visit the variable node as doing so will replace it with a tracing message node, and message nodes cannot be used as the left hand side
	in assignments.
	
	This is totally fine. Visiting a node is useful when I don't know its type, but in this case only VariableNodes are accepted for the left hand side.

	The source code interval for the variable will be considered covered when the assignment is evaluated."

	anAssignmentNode
		variable: anAssignmentNode variable
		value: (anAssignmentNode value accept: self).	

	^ self
		parseNodeCoveringNodeWithDeclaration: anAssignmentNode variable
		whenExecuting: anAssignmentNode! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558131!
assert: anAction changes: aCondition 

	| after before |
	
	before := aCondition value.
	anAction value.
	after := aCondition value.
	
	self deny: after = before! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558759!
assertValues: anArray
	| values |
	values := collection collect: [ :each | each value ].
	self 
		assert: anArray asArray = values asArray
		description: 'Expected: ' , anArray asArray printString , 
			', but got ' , values asArray printString! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558838!
pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 	
		self sysPreferences at: aPref put: enabled]! !
!Time class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562608!
microsecondsToRun: timedBlock 
	"Answer the number of microseconds timedBlock takes to return its value."

	| initialMicroseconds |
	initialMicroseconds _ self localMicrosecondClock.
	timedBlock value.
	^self localMicrosecondClock - initialMicroseconds! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560946!
identityIndexOf: anElement ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	1 to: self size do:
		[:i | (self at: i) == anElement ifTrue: [^ i]].
	^ exceptionBlock value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50561501 overrides: 50533210!
< aMagnitude

	^self value < aMagnitude! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560050!
m1: p1
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] value. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] value. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558103!
copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString value
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554074!
removeKey: aString ifAbsent: aBlock characterIndex: i

	| child answer |
	child _ self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	answer _ child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.
	child isEmpty ifTrue: [
		self removeChildFor: aString characterIndex: i.
		"If child is not needed anymore, compress the path"	
		children class == TrieNode ifTrue: [
			someKey _ children getSomeKey.
			segmentSize _ segmentSize + children getSegmentSize.
			childrenFirstChars _ children getChildrenFirstChars.
			children _ children getChildren ]].
	^answer! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554222!
replaceIvarWithNilIfNullObject

	replacementParameters do: [:replacementParameter | | refactoredSource  finder methodNode |
		methodNode := replacementParameter methodNode.
		finder := ArgumentsAndReturnsFinder in: methodNode for: instVar.
		finder value.	
		refactoredSource := replacementParameter methodSourceCode copyReplacing: finder ranges with: instVar, ' nilIfNullObject'.
		methodNode methodClass compile: refactoredSource]! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563143!
evaluate: textOrStream in: aContext to: aReceiver notifying: aRequestor ifFail: failBlock logged: doLog profiled: doProfile
	"Compiles the sourceStream into a parse tree, then generates code into
	 a method. If aContext is not nil, the text can refer to temporaries in that
	 context (the Debugger uses this). If aRequestor is not nil, then it will receive
	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 
	 compiled method is invoked from here via withArgs:executeMethod:, hence
	 the system no longer creates Doit method litter on errors."

	| methodNode method |
	
	class _ (aReceiver ifNotNil: [ aReceiver ] ifNil: [ aContext ifNotNil: [ :c | c receiver ]]) class.
	methodNode _ self compileNoPattern: textOrStream in: class context: aContext notifying: aRequestor ifFail: [^failBlock value].
	method _ methodNode generate.
	"I'm not keeping the source nor the methodNode for back compabibility. 
	The SmalltalkEditor sends the message #evaluateMethod:... which already keep the method node
	 for the debugger to show the right source code - Hernan"
	^self evaluateMethod: method to: aReceiver logged: doLog profiled: doProfile! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557644!
withTemporaryValue: temporaryValue of: aPreferenceName do: aBlock
	"Allows to execute a piece of code with a temporary value of the given preference. Useful for testing purposes."
	
	| currentValue |
	currentValue := self at: aPreferenceName.
	self at: aPreferenceName put: temporaryValue.
	[ aBlock value ] ensure: [ self at: aPreferenceName put: currentValue ]! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553784!
triggerEvent: anEventSelector
	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."

	^(self actionForEvent: anEventSelector) value! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563135!
at: aString ifAbsent: aBlock

	rootNode ifNil: [ ^aBlock value ].
	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50559976!
average: aBlock ifEmpty: emptyBlock 
	
	^ (self sum: aBlock ifEmpty: [ ^emptyBlock value ]) / self size! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556247!
should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: anExpectedErrorMessageCreator

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException | self assert: anExpectedErrorMessageCreator value equals: anException messageText ]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50554570!
performWithCompoundMeasureWithFormula

	self assert: ((self tenDollars + self tenPesos) perform: messageName with: formulaOfTenPesos) value = 
		((self tenDollars + self tenPesos) value perform: messageName with:formulaOfTenPesos value )! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555081!
castWithBlockInRejectBlock

	nil ifNotNil: [ :temp1 | [ temp1 mod: 5 ] value ]! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555835!
startAndEndNodesShareAParentNode  

	| parseNodesInCommon |
	parseNodesInCommon _ self parseNodesInCommon.
	
	^ parseNodesInCommon notEmpty and: [
		(self trimmed: parseNodesInCommon first value) = intervalToExtract]


! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557855!
rawTypesOf: aVariableName mappingToIndexWith: variableNameToIndexMapping into: anArrayOfRawTypes ifAbsent: anAbsentBlock

	| variableIndex |
	
	variableNameToIndexMapping ifNil: [ ^anAbsentBlock value ].
	variableIndex := variableNameToIndexMapping at: aVariableName ifAbsent: [ ^anAbsentBlock value ].
	
	^anArrayOfRawTypes at: variableIndex! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557511!
keysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding
			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma value]
			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562051 overrides: 50533319!
multiplyCompoundMeasure: aMeasureBag

	^self value multiplyCompoundMeasure: aMeasureBag! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560288!
blockWithTemporariesDeclaration
	
	[ | a | ] value! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50555630!
returnFromClosure: aValue

	[ ^aValue ] value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563977 overrides: 50553066!
transactionAmount

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super value! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50553809!
declareTemporaries: temporariesToDeclare in: aMethodOrBlockNode of: aSenderMethod

	| positionToInsertNewVariablesDeclarations renamedTemporaries temporariesToDeclareInPosition|

	renamedTemporaries := self renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod.

	aMethodOrBlockNode hasTemporaryVariables
		ifTrue: [
			positionToInsertNewVariablesDeclarations := (aSenderMethod methodNode
				singleCompleteSourceRangeOf: (aMethodOrBlockNode temporariesDeclaration)) last.
		]
		ifFalse: [
			| firstStatementRange |
			firstStatementRange := aSenderMethod methodNode singleCompleteSourceRangeOf: (aMethodOrBlockNode statements first).
			positionToInsertNewVariablesDeclarations := firstStatementRange first.
		].
	temporariesToDeclareInPosition := self temporariesToDeclareByInsertionPoint: (aSenderMethod -> positionToInsertNewVariablesDeclarations).
	temporariesToDeclareInPosition addAll: (renamedTemporaries collect: [:aReplacementAssociation | aReplacementAssociation value]).
	^renamedTemporaries.
	! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557208!
sourceCodeIfAbsent: aBlock

	| actualClass |

	actualClass := self actualClassIfAbsent: [ ^aBlock value ].
	^actualClass sourceCodeAt: methodSymbol ifAbsent: aBlock! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556961!
nodeToExtractFrom: methodNode at: trimmedIntervalToReplace or: intervalToReplace
	
	| nodeWithRangeToExtract nodesWithFirstPosition |
	
	nodesWithFirstPosition := methodNode parseNodesPathAt: trimmedIntervalToReplace first ifAbsent: [ self signalInvalidSelection ].
	nodeWithRangeToExtract := nodesWithFirstPosition 
		detect: [ :nodeAndRange | self is: nodeAndRange value equalTo: trimmedIntervalToReplace or: intervalToReplace ]
		ifNone: [ self signalInvalidSelection ].
	 
	^nodeWithRangeToExtract key.
	! !
!TestResultWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50558427!
runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgressiveTestRunner for: suite) value.
	! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50557998 overrides: 16822897!
= aBag
	"Two bags are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same size.
	 (c) each element occurs the same number of times in both of them".

	self == aBag ifTrue: [ ^ true ].		"Any object is equal to itself"
	(aBag is: #Bag) ifFalse: [ ^ false ].
	self size = aBag size ifFalse: [ ^ false ].
	contents associationsDo: [ :assoc |
		(aBag occurrencesOf: assoc key) = assoc value
			ifFalse: [ ^ false ]].
	^true! !
!Bag methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560723!
sortedCounts
	"Answer with a collection of counts with elements, sorted by decreasing count."
	| counts |
	counts _ SortedCollection sortBlock: [:x :y | x >= y].
	contents associationsDo:
		[:assn |
		counts add: (Association key: assn value value: assn key)].
	^ counts! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50562437!
storeLiteral: aCodeLiteral on: aStream
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"
	| key value |
	(aCodeLiteral isVariableBinding)
		ifFalse:
			[aCodeLiteral storeOn: aStream.
			 ^self].
	key _ aCodeLiteral key.
	(key isNil and: [(value _ aCodeLiteral value) isMemberOf: Metaclass])
		ifTrue:
			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.
			 ^self].
	(key isSymbol and: [(self bindingOf: key) notNil])
		ifTrue:
			[aStream nextPutAll: '##'; nextPutAll: key.
			 ^self].
	aCodeLiteral storeOn: aStream! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50560496!
runDenotativeObjectMessageCategoryTests

	selectedMessageCategory ifNotNil: [ | classlessObject suite |
		classlessObject := (Smalltalk classNamed: selectedClassName) class.
		suite := TestSuite named: 'Tests of ', selectedMessageCategory.
		(metaClassOrganizer listAtCategoryNamed: selectedMessageCategory) do: [ :selector |
			(self isTest: selector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: classlessObject>>selector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) value ]

	! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50563571!
lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	self lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex do: [ :index | ^index ].
	^exceptionBlock value.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:03' prior: 50556487!
recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	"An array of the 255 Characters in ascii order.
	 Cog inlines table into machine code at: prim so do not regenerate it."
"	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character numericValue: ascii])."
" 	 This is nil in Spur, which has immediate Characters."
	newArray at: 25 put: (self specialObjectsArray at: 25).
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	"An array of up to 31 classes whose instances will have compact headers; an empty array in Spur"
	newArray at: 29 put: self compactClassesArray.
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Prototype instances that can be copied for fast initialization"
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
"	newArray at: 32 put: Float new.
	newArray at: 33 put: (LargePositiveInteger new: 4).
	newArray at: 34 put: Point new."
	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.

	"Note: This must be fixed once we start using context prototypes (yeah, right)"
	"(MethodContext new: CompiledMethod fullFrameSize)."
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"
	newArray at: 36 put: nil. "was the prototype MethodContext"

	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Weak reference finalization"
	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray
	! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558646!
test43ExtractsRepetitionsOnMoreThanOneMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder value.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 'm1 self m2' equals: (classToRefactor >> #m1) sourceCode.
	self assert: 'm1b 100+self m2' equals: (classToRefactor >> #m1b) sourceCode.
	! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554936!
testValueWithAnotherGraph

	"Example from: http://www.cs.fsu.edu/~cop4531/slideshow/chapter23/23-4.html"

	| graph result |

	graph :=
		Graph
			edges: (
				OrderedCollection new
					add: (Edge from: 'undershorts' to: 'pants');
					add: (Edge from: 'undershorts' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'belt');
					add: (Edge from: 'socks' to: 'shoes');
					add: (Edge from: 'shirt' to: 'belt');
					add: (Edge from: 'shirt' to: 'tie');
					add: (Edge from: 'tie' to: 'jacket');
					yourself)
			nodes: (
				Set new
					add: 'undershorts';
					add: 'pants';
					add: 'shoes';
					add: 'belt';
					add: 'shirt';
					add: 'tie';
					add: 'jacket';
					add: 'watch';
					add: 'socks';
					yourself).

	result := ((TopologicalSort for: graph) value) asArray.

	self
		assert: (result indexOf: 'undershorts') < (result indexOf: 'pants');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'belt');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'jacket');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'shoes');
		assert: (result indexOf: 'shirt') < (result indexOf: 'belt');
		assert: (result indexOf: 'shirt') < (result indexOf: 'tie');
		assert: (result indexOf: 'shirt') < (result indexOf: 'jacket');
		assert: (result indexOf: 'pants') < (result indexOf: 'shoes')! !
!Object methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560546!
retryWithGC: execBlock until: testBlock
	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."
	| blockValue |
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock value.! !
!InlineMethod class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563882!
assertSenders: aCollectionOfSenders belongToClassOf: aCompiledMethod ifFalse: ifFalseBlock

	(aCollectionOfSenders allSatisfy: [:aSender | self sender: aSender belongsToClassOf: aCompiledMethod])
		ifFalse: [^ifFalseBlock value].! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563872!
printReducedTypesOf: aVarName ifAbsent: anAbsentBlock

	| typeInfo |
	
	typeInfo := self typeInfoOf: aVarName ifAbsent: [ ^anAbsentBlock value ].
	
	^typeInfo printReducedTypes ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558567 overrides: 50533155!
sameDomainAs: aMeasure

	^self value sameDomainAs: aMeasure! !
!Switch methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561434!
doAction: anAction 
	"Execute anAction if it is non-nil."

	anAction
		ifNotNil: [anAction value]! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561800!
methodWithCopiedAndPostClosedOverAssignedTemps
	| blk a b c r1 r2 |
	a := 1.
	b := 2.
	c := 4.
	blk := [a + b + c].
	r1 := blk value.
	b := nil.
	r2 := blk value.
	r1 -> r2

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!Integer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554156!
ifMultipleOf2And5Do: aBlock otherwise: anotherBlock
	"If our prime factorization consists only of 2's and 5's, evaluate aBlock with the exponents.
	Otherwise evaluate anotherBlock.
	Be fast!!"

	| exponent2 exponent5 without2Factors |
	exponent2 _ self lowBit-1.
	without2Factors _ self bitShift: exponent2 negated.
	exponent5 _ ( 0.430676558073393 "2 ln / 5 ln" * without2Factors highBit) truncated.
	(5 raisedToInteger: exponent5) = without2Factors
		ifTrue: [
			aBlock value: exponent2 value: exponent5 ]
		ifFalse: [
			anotherBlock value ]! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558489 overrides: 50571052!
runTestSuite: aTestSuite

	(DenotativeObjectProgessiveTestRunner for: aTestSuite) value

	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563719!
printToDoOn: aStream indent: level

	| limitNode |
	self printReceiver: receiver on: aStream indent: level.

	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode := arguments first]
		ifFalse: [limitNode := arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555886!
generateReport
	
	| compiledMethodReports |
	compiledMethodReports := coverageReportBuilders collect: [ :reportBuilder | reportBuilder value ].
	
	report := CodeCoverageAnalyzerReport withAll: compiledMethodReports.
	! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561285!
restoreAfter: aBlock
	"
	- Evaluate the block
	- Update host OS Display
	- Wait for a mouse click
	- And then restore the Morphic World"

	aBlock value.
	self forceToScreen.
	Sensor waitButton.
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560406!
performWithFormulaWithMeasure

	self assert: (formulaOfTenPesos perform: messageName with: self twentyPesos) value = 
		(formulaOfTenPesos value perform: messageName with: self twentyPesos value)! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555088 overrides: 50533226!
between: min and: max
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(min <= self value) and: [self value <= max]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562173!
ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode
	"If a remoteTempNode has been added ensure a statement exists to initialize it."
	remoteTempNode ~~ nil ifTrue:
		[(statements notEmpty
		  and: [statements first isAssignmentNode
		  and: [statements first variable isTemp
		  and: [statements first variable isIndirectTempVector]]])
			ifTrue: "If this is a decompiled tree, or if a temporary has been added later in
					the analysis then there already is a temp vector initialization node."
				[(statements first variable ~~ remoteTempNode) ifTrue:
					[statements first variable become: remoteTempNode].
				 statements first value numElements: remoteTempNode remoteTemps size]
			ifFalse:
				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556087!
sourceCodeAt: selector ifAbsent: aBlock

	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556361 overrides: 50568388!
renameClassOn: aBrowser for: aClassToRefactor

	(DenotativeObjectRenameApplier for: aClassToRefactor) value ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559843 overrides: 50533192!
ceiling
	
	^self value ceiling ! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554522 overrides: 50556026!
indexOf: anInteger startingAt: start ifAbsent: aBlock

	| ans |
	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	ans _ String indexOfByte: anInteger inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557933!
autoCompleterDocumentationAppendingToParameter: aParameterAppendBlock toReturn: aReturnAppendBlock
	
	"This message is sent either by the dynamic typing or live typing auto complete. If you do not have 
	live typing installed you will see one sender, do not refactor it!! - Hernan"
	
	| methodNode text |
 
	text := self receiverTextAutoCompleterDocumentation.
	
	methodNode := self methodNode.
	text := self selectorAutoCompleterDocumentationAppendingTo: text using: methodNode appendingToParameter: aParameterAppendBlock.
	text := text append: aReturnAppendBlock value.
	text := self commentAutoCompleterDocumentationAppendigTo: text using: methodNode.
			
	^text! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554336!
test15HasErrorsOrWarnings

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker value.
	
	self assert: typeChecker hasErrorsOrWarnings ! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558573!
valuesDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [:association | aBlock value: association value]! !
!WeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558861!
at: key ifAbsentOrNilPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsentOrNil: [self at: key put: aBlock value]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559206!
at: key ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."

	| assoc |
	assoc _ array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock value ].
	^ assoc value! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556769!
multipleEmptyBlocks
	
	[ 1 ] value.
	[ 2 ] value.! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554822 overrides: 50573314!
at: key ifAbsent: aBlock

	| index |
	index _ self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock value ].
	^ array at: index! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559863!
blockWithReadTemporaryVariable

	[ |a| a ] value! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559536!
sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs _ messageList collect: [ :aRef |
		aDate _ aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSubmitted]
			ifFalse: [
				aCompiledMethod _ aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder _ assocs asArray sort: [ :a :b | a value < b value].

	inOrder do: [ :each | each key prefixStringVersionWith: each value yyyymmdd ].
	messageList _ inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563264!
messageListForChangesWhich: aBlock ifNone: ifEmptyBlock

	| answer |

	answer _ self changedMessageListAugmented select: [ :each |
		aBlock value: each actualClass value: each methodSymbol
	].
	answer isEmpty ifTrue: [^ifEmptyBlock value].
	^answer
! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562838!
dumpPigStackOn: aStream
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process stack suspendedContext |
	promise _ Processor tallyCPUUsageFor: 1 every: 10.
	tally _ promise value.
	process _ tally sortedCounts first value.
	"Avoid, if possible, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		(process == Processor backgroundProcess or: [process isTerminated])
			ifTrue: [ process _ entry value ]].
	"UISupervisor whenUIinSafeState: [self dumpTallyOnTranscript: tally]."
	aStream nextPutAll: '====Al processes===='; newLine.
	self dumpTally: tally on: aStream.
	aStream newLine; nextPutAll: '====Process using most CPU===='; newLine.
	(100.0 * (tally occurrencesOf: process) / tally size) rounded printOn: aStream.
	aStream
		nextPutAll: ' % ';
		nextPutAll: (process browserPrintStringFull: false);
		newLine.
	stack _ process == Processor activeProcess
		ifTrue: [thisContext stackOfSize: Debugger defaultDebugStackSize]
		ifFalse: [
			suspendedContext _ process suspendedContext.
			suspendedContext
				ifNotNil: [suspendedContext stackOfSize: Debugger defaultDebugStackSize]].
	stack 
		ifNil: [ aStream nextPutAll: 'No context'; newLine]
		ifNotNil: [
			stack do: [ :c | 
				c printOn: aStream.
				aStream newLine ]].
	^process! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561721!
renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) value! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559003!
removeInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveInstanceVariableApplier on: model for: aClass) value ].! !
!ExtractMethodReplacementsWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562821!
closeAfter: aBlock

	aBlock value.
	self whenUIinSafeState: [ self delete ].
	! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557636!
pushUpInstanceVariable

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushUpInstanceVariableApplier on: model at: aClass ) value].! !
!FinderMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561781!
toolbarButtonFor: aCatalog

	^ (PluggableButtonMorph
		model: (CatalogButton for: aCatalog model: model)
		stateGetter: #isSelected
		action: #value
		label: aCatalog name)
		color: Color veryLightGray; 
		yourself! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558372!
hasLiteralThorough: literal
	"Answer true if any literal in these properties is literal,
	 even if embedded in array structure."
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [propertyOrPragma key == literal
					or: [propertyOrPragma value == literal
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteral: literal]]]]
			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:
			[^true]].
	^false! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554041 overrides: 50533207!
truncated
	
	^self value truncated
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561208!
notInclusiveBetween: min and: max
	"Create local variable #val for best performance"

	| val |

	val := self value.
	^val > min and: [val <= max]! !
!ContentPack class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554842!
encodeContentFrom: aDictionary

	| encodedTree |
	
	encodedTree _ Dictionary new.
	
	aDictionary associations
		do: [ :assoc |
			assoc value class == Dictionary
				ifTrue: [ 
					encodedTree 
						at: assoc key 
						put: (self encodeContentFrom: assoc value) 
				]
				ifFalse: [ 
					encodedTree 
						at: assoc key
						put: count.
					count _ count + 1.
					payload add: assoc value storeString asByteArray base64Encoded
				]
		].

	^ encodedTree associations collect: [ :assoc | 
		{ assoc key . assoc value }
	]! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560372!
critical: aBlock
	"Critical section.
	Executes aBlock as a critical section. At any time, only one process can be executing code 
	in a critical section.
	NOTE: All the following synchronization operations are only valid inside the critical section 
	of the monitor!!"

	^[
	self enter.
	aBlock value]
		ensure: [self exit].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555146!
topBlockTempsMap
	
	self blockExtentsToTempsMap associationsDo: [ :anAssociation | anAssociation key first = 0 ifTrue: [ ^anAssociation value ]].
	
	self error: 'Should not happen, there is always a topContext'! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562414!
classOfLocalBindingNamed: aName in: aClass 
	
	^  (aClass localBindingOf: aName) ifNotNil: [ :aBinding | aBinding value class ]! !
!LookupKey methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560469!
beBindingOfType: aClass announcing: aBool
	"Make the receiver a global binding of the given type"
	| old new |
	(Smalltalk associationAt: self key) == self
		ifFalse:[^self error:'Not a global variable binding'].
	self class == aClass ifTrue:[^self].
	old _ self.
	new _ aClass key: self key value: self value.
	old become: new.
	"NOTE: Now self == read-only (e.g., the new binding)"
	^self recompileBindingsAnnouncing: aBool! !
!StepMessage methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555479 overrides: 50568704!
valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast answer |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	[
		arguments
			ifNil: [ answer _ receiver perform: selector with: millisecondsSinceLast]
			ifNotNil: [ answer _ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]
	] ifError: [ :err :rcvr |
		receiver stopStepping.
		{ 'Error while stepping: '. self. rcvr. err } print.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	].
	^answer! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558161!
assertReceiverTypesOfAll: aCollectionOfSenders areIncludedInAllTypesOf: aCollectionOfImplementors

	| messageSendsWithInvalidReceiverTypes | 
	
	messageSendsWithInvalidReceiverTypes := (ReceiverTypesOfMessageSendsConform 
		from: aCollectionOfSenders to: aCollectionOfImplementors) value.
	messageSendsWithInvalidReceiverTypes ifNotEmpty: [ 
		self signalReceiverTypesNotIncludedInImplementorTypes: messageSendsWithInvalidReceiverTypes ].! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563765!
pushDownSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushDownMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) value ].! !
!Association methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561943 overrides: 16881493!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' -> ';
		print: self value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554102 overrides: 50533291!
divideSimpleMeasure: aMeasure

	^self value divideSimpleMeasure: aMeasure! !
!UniFileStream class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559282!
retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt _ self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock value.! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554007!
test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker value.
	
	typeChecker warningsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].
	
	self fail

	! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555195!
valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog tag |

	aDuration <= `Duration zero` ifTrue: [^ timeoutBlock value ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.
	tag := self.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | 
			e tag == tag 
				ifTrue:[ timeoutBlock value ]
				ifFalse:[ e pass]].! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558748!
test13HasErrorsReturnsFalseWhenNoErrorFound

	| typeChecker |
	
	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker value.
	
	self deny: typeChecker hasErrors ! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556121!
test06FindsRepetitionsInOtherClassMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: sourceMethod ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562778!
sourceCodeOfImplementorStatement: aStatementToInline withReplacements: replacementsDict removingReturn: removeReturn

	| sourceRange originalSourceCode statementReplacements implementorSourceCode |

	implementorSourceCode := methodToInline sourceCode.
	sourceRange := (self findRangesOf: aStatementToInline in: implementorCompleteSourceRanges) anyOne
		asSourceCodeInterval expandUntilStatementEndOn: implementorSourceCode.
	originalSourceCode := implementorSourceCode copyFrom: sourceRange first to: sourceRange last.
	"Replacements must be adjusted because the statement string begins at index 1 instead of the
	original position on the source code"
	statementReplacements := ((replacementsDict associations select: [:anAssociation | sourceRange includesAllOf: (anAssociation key)])
		collect: [:anAssociation | ((anAssociation key first - sourceRange first + 1) to: (anAssociation key last - sourceRange first + 1)) -> anAssociation value])
		asSortedCollection: [ :left :right | left key first < right key first ].

	"Remove the return character if present"
	(removeReturn and: [aStatementToInline isReturn]) ifTrue: [statementReplacements add: (1 to: 1) -> ''].
	^(originalSourceCode copyReplacing: statementReplacements).! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556026!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	start to: self size do:
		[:i | (self at: i) = anElement ifTrue: [^ i]].
	^ exceptionBlock value! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557490!
m05_only_temp_in_remote_vector

	| t1 |
	
	[ t1 := 10 ] value.
	
	^t1! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558712 overrides: 50496276!
typeInfoOf: aVarName ifAbsent: anAbsentBlock

	| rawTypes |
	
	rawTypes := methodProperties rawTypesOf: aVarName ifAbsent: [ ^anAbsentBlock value ].
	
	^method methodClass createMethodVariableTypeInfoOf: aVarName in: method are: rawTypes ! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563534 overrides: 50497572!
warningsDetect: aCondition ifNone: noneBlock

	| warning |
	
	typeCheckers do: [ :typeChecker |
		warning := typeChecker warningsDetect: aCondition ifNone: [ nil ].
		warning ifNotNil: [ ^warning ]].
	
	^noneBlock value! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556040!
propertyValueAt: propName ifAbsent: aBlock
	
	^self withPropertiesDo: [ :properties | properties propertyValueAt: propName ifAbsent: aBlock ] ifSelector: [ :selector | aBlock value ]
	! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557912!
isTrue: aBooleanOrBlock description: aFailureDescription
 
	aBooleanOrBlock value ifFalse: [ self signalFailure: aFailureDescription ]
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553993 overrides: 16901772!
= anObject

	^self value = anObject value! !
!Trie methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561297!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock value]! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555372!
finalizeValues
	"Some of our elements may have gone away. Look for those and activate the associated executors."
	| finiObjects |
	finiObjects _ nil.
	"First collect the objects."
	self protected:[
		valueDictionary associationsDo:[:assoc|
			assoc key ifNil: [
				finiObjects 
					ifNil: [ finiObjects := OrderedCollection with: assoc value]
					ifNotNil: [ finiObjects add: assoc value]]
		].
		finiObjects ifNotNil: [ valueDictionary finalizeValues: finiObjects asArray].
	].
	"Then do the finalization"
	finiObjects ifNotNil: [
		finiObjects do:[:each| each finalize]]! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561247!
protected: aBlock
	"Execute aBlock protected by the accessLock"
	^accessLock
		ifNil: [ aBlock value]
		ifNotNil: [ accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !
!NewTemporaryPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555064!
valueFor: aNewTemporaryVariableName in: aBlockNode of: aMethodNode

	^ (self for: aNewTemporaryVariableName in: aBlockNode of: aMethodNode) value! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559458!
whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock

	^aNoneBlock value! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557836!
runDeferredUIMessages
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	| readyToProcess |
	readyToProcess _ deferredUIMessages size.
	readyToProcess timesRepeat: [
		UISupervisor isUIProcessRunning ifFalse: [ ^self ].
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block value ]].! !
!CompiledMethodCoverageReportBuilder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556370 overrides: 50565857!
coverAll: sourceRanges evaluating: aBlock
	
	"Register that the evaluation of aBlock covered sourceRanges"
	
	^ [ | result |
		result _ aBlock value.
		self coverAll: sourceRanges by: result ]
	   ifCurtailed: [ self coverAsNonBooleanAll: sourceRanges ] ! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554135 overrides: 50569113!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectSafelyRemoveApplier on: self of: aBehavior theNonMetaClass) value ].
	
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556280!
unitNameFor: aNumber

	^self value unitNameFor: aNumber! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562423 overrides: 16823722!
remove: oldObject ifAbsent: exceptionBlock
	"Remove oldObject as one of the receiver's elements."
	| removedObject |
	oldObject ifNil: [ ^oldObject].
	self protected: [
		removedObject := valueDictionary removeKey: oldObject ifAbsent: nil.
	].
	^removedObject
		ifNil: [ exceptionBlock value]
		ifNotNil: [ removedObject]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555117!
test028_DoesNotCoverSuper

	"TODO: Don't cover the super receiver in message sends for now, as it has to be handled separately. NPM"
	
	self collectCoverageForExampleNamed: #value.
	
	self assertNumberOfCoveredRangesFor: #value is: 1 .
	self assert: #value hasBeenCoveredFrom: 381 to: 385 as: 'value'.! !
!FileIOAccessor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557721!
deleteFile: fullPathName ifAbsent: failBlock 
	^(self
			try: [self primDeleteFileNamed: fullPathName asUtf8Bytes]
			forFileNamed: fullPathName) 
		ifFalse: [^ failBlock value]! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559465!
m1_temps_not_in_block_read_write_temp

	| n1 n2 t1 |
	
	t1 := 1.
	[t1 := t1 + 1 ] value.
	
	n1 := n2 := 2.
	n1 := n1 + n2.

	^t1! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558848 overrides: 50533438!
composeWithNumber: aMeasure

	^self value composeWithNumber: aMeasure! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562958!
testBlockArgument
	| block block1 block2 |
	block := [ :arg | | temp | temp := arg. [ temp ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 value = 1.
	self assert: block2 value = 2! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558618!
runDenotativeObjectTests

	self selectedClassOrMetaClass ifNotNil: [ :aDenotativeObject | | suite |
		suite := TestSuite named: 'Tests of ', aDenotativeObject soleInstance name asString.
		aDenotativeObject selectors do: [ :aSelector |
			(self isTest: aSelector) ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aDenotativeObject>>aSelector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) value ]

	! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557034 overrides: 16901507!
at: symbolName
	^ (self instanceAt: symbolName) value! !
!VariableScopeFinder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561086 overrides: 50568194!
visitAssignmentNode: anAssignmentNode
	"Answer the minimum enclosing node for aVariabe or nil if none.
	 If the variable is accessed in more than one subexpression then anAssignmentNode
	 is the enclosing node, otherwise it is which ever single node that includes it, if any."
	^self
		enclosingNodeFor: [:aBlock|
							aBlock
								value: anAssignmentNode value;
								value: anAssignmentNode variable]
		of: anAssignmentNode! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555788!
test02FindsRepetitionsAfterSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self deny: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556185!
keyForIdentity: anObject
	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"

	self associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].
	^ nil! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560114!
performWithFormulaWithCompoundMeasure

	self assert: (formulaOfTenPesos perform: messageName with: (self tenDollars + self tenPesos)) value = 
		(formulaOfTenPesos value perform: messageName with: (self tenDollars + self tenPesos) value)! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560354!
assert: anAction changes: aCondition from: anInitialObject to: aFinalObject 

	| after before |
	
	before := aCondition value.
	anAction value.
	after := aCondition value.
	
	self assert: before equals: anInitialObject.
	self assert: after equals: aFinalObject! !
!DenotativeObjectBrowserWindow class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553924!
browseReferencesTo: anAssociation

	| references label |

	references := self sendersOf: anAssociation.

	label := 'References to ' , anAssociation value name.
	references isEmpty ifTrue: [^ (PopUpMenu labels: ' OK ') startUpWithCaption: 'There are no ' , label ].

	label := '[', references size printString, '] ', label.

	DenotativeObjectMessageSetWindow
		openMessageList: references asArray sort
		label: label
		autoSelect: anAssociation value name.! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560674!
parentIfNone: aBlock

	superclass = DenotativeObject ifTrue: [ ^aBlock value ].
	
	^ superclass ! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555690 overrides: 50570106!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value == (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554421 overrides: 50533299!
moduloCompoundMeasure: aMeasureBag

	^self value moduloCompoundMeasure: aMeasureBag! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557062 overrides: 16906201!
printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562529!
pushUpSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushUpMethodApplier on: model for: model selectedClassOrMetaClass>>selectedSelector) value ].! !
!Class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561949!
classVarValueOf: varNameSymbol

	^(self classPool bindingOf: varNameSymbol) ifNotNil: [:binding | binding value ]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554872!
positionsForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock value ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556050!
typeCheckCategory

	| typeChecker |
	
	selectedSystemCategory ifNotNil: [ 
		typeChecker := ManyMethodsTypeChecker forAllClasses: (systemOrganizer allClassesAt: selectedSystemCategory).
		typeChecker value.
		typeChecker showResultsWith: selectedSystemCategory name ]
	
	! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557441!
bench
	"See how many times I can value in 5 seconds.  I'll answer a meaningful description.
	[ Float pi printString ] bench print.
	[ 80000 factorial printString ] bench print.
	"

	| secondsPerRun startTime endTime count run |
	count _ 0.
	run _ true.
	[ (Delay forSeconds: 5) wait. run _ false ] forkAt: Processor timingPriority - 1.
	startTime _ Time localMillisecondClock.
	[ run ] whileTrue: [ self value. count _ count + 1 ].
	endTime _ Time localMillisecondClock.
	secondsPerRun _ (endTime - startTime) / (count * 1000).
	secondsPerRun >= 1
		ifTrue: [
			secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' seconds per run']]
			]
		ifFalse: [
			1.0 / secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' runs per second' ]]
			]! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553962 overrides: 16935088!
remove: oldObject ifAbsent: absentBlock

	firstIndex to: lastIndex do: [ :index |
		oldObject = (array at: index)
			ifTrue: [
				self removeIndex: index.
				^ oldObject ]].
	^ absentBlock value! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561746!
valueParameter: aBlock

	aBlock value.
	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560012!
profile: aBlock
	"Make a virtual machine profile of the given block."
	"Note: Profiling support is provided so that VM implementors
	 can better understand and improve the efficiency of the virtual
	 machine. To use it, you must be running a version of the
	 virtual machine compiled with profiling enabled (which
	 makes it much slower than normal even when not profiling).
	 You will also need the CodeWarrior profile reader application."

	self stopProfiling.
	self clearProfile.
	self startProfiling.
	aBlock value.
	self stopProfiling.
	self dumpProfile.! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556999!
rangesForLiteralNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litSet at: aName ifAbsent: [ ^aBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562018!
isAssignmentToNil: aNode

	^aNode isAssignmentNode and: [(aNode value isNilPseudoVariable) and: [aNode variable name =  instVar]].! !
!MenuMorph methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554121!
displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		self world ifNotNil: [ w displayWorld ].  "show myself"
		].
	aBlock value.
	self delete! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563207!
testSample02
	| blockClosure materialized |
	blockClosure _ self bc02.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure value = materialized value.! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558803!
prompt: aPrompt ifNone: aNoneBlock

	| selectedCategoryIndex categoryName |
	
	selectedCategoryIndex := self promptCategory: aPrompt.
	selectedCategoryIndex = 0 ifTrue: [^ aNoneBlock value].
	
	categoryName := selectedCategoryIndex = 1 ifTrue: [ self requestNewCategory ] ifFalse: [ categories at: selectedCategoryIndex ].
	categoryName isEmpty ifTrue: [ ^aNoneBlock value ].
	
	^categoryName
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555185!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559153 overrides: 50533200!
negated
	
	^self value negated! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554177!
untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock value ]]! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555174 overrides: 50365979!
nextPutAll: aCollection

	position + aCollection size > limit ifTrue: [
		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).
		limitBlock value.
		^self
	].
	super nextPutAll: aCollection.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562914 overrides: 50533433!
composeWith: aMeasure

	^self value composeWith: aMeasure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556918 overrides: 50533348!
remFrom: aNumber

	^self value remFrom: aNumber
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559305!
runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgressiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560071!
insertSuperclass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(InsertSuperclassApplier on: self for: aBehavior theNonMetaClass) value ].! !
!NewClassPrecondition class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559698!
valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^(self for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary) value! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558150!
packageOfMethod: aMethodReference ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock value ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodReference: aMethodReference]
		ifNone: errorBlock! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558731 overrides: 50533378!
subtractFrom: aNumber

	^self value subtractFrom: aNumber! !
!Time class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555246!
millisecondsToRun: timedBlock 
	"Answer the number of milliseconds timedBlock takes to return its value."

	| initialMilliseconds |
	initialMilliseconds _ self localMillisecondClock.
	timedBlock value.
	^self localMillisecondClock - initialMilliseconds! !
!ProcessorScheduler methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563858!
suspendFirstAt: aPriority ifNone: noneBlock 
	"Suspend the first Process that is waiting to run with priority aPriority.  
	If no Process is waiting, evaluate noneBlock"

	| aList |
	aList _ quiescentProcessLists at: aPriority.
	aList isEmpty
		ifTrue: [^noneBlock value]
		ifFalse: [^aList first suspend]! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558854!
typeInfoOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^aBlock value! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562551!
detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the evaluation of foundBlock at the first element for which aBlock evaluates to true."
	^ foundBlock value: (self detect: aBlock ifNone: [^ exceptionBlock value])! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558016!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector withCaption: aCaptionText ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass = aSuperclass ifTrue: [ { aClass } ] ifFalse: [ aClass withAllSuperclassesUpTo: aSuperclass ].
	chosenClassIndex _ PopUpMenu
		withCaption: aCaptionText
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554213!
removeKey: localFileName ifAbsent: failBlock
	self fileAccessor deleteFile: (self // localFileName) pathName ifAbsent: [^failBlock value].
	self invalidateChildren.! !
!VariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557777!
valueIn: aCompiledMethod

	^(self in: aCompiledMethod) value! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561907!
changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50558436!
test01FindsSelectionOnSourceMethod

	| sourceMethodName finder methodsToExtractFrom sourceMethod |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder value.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	self assert: (4 to: 5) equals: methodsToExtractFrom first intervalToExtract.
	self assert: sourceMethod equals: methodsToExtractFrom first methodToExtractFrom.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553987 overrides: 50533447!
convertAmountToBaseUnit

	^self value convertAmountToBaseUnit! !
!Collection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559218!
detect: aBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the first element for which aBlock evaluates to true."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^exceptionBlock value! !
!DenotativeObjectTestResultWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50557608 overrides: 50572654!
runSuite

	| suite |

	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(DenotativeObjectProgessiveTestRunner for: suite) value.
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559627 overrides: 50533314!
moduloSimpleMeasure: aMeasure

	^self value moduloSimpleMeasure: aMeasure! !
!Parser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553846!
correctVariable: proposedVariable interval: aSpot
	"Correct the proposedVariable to a known variable, or declare it as a new
	variable if such action is requested.  We support declaring lowercase
	variables as temps or inst-vars, and uppercase variables as Globals or 
	ClassVars, depending on whether the context is nil (class=UndefinedObject).
	Spot is the interval within the test stream of the variable.
	rr 3/4/2004 10:26 : adds the option to define a new class. "

	"Check if this is an i-var, that has been corrected already (ugly)"

	"Display the pop-up menu"

	| userSelection action delta spot |
	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: [
		^InstanceVariableNode new 
			name: proposedVariable
			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].

	"First check to see if the requestor knows anything about the variable"
	(requestor bindingOf: proposedVariable)
		ifNotNil: [ :binding | ^ encoder global: binding name: proposedVariable].

	"If we can't ask the user for correction, make it undeclared"
	self interactive ifFalse: [^encoder undeclared: proposedVariable].

	userSelection _ requestor selectionInterval.
	delta _ self sourceDelta.
	spot _ aSpot first - delta to: aSpot last - delta.
	requestor selectFrom: spot first to: spot last.

	"Build the menu with alternatives"
	action _ UndeclaredVariable 
				signalFor: self
				name: proposedVariable
				inRange: spot.
	action ifNil: [^self fail].

	"Execute the selected action"
	requestor selectInvisiblyFrom: userSelection first to: userSelection last.
	^action value ifNil: [self fail].
	! !
!WeakActionSequence methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554482!
valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each value ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555353!
intervalCoversCompleteAstNodes 

	^ (self trimmed: (initialNode value first to: finalNode value last) asSourceCodeInterval) = intervalToExtract! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50554354 overrides: 50521541!
isFixed

	^self value isFixed! !
!ConversionTable methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562885!
removeUnitConversionRuleFrom: aSourceUnit to: aTargetUnit ifAbsent: aBlock

	| currentConvertionRule |
	currentConvertionRule := self 
		unitConversionRuleFrom: aSourceUnit
		to: aTargetUnit
		ifNone: [^aBlock value].
	unitConversionRules remove: currentConvertionRule.
	self invalidateGraph! !
!FilteredGregorianDate methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555959 overrides: 16881710!
< aDate

	^date < aDate value! !
!Semaphore methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560981!
critical: mutuallyExcludedBlock ifLocked: alternativeBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 
	the process of running the critical: message. If the receiver is, then evaluate 
	alternativeBlock and return."
	"See the comment of #critical: for the explanation how this pattern works
	before changing the code."

	| caught |
	caught := false.
	^[
		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only.
	Do not change the following #== for #=, as #== is not a real message send, just a bytecode."
		excessSignals == 0
			ifTrue: [
				"If we come here, then the semaphore was locked when the test executed. 
				Evaluate the alternative block and answer its result."
				alternativeBlock value ]
			ifFalse: [
				excessSignals := excessSignals - 1.
				caught := true.
				mutuallyExcludedBlock value ] ]
		ensure: [ caught ifTrue: [ self signal ] ]! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555776!
withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560536!
packageOfSystemCategory: aSystemCategory ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock value ].
	^ InstalledPackages
		detect: [:ea | ea includesSystemCategory: aSystemCategory]
		ifNone: errorBlock! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556429!
browseSelected
	
	| action |
	
	action := actions at: selectedIndex ifAbsent: [ ^self ].
	action value! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559350 overrides: 50533214!
<= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(aMagnitude < self value) not! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562898!
lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	lastIndex to: 1 by: -1 do:
		[:index |
		(self at: index) = anElement ifTrue: [^ index]].
	^ exceptionBlock value! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50555052!
testWithGraphWithoutEdges

	| graph result |

	graph := Graph edges: #() nodes: (Array with: 'a' with: 'b').

	result := (TopologicalSort for: graph) value.

	self
		assert: (result includes: 'a');
		assert: (result includes: 'b')! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563391 overrides: 50533163!
* anAritmethicObject

	^self value * anAritmethicObject value! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561751!
withActualMessageSendsOfAll: compiledMethods 
	do: aMessageSendNodeBlock 
	ifAbsent: absentBlock 
	withPossibleMessageSends: shouldAddPossibleMessageSends 
	sortingWith: aSortBlock 
	using: aMethodNode 
	
	| ranges sortedRanges sendersCollector sender |
	
	sender := class>>selector.
	ranges := Set new.
	compiledMethods do: [ :aCompiledMethod |
		sendersCollector := sender actualSendersOf: aCompiledMethod using: aMethodNode.
		ranges addAll: (sendersCollector sureMessageSends collect: aMessageSendNodeBlock).
		shouldAddPossibleMessageSends ifTrue: [
			ranges addAll: (sendersCollector possibleMessageSends collect: [ :aPossibleMessageSend | aMessageSendNodeBlock value: aPossibleMessageSend key])]].
		
	ranges isEmpty ifTrue: [ ^absentBlock value ].
	sortedRanges := ranges asSortedCollection: aSortBlock.

	^sortedRanges ! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563994 overrides: 50553066!
transactionAmount

	^self class from: from value duration: duration! !
!False methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50559874!
orNot: alternativeBlock

	^alternativeBlock value not! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50560253 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isAssignmentNode
		and: [ self variable equivalentTo: aParseNode variable ]
		and: [ self value equivalentTo: aParseNode value ]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50562078!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock value]! !
!Parser class methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561469!
chainExamplesDoubleColon

	1 bitShift: 3 :: + 5.  "13"

	3 + 4 :: negated + 2 :: negated - 2 bitShift: 2 :: bitShift: -1.  "6"

	1 = 2 and: [3 = 4] :: ifTrue: [5] ifFalse: [6].  "6"

	1 = 1
		:: and: [2 = 2]
		:: and: [3 = 3]
		:: and: [4 = 4]
		:: ifTrue: [#yes] ifFalse: [#bummer].  "#yes"

	1 = 1 :: = true.  "true"

	1 = 1 :: ifTrue: [2] ifFalse: [3] :: + 1 ; + 10.  "12"

	1 bitShift: 3 :: + 2 bitShift: -1.  "5"

	1 to: 10 by: 3 :: size.  "4"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x].  "22"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x] :: bitShift: -1 :: - 1.  "10"

	CompiledMethod allInstances
		:: reject: [:x | x getSourceFromFile isNil]
		:: collect: [:x | x getSourceFromFile -> x]
		:: collect: [:x | x key occurrencesOf: $( :: + (x key occurrencesOf: $)) :: -> x key -> x value]
		:: asSortedCollection: [:x :y | x > y]
		:: inspect.! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50561594!
addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(AddInstanceVariableApplier on: model for: aClass) value ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556214 overrides: 50533130!
isNothing

	^self value isNothing! !
!Browser methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50553998!
runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) value 
	! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50556388!
timesRepeat: aBlock
	
	[ aBlock value.
	true ] whileTrue! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50563744!
newProcess
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	^Process
		forContext: 
			[self value.
			Processor activeProcess suspend] asContext
		priority: Processor activePriority! !
!Preference methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50564643 overrides: 50564492!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50564668 overrides: 50564492!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super value! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:05:04' prior: 50565051 overrides: 50564492!
value

	^self class from: from value duration: duration! !

!methodRemoval: Object #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^self!

!methodRemoval: MessageSend #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)!

!methodRemoval: WeakMessageSend #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]!

!methodRemoval: Association #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	"Answer the value of the receiver."
	^value!

!methodRemoval: ReadOnlyVariableBinding #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	^value!

!methodRemoval: WeakValueAssociation #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	^self at: 1!

!methodRemoval: FilteredGregorianDate #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^date
!

!methodRemoval: RelativeGregorianDate #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^self absoluteDate!

!methodRemoval: BlockClosure #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>
	| newContext |
	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	false
		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."
			[newContext := self asContextWithSender: thisContext sender.
			thisContext privSender: newContext]
		ifFalse: [self primitiveFailed]!

!methodRemoval: WeakActionSequence #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1!

!methodRemoval: AssignmentNode #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	^ value!

!methodRemoval: MessageSendingBlocksVariablesToExtractFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract!

!methodRemoval: VariablesToExtractFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract!

!methodRemoval: MultiImplementorsActualMessageSendsCollector #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self 
		calculateSendersInfo;
		groupSendersByType;
		createMessageList !

!methodRemoval: ReceiverTypesOfMessageSendsConform #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [ 
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].
		
		senders do: [ :aSender | 
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender methodNode accept: self ]].
	
	^notIncludedReceiverTypesInMessageSends!

!methodRemoval: MethodTypeCheckerVisitor #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self 
		prepareToValue;
		visitMethodNode: methodNode.	
!

!methodRemoval: CodeCoverageSourceCodeGenerator #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."

	methodNode accept: self.
	
	tracedSourceCode :=  String streamContents: [ :stream | methodNode printOn: stream ] .
	
	!

!methodRemoval: Preference #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	!

!methodRemoval: DropFilesAction #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
!

!methodRemoval: ProgressiveTestRunner #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	Utilities authorInitials.
	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]!

!methodRemoval: CodeCoverageTest #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super value!

!methodRemoval: ClassReferencesCollector #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	!

!methodRemoval: ExtractMethodParametersDetector #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	| parseNodesFound |
	parseNodesFound := OrderedCollection new.
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ parseNodesFound add: parseNode ]
	].
	^ parseNodesFound!

!methodRemoval: ExtractMethodReplacementsFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	sizeToExtract := intervalToExtract size - 1.
	replacements := OrderedCollection new.
	
	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]
	 !

!methodRemoval: RefactoringApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	!

!methodRemoval: ChangeSelectorApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]!

!methodRemoval: ExtractMethodApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
!

!methodRemoval: InlineMethodApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]!

!methodRemoval: ExtractToMethodObjectApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: IntroduceNullObjectApplier #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: RefactoringPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self subclassResponsibility!

!methodRemoval: NewClassPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

!

!methodRemoval: NewGlobalPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

!

!methodRemoval: NewInstanceVariablePrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.!

!methodRemoval: NewSelectorPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy!

!methodRemoval: NewTemporaryPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes!

!methodRemoval: SourceCodeIntervalPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self subclassResponsibility!

!methodRemoval: SourceCodeOfMethodToBeExtractedPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression!

!methodRemoval: SourceCodeOfTemporaryToBeExtractedPrecondition #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes!

!methodRemoval: ArgumentsAndReturnsFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
!

!methodRemoval: IfNilChecksFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].!

!methodRemoval: ReturnStatementAdder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	!

!methodRemoval: SubstringMatcher #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^ resultsSorter value: (self filterCollection asOrderedCollection)!

!methodRemoval: CatalogButton #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	model changeSelectedCatalog: catalog!

!methodRemoval: ActualImplementorsFinder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self subclassResponsibility !

!methodRemoval: AllActualImplementors #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount 

	| typeImplementors |
	
	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self!

!methodRemoval: AllActualLocalImplementors #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	notImplemented := OrderedCollection new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
!

!methodRemoval: TypeChecker #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	self subclassResponsibility!

!methodRemoval: ManyMethodsTypeChecker #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].
	
	^self!

!methodRemoval: MethodTypeChecker #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self 
		initializeErrorsWarningsAndProblems;
		typeCheck.
			
	^self!

!methodRemoval: Collaborator #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^owner instVarNamed: name!

!methodRemoval: Delegator #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
!

!methodRemoval: CompiledMethodCoverageReportBuilder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults.!

!methodRemoval: CodeCoverageAnalyzerBuilder #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze!

!methodRemoval: Evaluation #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	self subclassResponsibility!

!methodRemoval: CachedEvaluation #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue!

!methodRemoval: DummyEvaluation #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^measure!

!methodRemoval: TopologicalSort #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result!

!methodRemoval: GregorianTimespan #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^self class from: from value duration: duration!

!methodRemoval: AccountTransaction #transactionAmount stamp: 'TD 10/6/2022 21:05:04'!
transactionAmount

	^ amount!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:05:07'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:07'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:07'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:05:07'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:05:07'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:05:07'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:05:07'!
PASSED!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:21'!
transactionAmount

	^ amount! !

!methodRemoval: AccountTransaction #value stamp: 'TD 10/6/2022 21:05:21'!
value

	^ amount!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:05:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:24'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:24'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:05:24'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:05:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:05:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:05:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:26'!
FAILURE!
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:47' prior: 50552922 overrides: 50552780!
impactOnBalance
	^self transactionAmount negated.! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:05:55' prior: 50552900 overrides: 50552780!
impactOnBalance
	^self transactionAmount.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:05:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:56'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:56'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:05:56'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:05:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:05:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:05:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:05:58'!
FAILURE!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:06:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:06:22'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:06:22'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:06:22'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:06:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:06:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:06:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:06:33'!
FAILURE!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:06:33'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:07:15' prior: 50553059!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := balanceSum + (aTransaction impactOnBalance)].
	^balanceSum.! !

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:07:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:07:18'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:07:18'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:07:18'!
FAILURE!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:08:01' overrides: 50564492!
value

	^ amount! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:08:01' prior: 50575622 overrides: 50552780!
impactOnBalance
	^self value negated.! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:08:01' prior: 50575627 overrides: 50552780!
impactOnBalance
	^self value.! !

!methodRemoval: AccountTransaction #transactionAmount stamp: 'TD 10/6/2022 21:08:01'!
transactionAmount

	^ amount!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:08:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:08:03'!
PASSED!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:12:41' prior: 50575696!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := balanceSum + (aTransaction updateBalance)].
	^balanceSum.! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:07:15' prior: 50575786!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := balanceSum + (aTransaction impactOnBalance)].
	^balanceSum.! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:13:38'!
impactOnBalance: aBalance

	self subclassResponsibility ! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:13:38' overrides: 50575802!
impactOnBalance: aBalance
	^self value.! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:13:38' overrides: 50575802!
impactOnBalance: aBalance
	^self value negated.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:13:38' prior: 50575794!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := balanceSum + (aTransaction impactOnBalance: balanceSum)].
	^balanceSum.! !

!methodRemoval: AccountTransaction #impactOnBalance stamp: 'TD 10/6/2022 21:13:38'!
impactOnBalance

	self subclassResponsibility !

!methodRemoval: Deposit #impactOnBalance stamp: 'TD 10/6/2022 21:13:38'!
impactOnBalance
	^self value.!

!methodRemoval: Withdraw #impactOnBalance stamp: 'TD 10/6/2022 21:13:38'!
impactOnBalance
	^self value negated.!
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:14:02' prior: 50575807 overrides: 50575802!
impactOnBalance: aBalance
	^self value + aBalance.! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:14:17' prior: 50575836 overrides: 50575802!
impactOnBalance: aBalance
	^aBalance - (self value).! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:14:33' prior: 50575841 overrides: 50575802!
impactOnBalance: aBalance
	^self value + aBalance.! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:14:43' prior: 50575811 overrides: 50575802!
impactOnBalance: aBalance
	^aBalance - (self value).! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:14:56' prior: 50575816!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := aTransaction impactOnBalance: balanceSum].
	^balanceSum.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:15:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:15:04'!
PASSED!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22'!
updateBalance: aBalance

	self subclassResponsibility ! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50575890!
updateBalance: aBalance
	^self value + aBalance.! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50575890!
updateBalance: aBalance
	^aBalance - (self value).! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:15:22' prior: 50575856!
balance
	|balanceSum|
	balanceSum := 0.
	transactions do: [ :aTransaction | balanceSum := aTransaction updateBalance: balanceSum].
	^balanceSum.! !

!methodRemoval: AccountTransaction #impactOnBalance: stamp: 'TD 10/6/2022 21:15:22'!
impactOnBalance: aBalance

	self subclassResponsibility !

!methodRemoval: Deposit #impactOnBalance: stamp: 'TD 10/6/2022 21:15:22'!
impactOnBalance: aBalance
	^self value + aBalance.!

!methodRemoval: Withdraw #impactOnBalance: stamp: 'TD 10/6/2022 21:15:22'!
impactOnBalance: aBalance
	^aBalance - (self value).!

----End fileIn of /home/clinux01/Descargas/linux64 (2)/Packages/TerseGuide.pck.st----!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:17:25' prior: 50575905!
balance

	^transactions inject: 0 into: [ :balanceSum :aTransaction |aTransaction updateBalance: balanceSum].! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/6/2022 21:17:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/6/2022 21:17:28'!
PASSED!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:17:35' prior: 50578845!
balance

	^transactions inject: 0 into: [ :balanceSum :aTransaction | aTransaction updateBalance: balanceSum].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/6/2022 21:17:56' prior: 50552490!
hasRegistered: aTransaction

	^ transactions includes: aTransaction ! !

TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:35:12'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:36:39'!
Object subclass: #Portfolio
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'no messages' stamp: 'TD 10/6/2022 21:36:31'!
test01emptyPortfolioHasZeroBalance
	|portfolio|
	portfolio := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:36:43'!
ERROR!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:36:43'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:37:11'!
balance
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:37:17' prior: 50578922!
balance
	^0.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:37:19'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:37:21'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:38:07'!
test02portfolioWith1AccountHasAccountBalance! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:38:38' prior: 50578936!
test02portfolioWith1AccountHasAccountBalance
	|account|
	
	account := ReceptiveAccount ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:39:45' prior: 50578941!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account. ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:40:06' prior: 50578947!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio with: account.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:40:22' prior: 50578956!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new add: account.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:40:46' prior: 50578966!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio addAccount: account.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:41:03' prior: 50578976!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio addAccount: account.
	
	self assert: 50 equals: portfolio balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:42:00'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:42:00'!
ERROR!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:42:00'!
ERROR!
!Portfolio methodsFor: 'accounts' stamp: 'TD 10/6/2022 21:42:30'!
addAccount: aReceptiveAccount 
	self shouldBeImplemented.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/6/2022 21:43:37'!
Object subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'accounts' stamp: 'TD 10/6/2022 21:43:34' prior: 50579008!
addAccount: aReceptiveAccount 
	accountsAndPortfolios add: aReceptiveAccount.! !

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:43:52'!
ERROR!
!Portfolio methodsFor: 'nil' stamp: 'TD 10/6/2022 21:44:22' overrides: 16920235!
initialize
	accountsAndPortfolios := OrderedCollection new.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:44:23'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:44:23'!
FAILURE!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:44:23'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:45:24' prior: 50578926!
balance
	accountsAndPortfolios ifEmpty: [^0].
	^(accountsAndPortfolios first) balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:45:26'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:45:26'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:47:30'!
test03portfolioWithManyAccountHasAccountSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio addAccount: account.
	portfolio addAccount: account1.
	portfolio addAccount: account2.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:47:48'!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio addAccount: account.
	portfolio addAccount: account1.
	portfolio addAccount: account2.
	
	self assert: 75 equals: portfolio balance.! !

!methodRemoval: PortfolioTest #test03portfolioWithManyAccountHasAccountSumBalance stamp: 'TD 10/6/2022 21:47:48'!
test03portfolioWithManyAccountHasAccountSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio addAccount: account.
	portfolio addAccount: account1.
	portfolio addAccount: account2.
	
	self assert: 75 equals: portfolio balance.!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:47:51'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:47:52'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:47:52'!
FAILURE!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:47:52'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:49:39' prior: 50579045!
balance
	|balanceSum|
	accountsAndPortfolios do: [:aMember | balanceSum := balanceSum + (aMember balance)].
	^balanceSum ! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:49:47' prior: 50579135!
balance
	|balanceSum|
	balanceSum := 0.
	accountsAndPortfolios do: [:aMember | balanceSum := balanceSum + (aMember balance)].
	^balanceSum ! !

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:49:49'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:49:50'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:49:50'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:49:50'!
PASSED!
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:51:17'!
impactOnPortfolioBalance: aBalance
	^aBalance + self balance.! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:51:22' prior: 50579163!
impactOnPortfolioBalance: aBalance
	^aBalance + (self balance).! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:52:19' prior: 50579142!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember impactOnPortfolioBalance: balanceSum]! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:52:58'!
updatePortfolioBalance: aBalance
	^aBalance + (self balance).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:52:58' prior: 50579173!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember updatePortfolioBalance: balanceSum]! !

!methodRemoval: ReceptiveAccount #impactOnPortfolioBalance: stamp: 'TD 10/6/2022 21:52:58'!
impactOnPortfolioBalance: aBalance
	^aBalance + (self balance).!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:53:02'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:53:02'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:53:02'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:54:45'!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio addAccount: account.
	portfolio addAccount: account1.
	portfolio1 addAccount: account2.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:55:39' prior: 50579207!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio addAccount: account.
	portfolio addAccount: account1.
	portfolio1 addAccount: account2.
	portfolio addPortfolio: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:55:46'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:55:46'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:55:46'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:55:46'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:55:46'!
ERROR!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:55:50'!
addPortfolio: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:55:58' prior: 50579273!
addPortfolio: aPortfolio 
	accountsAndPortfolios add: aPortfolio.! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:56:01'!
ERROR!
!Portfolio methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/6/2022 21:57:04'!
updatePortfolioBalance: aSmallInteger 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/6/2022 21:57:25'!
updateParentPortfolioBalance: aSmallInteger 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:57:25'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:57:25' prior: 50579185!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember updateParentPortfolioBalance: balanceSum]! !

!methodRemoval: Portfolio #updatePortfolioBalance: stamp: 'TD 10/6/2022 21:57:25'!
updatePortfolioBalance: aSmallInteger 
	self shouldBeImplemented.!

!methodRemoval: ReceptiveAccount #updatePortfolioBalance: stamp: 'TD 10/6/2022 21:57:25'!
updatePortfolioBalance: aBalance
	^aBalance + (self balance).!
!Portfolio methodsFor: 'nil' stamp: 'TD 10/6/2022 21:57:56'!
updatePortfolioBalance: aBalance
	^aBalance + (self balance)! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:58:00'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:58:02'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:58:02'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:58:02'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:58:02'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:58:02'!
ERROR!
!Portfolio methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/6/2022 21:58:29' prior: 50579293!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:58:30'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:58:32'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:58:32'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:58:32'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:58:32'!
PASSED!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:59:02' prior: 50579021!
addAccount: aMember 
	accountsAndPortfolios add: aMember.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:59:11'!
add: aMember 
	accountsAndPortfolios add: aMember.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:59:11' prior: 50579230!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio addPortfolio: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:59:11' prior: 50578987!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account transaction|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: 50 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:59:11' prior: 50579079!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: 75 equals: portfolio balance.! !

!methodRemoval: Portfolio #addAccount: stamp: 'TD 10/6/2022 21:59:11'!
addAccount: aMember 
	accountsAndPortfolios add: aMember.!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:59:29' prior: 50579385!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !

!methodRemoval: Portfolio #addPortfolio: stamp: 'TD 10/6/2022 21:59:45'!
addPortfolio: aPortfolio 
	accountsAndPortfolios add: aPortfolio.!

!methodRemoval: Portfolio #updatePortfolioBalance: stamp: 'TD 10/6/2022 21:59:50'!
updatePortfolioBalance: aBalance
	^aBalance + (self balance)!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/6/2022 21:59:53'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/6/2022 21:59:53'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/6/2022 21:59:53'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/6/2022 21:59:53'!
PASSED!

----STARTUP---- (13 October 2022 19:57:33) as /home/clinux01/Descargas/linux64 (2)/CuisUniversity-5481.image!


----End fileIn of /home/clinux01/Escritorio/06-Portfolio.st----!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:00:54'!
test05portfolioWithNoAccountsDoesntHaveTransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:01:05'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:01:11'!
hasRegistered: aDeposit 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:01:17' prior: 50552632!
hasRegistered: aDeposit 
	^false.! !

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:01:19'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:03:30'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:03:30'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:03:30'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:03:30'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:03:30'!
PASSED!

Object subclass: #AccountType
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/13/2022 21:08:02'!
Object subclass: #AccountType
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/13/2022 21:08:11'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/13/2022 21:08:26'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/13/2022 21:08:31'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/13/2022 21:08:58'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:09:00'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:09:00'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:09:00'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:09:00'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:09:00'!
PASSED!
!AccountType methodsFor: 'no messages' stamp: 'TD 10/13/2022 21:10:03'!
balance
	self subclassResponsibility.! !
!AccountType methodsFor: 'balance' stamp: 'TD 10/13/2022 21:12:10'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !

!methodRemoval: ReceptiveAccount #updateParentPortfolioBalance: stamp: 'TD 10/13/2022 21:12:10'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).!
!AccountType methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/13/2022 21:12:16' prior: 50552788!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !

!methodRemoval: Portfolio #updateParentPortfolioBalance: stamp: 'TD 10/13/2022 21:12:16'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).!
!AccountType methodsFor: 'nil' stamp: 'TD 10/13/2022 21:13:18'!
hasRegistered: aTransaction
	self subclassResponsibility.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:14:44'!
test06portfolioWithOneAccountHasATransactionOfTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:14:53' prior: 50552814!
test06portfolioWithOneAccountHasATransactionOfTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:14:55'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:15:38' prior: 50552637 overrides: 50552809!
hasRegistered: aDeposit 
	^(accountsAndPortfolios first) hasRegistered: aDeposit.! !

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:15:40'!
ERROR!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:15:40'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:15:40'!
ERROR!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:16:04'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:16:04'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:16:04'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:16:04'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:16:04'!
ERROR!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:16:04'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:16:04'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:16:16'!
ERROR!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:16:46'!
ERROR!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:16:46'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:16:46'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:01:17' prior: 50552844 overrides: 50552809!
hasRegistered: aDeposit 
	^false.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'TD 10/13/2022 21:17:16'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:17:17'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:17:17'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:17:17'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:17:17'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:17:17'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:17:17'!
FAILURE!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:17:17'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:18:05' prior: 50552943 overrides: 50552809!
hasRegistered: aDeposit 
	[accountsAndPortfolios isEmpty] ifTrue: [^false].
	^true.! !

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:18:14'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:18:29' prior: 50553001 overrides: 50552809!
hasRegistered: aDeposit 
	(accountsAndPortfolios isEmpty) ifTrue: [^false].
	^true.! !

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:18:30'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:18:32'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:18:32'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:18:32'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:18:32'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:18:32'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:18:32'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:19:08'!
test07portfolioWithOneAccountHasTheSameTransactionAsAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !

!methodRemoval: PortfolioTest #test07portfolioWithOneAccountHasTheSameTransactionAsAccount stamp: 'TD 10/13/2022 21:19:20'!
test07portfolioWithOneAccountHasTheSameTransactionAsAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:19:29'!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !

!methodRemoval: PortfolioTest #test06portfolioWithOneAccountHasATransactionOfTheAccount stamp: 'TD 10/13/2022 21:19:31'!
test06portfolioWithOneAccountHasATransactionOfTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:20:03' prior: 50553011 overrides: 50552809!
hasRegistered: aDeposit 
	(accountsAndPortfolios isEmpty) ifTrue: [^false].
	^(accountsAndPortfolios first) hasRegistered: aDeposit.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:20:07'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:20:07'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:20:07'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:20:07'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:20:07'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:20:07'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:20:58'!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:21:21' prior: 50553127!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio transaction account account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:21:52' prior: 50553140!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio transaction account account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:22:00'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:22:00'!
FAILURE!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:22:00'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:22:18' prior: 50553097 overrides: 50552809!
hasRegistered: aTransaction 
	(accountsAndPortfolios isEmpty) ifTrue: [^false].
	^(accountsAndPortfolios first) hasRegistered: aTransaction.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:23:47' prior: 50553212 overrides: 50552809!
hasRegistered: aTransaction 
	^accountsAndPortfolios anySatisfy: [:aMember | aMember hasRegistered: aTransaction].! !

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:23:49'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:23:51'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:23:51'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:24:58'!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).! !

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/13/2022 21:25:03'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:25:06'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/13/2022 21:25:06'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:27:37' prior: 50553258!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:27:40' prior: 50553318!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account transaction account1 account2 transaction1 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:31:51'!
test05portfolioWithNoAccountsDoesNotHaveTransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !

!methodRemoval: PortfolioTest #test05portfolioWithNoAccountsDoesntHaveTransactionRegistered stamp: 'TD 10/13/2022 21:31:51'!
test05portfolioWithNoAccountsDoesntHaveTransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:32:02'!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !

!methodRemoval: PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactionRegistered stamp: 'TD 10/13/2022 21:32:02'!
test05portfolioWithNoAccountsDoesNotHaveTransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:32:46'!
test05portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio |
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:32:51' prior: 50553427!
test05portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:32:53'!
ERROR!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/13/2022 21:32:53'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:32:53'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:32:58'!
transactions
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:33:07' prior: 50553483!
transactions
	^OrderedCollection new.! !

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:33:08'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:33:10'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/13/2022 21:33:10'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:33:19'!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !

!methodRemoval: PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:33:19'!
test05portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:34:02'!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account transaction |
	
	account := ReceptiveAccount new.
	transaction := Deposit with: 50.
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:34:39' prior: 50553549!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account transaction |
	
	account := ReceptiveAccount new.
	transaction := Deposit with: 50.
	portfolio := Portfolio new.
	
	self assert: (account transactions) equals: portfolio transactions.! !

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/13/2022 21:34:43'!
ERROR!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:35:07' prior: 50553561!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account transaction |
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	
	self assert: (account transactions) equals: portfolio transactions.! !

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/13/2022 21:35:10'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:35:37' prior: 50553488!
transactions
	^(accountsAndPortfolios first) transactions.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:36:14' prior: 50553592!
transactions
	accountsAndPortfolios isEmpty ifTrue: [^OrderedCollection new.].
	^(accountsAndPortfolios first) transactions.! !

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/13/2022 21:36:15'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:36:39' prior: 50553576!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account transaction |
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/13/2022 21:36:42'!
PASSED!

----SNAPSHOT----(13 October 2022 21:41:11) CuisUniversity-5481.image priorSource: 7059698!

----QUIT----(13 October 2022 21:41:15) CuisUniversity-5481.image priorSource: 7104276!

----STARTUP---- (14 October 2022 18:46:27) as C:\Users\Franco\Desktop\UBA2\Ing1\CuisUniversity\CuisUniversity-5466.image!


----End fileIn of C:\Users\Franco\Downloads\06-Portfolio.st----!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'FM 10/14/2022 18:48:43'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'FM 10/14/2022 18:48:43'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 18:51:26'!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction |
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 18:51:48' prior: 50566400!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 18:56:27' prior: 50566413!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 18:56:46' prior: 50566435!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 18:56:50'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 18:56:50'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 18:59:25' prior: 50566300!
transactions
	
	accountsAndPortfolios isEmpty ifTrue: [^OrderedCollection new.].
	
	^accountsAndPortfolios inject: (OrderedCollection new) into: [:curTransactions :member | curTransactions addAll: (member transactions)].
	"(accountsAndPortfolios first) transactions."! !
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 18:59:37' prior: 50566499!
transactions
	
	"accountsAndPortfolios isEmpty ifTrue: [^OrderedCollection new.]."
	
	^accountsAndPortfolios inject: (OrderedCollection new) into: [:curTransactions :member | curTransactions addAll: (member transactions)].
	"(accountsAndPortfolios first) transactions."! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 18:59:40'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 18:59:40'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:01:08'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:01:08'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:01:22' prior: 50566463!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	"transaction2 := Withdraw register: 75 on: account2."
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	"portfolio add: account2."
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	"transactionList addAll: account2 transactions."
	
	self assert: transactionList equals: portfolio transactions.! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:01:27'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:01:27'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:01:34' prior: 50566539!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:04:10' prior: 50566511!
transactions
	|transactionList|
	"accountsAndPortfolios isEmpty ifTrue: [^OrderedCollection new.]."
	transactionList := OrderedCollection new.
	accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList.
	"accountsAndPortfolios inject: (OrderedCollection new) into: [:curTransactions :member | curTransactions addAll: (member transactions)]."
	"(accountsAndPortfolios first) transactions."! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:04:17'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'FM 10/14/2022 19:04:28'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'FM 10/14/2022 19:04:30'!
PASSED!
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:05:49' prior: 50566602!
transactions
	|transactionList|
	"accountsAndPortfolios isEmpty ifTrue: [^OrderedCollection new.]."
	transactionList := OrderedCollection new.
	"accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList."
	^accountsAndPortfolios inject: transactionList into: [:curTransactions :member | curTransactions addAll: (member transactions)].
	"(accountsAndPortfolios first) transactions."! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:05:51'!
FAILURE!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:05:51'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:06:08' prior: 50566631!
transactions
	|transactionList|
	transactionList := OrderedCollection new.
	accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList.
	! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:06:11'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:07:07' prior: 50566575!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:01:34' prior: 50566670!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:07:55'!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:13:56' prior: 50566727!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	transaction2 := Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:14:00'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:14:20' prior: 50566757!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account transaction account1 account2 transaction1 transaction2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	transaction1 := Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	transaction2 := Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:14:52' prior: 50566792!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:14:55'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:16' prior: 50565907!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: 50 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:30' prior: 50565918!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account account1 account2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: 75 equals: portfolio balance.! !

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'FM 10/14/2022 19:15:31'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'FM 10/14/2022 19:15:32'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:38' prior: 50565938!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'FM 10/14/2022 19:15:41'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:45' prior: 50565961!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:48' prior: 50565973!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:53' prior: 50566928!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:59' prior: 50566916!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:17' prior: 50565986!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'FM 10/14/2022 19:16:18'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'FM 10/14/2022 19:16:19'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:29' prior: 50566007!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'FM 10/14/2022 19:16:30'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:37' prior: 50566044!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:46' prior: 50566700!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'FM 10/14/2022 19:16:47'!
PASSED!
!AccountType methodsFor: 'balance' stamp: 'FM 10/14/2022 19:18:57'!
transactions
	self subclassResponsibility.! !

----STARTUP---- (17 October 2022 13:06:51) as C:\Users\tomas\Desktop\FACULTAD\Inge1\windows64\CuisUniversity-5481.image!


----End fileIn of C:\Users\tomas\Desktop\FACULTAD\Inge1\FileOuts\06-Portfolio.st----!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:09:29'!
test13portfolioCannotAddSameAccountTwice
	|portfolio account |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	
	self should: [portfolio add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:09:36'!
ERROR!
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:09:47'!
repeatedAccountErrorDescription
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:10:06' prior: 50600330!
repeatedAccountErrorDescription
	^'cannot add an account multiple times!!'! !

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:10:08'!
FAILURE!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:11:16' prior: 50600261!
add: aMember
	(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:11:19'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:11:20'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:11:20'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:07'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!testRun: #PortfolioTest #test13portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:12:11'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:23'!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!methodRemoval: PortfolioTest #test13portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:12:23'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:12:26'!
FAILURE!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:17:01' prior: 50600344!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:17:05'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:17:05'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:17:05'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:17:06'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:17:06'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:17:06'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:17:06'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:17:06'!
FAILURE!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:17:07'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:17:12'!
FAILURE!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:17:17'!
ERROR!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:42'!
shouldNotLetAdding: aPortfolio 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:54' prior: 50600538!
shouldNotLetAdding: aMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:19:07' prior: 50600543!
shouldNotLetAdding: aCandidateMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:21:10' prior: 50600548!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember has: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:21:14'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:21:19'!
has: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:22' prior: 50600568!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: [
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]]].
	^isContained.! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:25:23'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:54' prior: 50600573!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: ([
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]])].
	^isContained.! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:25:55'!
ERROR!

aCandidateMember has: self!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:31:18' prior: 50600590!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:31:21'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:31:21'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:31:21'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:31:21'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:31:21'!
FAILURE!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:31:23'!
ERROR!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:35'!
contains: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:51' prior: 50600675!
contains: aReceptiveAccount 
	^aReceptiveAccount = self! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:31:53'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:31:54'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:31:55'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:31:55'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:31:55'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:31:55'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:31:55'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:31:55'!
PASSED!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:32:32'!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !

!methodRemoval: Portfolio #has: stamp: 'TD 10/17/2022 13:32:32'!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:33:23'!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:34:02' prior: 50600759!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:34:03'!
ERROR!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:34:26'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:34:26'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:34:27'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:34:27'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:34:27'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:34:27'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:34:27'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:34:27'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:34:27'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:34:27'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:34:29'!
ERROR!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:34:37' prior: 50600554!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:34:43'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:34:45'!
FAILURE!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:34:45'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:34:45'!
FAILURE!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:34:53'!
PASSED!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 13:38:45'!
Object subclass: #AccountType
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:38:44' prior: 50600856!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:38:51'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:38:51'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:38:51'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:38:51'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:38:51'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:38:51'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:38:53'!
ERROR!
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 13:39:39' overrides: 16920235!
initialize
	parent := self.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:48' prior: 50600266 overrides: 50601021!
initialize
	accountsAndPortfolios := OrderedCollection new.
	super initialize.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:57' prior: 50600285 overrides: 50601021!
initialize
	transactions := OrderedCollection new.
	super initialize.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:40:34' prior: 50600454!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:40:39'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:40:39'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:40:40'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:40:40'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:40:40'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:40:41'!
ERROR!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:40:41'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:40:41'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:40:41'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:40:42'!
ERROR!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:40:42'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:40:42'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:40:42'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:40:43'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:40:43'!
ERROR!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:40:46'!
ERROR!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:40:58'!
parent: aPortfolio 
	self shouldBeImplemented.
	parent := aPortfolio! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:41:10' prior: 50601118!
parent: aPortfolio 
	parent := aPortfolio! !

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:41:12'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:41:14'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:41:15'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:41:16'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:41:18'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:41:18'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:41:20'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:41:20'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:41:20'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:41:21'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:41:22'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:41:23'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:41:23'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:41:24'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:41:25'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:41:25'!
FAILURE!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:41:30'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:41:30'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:41:31'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:41:32'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:41:33'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:41:33'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:41:34'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:41:35'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:41:36'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:41:37'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:41:37'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:41:38'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:41:39'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:41:40'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:41:41'!
FAILURE!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:41:57'!
FAILURE!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:46:10' prior: 50600680!
contains: aReceptiveAccount 
	(aReceptiveAccount isKindOf: self class) ifTrue: [
		^ self = aReceptiveAccount
	].
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [
		^aReceptiveAccount contains: self.
	]! !

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:46:12'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:46:13'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:46:14'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:46:14'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:46:14'!
FAILURE!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:48:09' prior: 50601039!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:48:13'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:49:04'!
FAILURE!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:28' prior: 50600945!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self or: [].
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:33' prior: 50601358!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:51:35'!
FAILURE!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50601371!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:52:26'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:52:26'!
PASSED!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:53:51' prior: 50601331!
add: aMember

	aMember cannotBeAdded ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:53:54'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:53:54'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:53:54'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:53:54'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:53:55'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:53:55'!
ERROR!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:53:58'!
ERROR!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:54:08'!
cannotBeAdded
	self shouldBeImplemented.! !

!methodRemoval: ReceptiveAccount #cannotBeAdded stamp: 'TD 10/17/2022 13:54:33'!
cannotBeAdded
	self shouldBeImplemented.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:54:45' prior: 50601460!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:54:48'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:54:48'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:54:48'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:54:48'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:54:49'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:54:49'!
ERROR!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:54:52'!
ERROR!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:55:03'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:56:23' prior: 50601636!
cannotBeAddedTo: aPortfolio 
	^aPortfolio shouldNotLetAdding: self.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:56:25'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:56:26'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:56:26'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:56:26'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:56:26'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:56:26'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:56:26'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:56:29'!
ERROR!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:56:37'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:58:31' prior: 50601709!
cannotBeAddedTo: aPortfolio 
	^aPortfolio contains: self.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:58:35'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:58:36'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 13:58:38'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 13:58:39'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 13:58:39'!
PASSED!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:00:52' prior: 50601254!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.
	"End of block expected ->(aCandidateMember isKindOf: self class) ifTrue: [
		^ self = aCandidateMember
	].
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self.
	]"! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:00:57'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:00:57'!
FAILURE!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:00:57'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:00:57'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:00:59'!
ERROR!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:04'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:43' prior: 50601911!
alreadyBelongsTo: aReceptiveAccount 
	^self = aReceptiveAccount.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:01:57'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:01:57'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:01:57'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:01:57'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:01:58'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:01:58'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:01:59'!
ERROR!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:11'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:44' prior: 50601984!
alreadyBelongsTo: aReceptiveAccount 
	self contains: aReceptiveAccount.! !

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:02:45'!
ERROR!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:00' prior: 50601989!
alreadyBelongsTo: aReceptiveAccount 
	^self contains: aReceptiveAccount.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:03:02'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:03:02'!
PASSED!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:20' prior: 50601552!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:03:45' prior: 50601837!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:58' prior: 50602064!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 14:04:24'!
alreadyBelongsTo: aReceptiveAccount 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:04:43'!
cannotBeAddedTo: aPortfolio 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:05:08'!
contains: anOriginalMember
	self subclassResponsibility.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:06:57' prior: 50601388!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].

	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:06:58'!
PASSED!

----STARTUP---- (17 October 2022 14:15:13) as C:\Users\tomas\Desktop\FACULTAD\Inge1\windows64\CuisUniversity-5481.image!


!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:19'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:20'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:36:31'!
test01emptyPortfolioHasZeroBalance
	|portfolio|
	portfolio := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:16'!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: 50 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:30'!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account account1 account2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:38'!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:59'!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:53'!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:17'!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:29'!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:33:19'!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:37'!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:46'!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:14:52'!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:22'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:23'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 20:35:18'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 21:05:03'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22'!
updateBalance: aBalance

	self subclassResponsibility ! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:08:01' overrides: 16902254!
value

	^ amount! !

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:24'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:28'!
initializeFor: anAmount

	amount := anAmount ! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50602435!
updateBalance: aBalance
	^self value + aBalance.! !

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:22'!
initializeFor: anAmount

	amount := anAmount ! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50602435!
updateBalance: aBalance
	^aBalance - (self value).! !

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:25'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:26'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:26'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'balance' stamp: 'TD 10/13/2022 21:10:03'!
balance
	self subclassResponsibility.! !
!AccountType methodsFor: 'balance' stamp: 'FM 10/14/2022 19:18:57'!
transactions
	self subclassResponsibility.! !
!AccountType methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/13/2022 21:12:16'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/13/2022 21:13:18'!
hasRegistered: aTransaction
	self subclassResponsibility.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:26'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:26'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:57:25' overrides: 50602552!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember updateParentPortfolioBalance: balanceSum]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:23:47' overrides: 50602566!
hasRegistered: aTransaction 
	^accountsAndPortfolios anySatisfy: [:aMember | aMember hasRegistered: aTransaction].! !
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:06:08' overrides: 50602556!
transactions
	|transactionList|
	transactionList := OrderedCollection new.
	accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList.
	! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:59:11'!
add: aMember 
	accountsAndPortfolios add: aMember.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:44:22' overrides: 16920235!
initialize
	accountsAndPortfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:27'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:28'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' overrides: 16920235!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:25' overrides: 50602556!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:17:35' overrides: 50602552!
balance

	^transactions inject: 0 into: [ :balanceSum :aTransaction | aTransaction updateBalance: balanceSum].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/6/2022 21:17:56' overrides: 50602566!
hasRegistered: aTransaction

	^ transactions includes: aTransaction ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:09:29'!
test13portfolioCannotAddSameAccountTwice
	|portfolio account |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	
	self should: [portfolio add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:09:47'!
repeatedAccountErrorDescription
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:10:06' prior: 50602675!
repeatedAccountErrorDescription
	^'cannot add an account multiple times!!'! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:11:16' prior: 50602610!
add: aMember
	(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	accountsAndPortfolios add: aMember.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:07'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:23'!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!methodRemoval: PortfolioTest #test13portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:15:29'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:17:01' prior: 50602686!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:42'!
shouldNotLetAdding: aPortfolio 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:54' prior: 50602754!
shouldNotLetAdding: aMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:19:07' prior: 50602759!
shouldNotLetAdding: aCandidateMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:21:10' prior: 50602764!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember has: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:21:19'!
has: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:22' prior: 50602779!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: [
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]]].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:54' prior: 50602784!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: ([
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]])].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:31:18' prior: 50602797!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:35'!
contains: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:51' prior: 50602818!
contains: aReceptiveAccount 
	^aReceptiveAccount = self! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:32:32'!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !

!methodRemoval: Portfolio #has: stamp: 'TD 10/17/2022 14:15:30'!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:33:23'!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:34:02' prior: 50602843!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:34:37' prior: 50602770!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:15:31'!
Object subclass: #AccountType
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:38:44' prior: 50602873!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 13:39:39' overrides: 16920235!
initialize
	parent := self.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:48' prior: 50602615 overrides: 50602904!
initialize
	accountsAndPortfolios := OrderedCollection new.
	super initialize.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:57' prior: 50602637 overrides: 50602904!
initialize
	transactions := OrderedCollection new.
	super initialize.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:40:34' prior: 50602737!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:40:58'!
parent: aPortfolio 
	self shouldBeImplemented.
	parent := aPortfolio! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:41:10' prior: 50602940!
parent: aPortfolio 
	parent := aPortfolio! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:46:10' prior: 50602823!
contains: aReceptiveAccount 
	(aReceptiveAccount isKindOf: self class) ifTrue: [
		^ self = aReceptiveAccount
	].
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [
		^aReceptiveAccount contains: self.
	]! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:48:09' prior: 50602922!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:28' prior: 50602891!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self or: [].
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:33' prior: 50602980!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50602993!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:53:51' prior: 50602961!
add: aMember

	aMember cannotBeAdded ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:54:08'!
cannotBeAdded
	self shouldBeImplemented.! !

!methodRemoval: ReceptiveAccount #cannotBeAdded stamp: 'TD 10/17/2022 14:15:32'!
cannotBeAdded
	self shouldBeImplemented.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:54:45' prior: 50603019!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:55:03'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:56:23' prior: 50603072!
cannotBeAddedTo: aPortfolio 
	^aPortfolio shouldNotLetAdding: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:56:37'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:58:31' prior: 50603082!
cannotBeAddedTo: aPortfolio 
	^aPortfolio contains: self.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:00:52' prior: 50602951!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.
	"End of block expected ->(aCandidateMember isKindOf: self class) ifTrue: [
		^ self = aCandidateMember
	].
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self.
	]"! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:04'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:43' prior: 50603103!
alreadyBelongsTo: aReceptiveAccount 
	^self = aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:11'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:44' prior: 50603113!
alreadyBelongsTo: aReceptiveAccount 
	self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:00' prior: 50603118!
alreadyBelongsTo: aReceptiveAccount 
	^self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:20' prior: 50603050!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:03:45' prior: 50603092!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:58' prior: 50603130!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 14:04:24'!
alreadyBelongsTo: aReceptiveAccount 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:04:43'!
cannotBeAddedTo: aPortfolio 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:05:08'!
contains: anOriginalMember
	self subclassResponsibility.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:06:57' prior: 50603006!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50603168!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:17:10' prior: 50603176!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:17:38'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:17:38'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:17:38'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:17:39'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:17:39'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:17:39'!
ERROR!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:17:41'!
ERROR!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:17:48'!
shouldNotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:18:33' overrides: 50603189!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !

!methodRemoval: AccountType #shouldNotLetAdding: stamp: 'TD 10/17/2022 14:18:38'!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.!

!methodRemoval: ReceptiveAccount #shouldNotBeAddedTo: stamp: 'TD 10/17/2022 14:18:42'!
shouldNotBeAddedTo: aPortfolio 
	self shouldBeImplemented.!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:18:46'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:18:46'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:18:46'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:18:46'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:18:46'!
ERROR!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:19:28' prior: 50603264!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:19:30'!
PASSED!

----STARTUP---- (17 October 2022 14:19:40) as C:\Users\tomas\Desktop\FACULTAD\Inge1\windows64\CuisUniversity-5481.image!


!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:41'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:41'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:36:31'!
test01emptyPortfolioHasZeroBalance
	|portfolio|
	portfolio := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:16'!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: 50 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:30'!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account account1 account2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:38'!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:59'!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:53'!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:17'!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:29'!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:33:19'!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:37'!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:46'!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:14:52'!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:43'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:43'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 20:35:18'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 21:05:03'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:44'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:44'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22'!
updateBalance: aBalance

	self subclassResponsibility ! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:08:01' overrides: 16902254!
value

	^ amount! !

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:44'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:44'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:28'!
initializeFor: anAmount

	amount := anAmount ! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50603676!
updateBalance: aBalance
	^self value + aBalance.! !

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:22'!
initializeFor: anAmount

	amount := anAmount ! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' overrides: 50603676!
updateBalance: aBalance
	^aBalance - (self value).! !

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:45'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'balance' stamp: 'TD 10/13/2022 21:10:03'!
balance
	self subclassResponsibility.! !
!AccountType methodsFor: 'balance' stamp: 'FM 10/14/2022 19:18:57'!
transactions
	self subclassResponsibility.! !
!AccountType methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/13/2022 21:12:16'!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/13/2022 21:13:18'!
hasRegistered: aTransaction
	self subclassResponsibility.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:46'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:46'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:57:25' overrides: 50603793!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember updateParentPortfolioBalance: balanceSum]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:23:47' overrides: 50603807!
hasRegistered: aTransaction 
	^accountsAndPortfolios anySatisfy: [:aMember | aMember hasRegistered: aTransaction].! !
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:06:08' overrides: 50603797!
transactions
	|transactionList|
	transactionList := OrderedCollection new.
	accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList.
	! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:59:11'!
add: aMember 
	accountsAndPortfolios add: aMember.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:44:22' overrides: 16920235!
initialize
	accountsAndPortfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:47'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:47'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' overrides: 16920235!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:25' overrides: 50603797!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:17:35' overrides: 50603793!
balance

	^transactions inject: 0 into: [ :balanceSum :aTransaction | aTransaction updateBalance: balanceSum].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/6/2022 21:17:56' overrides: 50603807!
hasRegistered: aTransaction

	^ transactions includes: aTransaction ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:09:29'!
test13portfolioCannotAddSameAccountTwice
	|portfolio account |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	
	self should: [portfolio add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:09:47'!
repeatedAccountErrorDescription
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:10:06' prior: 50603916!
repeatedAccountErrorDescription
	^'cannot add an account multiple times!!'! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:11:16' prior: 50603851!
add: aMember
	(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	accountsAndPortfolios add: aMember.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:07'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:23'!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!methodRemoval: PortfolioTest #test13portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:19:48'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:17:01' prior: 50603927!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:42'!
shouldNotLetAdding: aPortfolio 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:54' prior: 50603995!
shouldNotLetAdding: aMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:19:07' prior: 50604000!
shouldNotLetAdding: aCandidateMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:21:10' prior: 50604005!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember has: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:21:19'!
has: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:22' prior: 50604020!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: [
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]]].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:54' prior: 50604025!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: ([
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]])].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:31:18' prior: 50604038!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:35'!
contains: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:51' prior: 50604059!
contains: aReceptiveAccount 
	^aReceptiveAccount = self! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:32:32'!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !

!methodRemoval: Portfolio #has: stamp: 'TD 10/17/2022 14:19:48'!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:33:23'!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:34:02' prior: 50604084!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:34:37' prior: 50604011!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:49'!
Object subclass: #AccountType
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:38:44' prior: 50604114!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 13:39:39' overrides: 16920235!
initialize
	parent := self.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:48' prior: 50603856 overrides: 50604145!
initialize
	accountsAndPortfolios := OrderedCollection new.
	super initialize.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:57' prior: 50603878 overrides: 50604145!
initialize
	transactions := OrderedCollection new.
	super initialize.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:40:34' prior: 50603978!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:40:58'!
parent: aPortfolio 
	self shouldBeImplemented.
	parent := aPortfolio! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:41:10' prior: 50604181!
parent: aPortfolio 
	parent := aPortfolio! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:46:10' prior: 50604064!
contains: aReceptiveAccount 
	(aReceptiveAccount isKindOf: self class) ifTrue: [
		^ self = aReceptiveAccount
	].
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [
		^aReceptiveAccount contains: self.
	]! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:48:09' prior: 50604163!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:28' prior: 50604132!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self or: [].
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:33' prior: 50604221!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50604234!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:53:51' prior: 50604202!
add: aMember

	aMember cannotBeAdded ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:54:08'!
cannotBeAdded
	self shouldBeImplemented.! !

!methodRemoval: ReceptiveAccount #cannotBeAdded stamp: 'TD 10/17/2022 14:19:49'!
cannotBeAdded
	self shouldBeImplemented.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:54:45' prior: 50604260!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:55:03'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:56:23' prior: 50604313!
cannotBeAddedTo: aPortfolio 
	^aPortfolio shouldNotLetAdding: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:56:37'!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:58:31' prior: 50604323!
cannotBeAddedTo: aPortfolio 
	^aPortfolio contains: self.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:00:52' prior: 50604192!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.
	"End of block expected ->(aCandidateMember isKindOf: self class) ifTrue: [
		^ self = aCandidateMember
	].
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self.
	]"! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:04'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:43' prior: 50604344!
alreadyBelongsTo: aReceptiveAccount 
	^self = aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:11'!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:44' prior: 50604354!
alreadyBelongsTo: aReceptiveAccount 
	self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:00' prior: 50604359!
alreadyBelongsTo: aReceptiveAccount 
	^self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:20' prior: 50604291!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:03:45' prior: 50604333!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:58' prior: 50604371!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 14:04:24'!
alreadyBelongsTo: aReceptiveAccount 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:04:43'!
cannotBeAddedTo: aPortfolio 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:05:08'!
contains: anOriginalMember
	self subclassResponsibility.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:06:57' prior: 50604247!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].

	^parent shouldNotLetAdding: aCandidateMember.! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/6/2022 21:36:31' prior: 50603373!
test01emptyPortfolioHasZeroBalance
	|portfolio|
	portfolio := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:16' prior: 50603380!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: 50 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:30' prior: 50603391!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio account account1 account2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:38' prior: 50603408!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:59' prior: 50603428!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self assert: false equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:15:53' prior: 50603440!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:17' prior: 50603453!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:29' prior: 50603472!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto xx por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/13/2022 21:33:19' prior: 50603500!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	|portfolio|
	
	portfolio := Portfolio new.
	
	self assert: (OrderedCollection new) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:37' prior: 50603508!
test10portfolioWithOneAccountHasAccountsTransactions
	|portfolio account |
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account. 
	portfolio := Portfolio new.
	portfolio add: account.
	
	self assert: (account transactions) equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:16:46' prior: 50603520!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'FM 10/14/2022 19:14:52' prior: 50603545!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44' prior: 50603588!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48' prior: 50603595!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 20:35:18' prior: 50603604!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'TD 10/6/2022 21:05:03' prior: 50603614!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46' prior: 50603624!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53' prior: 50603637!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01' prior: 50603649!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'amount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' prior: 50603676!
updateBalance: aBalance

	self subclassResponsibility ! !
!AccountTransaction methodsFor: 'value' stamp: 'TD 10/6/2022 21:08:01' prior: 50603681 overrides: 16902254!
value

	^ amount! !

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:51'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00' prior: 50603695!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:28' prior: 50603717!
initializeFor: anAmount

	amount := anAmount ! !
!Deposit methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' prior: 50603722 overrides: 50604741!
updateBalance: aBalance
	^self value + aBalance.! !

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38' prior: 50603736!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:02:22' prior: 50603755!
initializeFor: anAmount

	amount := anAmount ! !
!Withdraw methodsFor: 'value' stamp: 'TD 10/6/2022 21:15:22' prior: 50603760 overrides: 50604741!
updateBalance: aBalance
	^aBalance - (self value).! !

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33' prior: 50603774!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
Object subclass: #AccountType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'balance' stamp: 'TD 10/13/2022 21:10:03' prior: 50603793!
balance
	self subclassResponsibility.! !
!AccountType methodsFor: 'balance' stamp: 'FM 10/14/2022 19:18:57' prior: 50603797!
transactions
	self subclassResponsibility.! !
!AccountType methodsFor: 'parent portfolio balance modifier' stamp: 'TD 10/13/2022 21:12:16' prior: 50603802!
updateParentPortfolioBalance: aBalance
	^aBalance + (self balance).! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/13/2022 21:13:18' prior: 50603807!
hasRegistered: aTransaction
	self subclassResponsibility.! !

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountType subclass: #Portfolio
	instanceVariableNames: 'accountsAndPortfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'information' stamp: 'TD 10/6/2022 21:57:25' prior: 50603828 overrides: 50604861!
balance
	^accountsAndPortfolios inject: 0 into: 
	[:balanceSum :aMember | aMember updateParentPortfolioBalance: balanceSum]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/13/2022 21:23:47' prior: 50603835 overrides: 50604875!
hasRegistered: aTransaction 
	^accountsAndPortfolios anySatisfy: [:aMember | aMember hasRegistered: aTransaction].! !
!Portfolio methodsFor: 'information' stamp: 'FM 10/14/2022 19:06:08' prior: 50603842 overrides: 50604865!
transactions
	|transactionList|
	transactionList := OrderedCollection new.
	accountsAndPortfolios do: [:member | 
		transactionList addAll: (member transactions)].
		
	^transactionList.
	! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/6/2022 21:59:11' prior: 50604386!
add: aMember 
	accountsAndPortfolios add: aMember.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/6/2022 21:44:22' prior: 50604150 overrides: 50604145!
initialize
	accountsAndPortfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:52'!
AccountType subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' prior: 50604157 overrides: 50604145!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37' prior: 50603883!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'TD 10/6/2022 20:46:25' prior: 50603888 overrides: 50604865!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'TD 10/6/2022 21:17:35' prior: 50603893 overrides: 50604861!
balance

	^transactions inject: 0 into: [ :balanceSum :aTransaction | aTransaction updateBalance: balanceSum].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/6/2022 21:17:56' prior: 50603900 overrides: 50604875!
hasRegistered: aTransaction

	^ transactions includes: aTransaction ! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:09:29' prior: 50603905!
test13portfolioCannotAddSameAccountTwice
	|portfolio account |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	
	self should: [portfolio add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:09:47' prior: 50603921!
repeatedAccountErrorDescription
	self shouldBeImplemented.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 13:10:06' prior: 50604990!
repeatedAccountErrorDescription
	^'cannot add an account multiple times!!'! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:11:16' prior: 50604921!
add: aMember
	(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	accountsAndPortfolios add: aMember.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:07'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:12:23' prior: 50603949!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!methodRemoval: PortfolioTest #test13portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:19:53'!
test13portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:17:01' prior: 50605001!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:42' prior: 50604409!
shouldNotLetAdding: aPortfolio 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:18:54' prior: 50605070!
shouldNotLetAdding: aMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:19:07' prior: 50605075!
shouldNotLetAdding: aCandidateMember 
	self shouldBeImplemented.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:21:10' prior: 50605080!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember has: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:21:19'!
has: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:22' prior: 50605095!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: [
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]]].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:25:54' prior: 50605100!
has: anOriginalMember
	|isContained|
	isContained := false.
	accountsAndPortfolios do: [:aMember | isContained := isContained or: ([
		((aMember isKindOf: Portfolio) ifTrue: [aMember has: anOriginalMember])] or: [(aMember isKindOf: ReceptiveAccount) ifTrue: [aMember = anOriginalMember]])].
	^isContained.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:31:18' prior: 50605113!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:35' prior: 50604380 overrides: 50604404!
contains: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:31:51' prior: 50605135 overrides: 50604404!
contains: aReceptiveAccount 
	^aReceptiveAccount = self! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 13:32:32' prior: 50604069 overrides: 50604404!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].! !

!methodRemoval: Portfolio #has: stamp: 'TD 10/17/2022 14:19:53'!
has: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: (aMember contains: anOriginalMember)].!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:33:23' prior: 50604099!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 13:34:02' prior: 50605162!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:34:37' prior: 50605086!
shouldNotLetAdding: aCandidateMember 
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self
	].
	(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
		^aCandidateMember = self.
	]! !

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:19:54'!
Object subclass: #AccountType
	instanceVariableNames: 'parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:38:44' prior: 50605192!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 13:39:39' prior: 50604145 overrides: 16920235!
initialize
	parent := self.! !
!Portfolio methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:48' prior: 50604927 overrides: 50605223!
initialize
	accountsAndPortfolios := OrderedCollection new.
	super initialize.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'TD 10/17/2022 13:39:57' prior: 50604949 overrides: 50605223!
initialize
	transactions := OrderedCollection new.
	super initialize.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:40:34' prior: 50605053!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		(accountsAndPortfolios includes: aMember) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:40:58' prior: 50604187!
parent: aPortfolio 
	self shouldBeImplemented.
	parent := aPortfolio! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:41:10' prior: 50605259!
parent: aPortfolio 
	parent := aPortfolio! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:46:10' prior: 50605141 overrides: 50604404!
contains: aReceptiveAccount 
	(aReceptiveAccount isKindOf: self class) ifTrue: [
		^ self = aReceptiveAccount
	].
	(aReceptiveAccount isKindOf: Portfolio) ifTrue: [
		^aReceptiveAccount contains: self.
	]! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:48:09' prior: 50605241!
add: aMember
	(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	].

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:28' prior: 50605210!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self or: [].
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:51:33' prior: 50605299!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^aCandidateMember = self.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50605312!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:53:51' prior: 50605280!
add: aMember

	aMember cannotBeAdded ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:54:08'!
cannotBeAdded
	self shouldBeImplemented.! !

!methodRemoval: ReceptiveAccount #cannotBeAdded stamp: 'TD 10/17/2022 14:19:54'!
cannotBeAdded
	self shouldBeImplemented.!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:54:45' prior: 50605338!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	"(aMember isKindOf: ReceptiveAccount) ifTrue:[
		((accountsAndPortfolios includes: aMember) or: [parent shouldNotLetAdding: aMember]) ifTrue: [^self error: self class repeatedAccountErrorDescription ].
	].
	(aMember isKindOf: Portfolio) ifTrue:[
		(accountsAndPortfolios anySatisfy: [:anAccountOrPortfolio | anAccountOrPortfolio shouldNotLetAdding: 		aMember]) ifTrue:[^self error: self class repeatedAccountErrorDescription].
	]."

	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:55:03' prior: 50604318 overrides: 50604399!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:56:23' prior: 50605392 overrides: 50604399!
cannotBeAddedTo: aPortfolio 
	^aPortfolio shouldNotLetAdding: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:56:37' prior: 50604328 overrides: 50604399!
cannotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 13:58:31' prior: 50605404 overrides: 50604399!
cannotBeAddedTo: aPortfolio 
	^aPortfolio contains: self.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:00:52' prior: 50605270 overrides: 50604404!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.
	"End of block expected ->(aCandidateMember isKindOf: self class) ifTrue: [
		^ self = aCandidateMember
	].
	(aCandidateMember isKindOf: Portfolio) ifTrue: [
		^aCandidateMember contains: self.
	]"! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:04' prior: 50604349 overrides: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:01:43' prior: 50605428 overrides: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	^self = aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:11' prior: 50604365 overrides: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:02:44' prior: 50605440 overrides: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:00' prior: 50605446 overrides: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	^self contains: aReceptiveAccount.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:20' prior: 50605369!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:03:45' prior: 50605416 overrides: 50604404!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:03:58' prior: 50605458!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	
	aMember parent: self.
	accountsAndPortfolios add: aMember.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 14:04:24' prior: 50604394!
alreadyBelongsTo: aReceptiveAccount 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:04:43' prior: 50604399!
cannotBeAddedTo: aPortfolio 
	self subclassResponsibility.! !
!AccountType methodsFor: 'testing' stamp: 'TD 10/17/2022 14:05:08' prior: 50604404!
contains: anOriginalMember
	self subclassResponsibility.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:06:57' prior: 50605325!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 13:52:23' prior: 50605497!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [
		(aCandidateMember isKindOf: Portfolio) ifTrue: [
			^aCandidateMember contains: self
		].
		(aCandidateMember isKindOf: ReceptiveAccount) ifTrue: [
			^self contains: aCandidateMember.
		]
	].

	^parent shouldNotLetAdding: aCandidateMember.! !
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:17:10' prior: 50605505!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:17:48'!
shouldNotBeAddedTo: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:18:33' overrides: 50605518!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !

!methodRemoval: AccountType #shouldNotLetAdding: stamp: 'TD 10/17/2022 14:19:55'!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ aCandidateMember shouldNotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.!

!methodRemoval: ReceptiveAccount #shouldNotBeAddedTo: stamp: 'TD 10/17/2022 14:19:55'!
shouldNotBeAddedTo: aPortfolio 
	self shouldBeImplemented.!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:19:28' prior: 50605531!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^aCandidateMember cannotBeAddedTo: self].
	
	^parent shouldNotLetAdding: aCandidateMember.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:20:28' prior: 50605398 overrides: 50605487!
cannotBeAddedTo: aPortfolio 
	^self alreadyBelongsTo: aPortfolio.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:20:56'!
FAILURE!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:20:56'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:20:56'!
FAILURE!
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 13:56:23' prior: 50605560 overrides: 50605487!
cannotBeAddedTo: aPortfolio 
	^aPortfolio shouldNotLetAdding: self.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:21:55' prior: 50605551!
shouldNotLetAdding: aCandidateMember 
	(parent = self) ifTrue: [ ^self contains: aCandidateMember].
	
	^parent shouldNotLetAdding: aCandidateMember.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:22:11'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:22:11'!
PASSED!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:22:40' prior: 50605630!
shouldNotLetAdding: aCandidateMember
	(parent = self) ifTrue: [^self contains: aCandidateMember].
	
	^parent shouldNotLetAdding: aCandidateMember.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:24:24'!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 portfolio3 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio3 := Portfolio new.
	portfolio add: portfolio2.
	portfolio3 add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:24:34'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:24:34'!
FAILURE!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:24:34'!
FAILURE!

Object subclass: #AccountType
	instanceVariableNames: 'parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountType category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 14:24:45'!
Object subclass: #AccountType
	instanceVariableNames: 'parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountType methodsFor: 'verification on add' stamp: 'TD 10/17/2022 14:25:16'!
addParent: aPortfolio 
	parents add: aPortfolio.! !
!AccountType methodsFor: 'nil' stamp: 'TD 10/17/2022 14:25:28' prior: 50605223 overrides: 16920235!
initialize
	parents := OrderedCollection new.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:26:26' prior: 50605697!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self contains: aCandidateMember].
	
	^parents do: [:aParent | aParent shouldNotLetAdding: aCandidateMember].! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:26:30'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:26:31'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:26:31'!
FAILURE!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:26:31'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:26:33'!
FAILURE!
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 14:27:21' prior: 50605473!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedAccountErrorDescription].
	
	aMember addParent: self.
	accountsAndPortfolios add: aMember.! !

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:27:22'!
FAILURE!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:27:26'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:27:26'!
FAILURE!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:27:26'!
FAILURE!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:27:28'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:30:54' prior: 50605812!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self contains: aCandidateMember].
	
	^parents inject: false into: [:permission :aParent | permission and: (aParent shouldNotLetAdding: aCandidateMember)].! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:31:01' prior: 50605968!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self contains: aCandidateMember].
	
	^parents inject: false into: [:permission :aParent | permission or: (aParent shouldNotLetAdding: aCandidateMember)].! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:31:06'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:31:07'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:31:07'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:31:07'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:31:07'!
PASSED!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:33:14'!
test17portfolioCannotAddEmptyPortfolioTwice
	|portfolio portfolio2 |
	
	portfolio := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:33:21' prior: 50606051!
test17portfolioCannotAddEmptyPortfolioTwice
	|portfolio portfolio2|
	
	portfolio := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedAccountErrorDescription.! !
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 14:34:01'!
repeatedEntityErrorDescription
	^'cannot add an account multiple times!!'! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:34:01' prior: 50605888!
add: aMember

	(aMember cannotBeAddedTo: self) ifTrue: [^self error: self class repeatedEntityErrorDescription].
	
	aMember addParent: self.
	accountsAndPortfolios add: aMember.! !

!methodRemoval: Portfolio class #repeatedAccountErrorDescription stamp: 'TD 10/17/2022 14:34:01'!
repeatedAccountErrorDescription
	^'cannot add an account multiple times!!'!
!Portfolio class methodsFor: 'error messages' stamp: 'TD 10/17/2022 14:34:27' prior: 50606075!
repeatedEntityErrorDescription
	^'cannot add an entity multiple times!!'! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:34:48' prior: 50604978!
test13portfolioCannotAddSameAccountTwice
	|portfolio account |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	
	self should: [portfolio add: account] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:34:54' prior: 50605024!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio2 add: account.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:34:57' prior: 50605177!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:35:00' prior: 50605705!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio account portfolio2 portfolio3 |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	portfolio add: account.	
	portfolio2 := Portfolio new.
	portfolio3 := Portfolio new.
	portfolio add: portfolio2.
	portfolio3 add: portfolio2.
	
	self should: [portfolio2 add: account] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:35:02' prior: 50606063!
test17portfolioCannotAddEmptyPortfolioTwice
	|portfolio portfolio2|
	
	portfolio := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:35:05'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:05'!
FAILURE!

!testRun: #PortfolioTest #test17portfolioCannotAddEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:05'!
FAILURE!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:35:20'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:35:20'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:35:20'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:35:20'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:35:21'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:21'!
FAILURE!

!testRun: #PortfolioTest #test17portfolioCannotAddEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:21'!
FAILURE!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:35:35'!
test17portfolioCannotAddSameEmptyPortfolioTwice
	|portfolio portfolio2|
	
	portfolio := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!methodRemoval: PortfolioTest #test17portfolioCannotAddEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:36'!
test17portfolioCannotAddEmptyPortfolioTwice
	|portfolio portfolio2|
	
	portfolio := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio add: portfolio2.
	
	self should: [portfolio add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:41'!
FAILURE!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:35:41'!
FAILURE!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:36:54' prior: 50605147 overrides: 50605492!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember contains: anOriginalMember) or: aMember = anOriginalMember)].! !

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:36:58'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:37:00'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:52:27'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 14:52:28'!
PASSED!

----SNAPSHOT----(17 October 2022 14:53:11) CuisUniversity-5481.image priorSource: 8580298!

!classRenamed: #AccountType as: #AccountableAsset stamp: 'TD 10/17/2022 14:54:12'!
Smalltalk renameClassNamed: #AccountType as: #AccountableAsset!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:54:30' prior: 50604534!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!AccountableAsset methodsFor: 'testing' stamp: 'TD 10/17/2022 14:59:36'!
alreadyIncludes: anOriginalMember
	self subclassResponsibility.! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:59:36' overrides: 50606530!
alreadyIncludes: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember contains: anOriginalMember) or: aMember = anOriginalMember)].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:59:37' overrides: 50606530!
alreadyIncludes: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605410 overrides: 50605487!
cannotBeAddedTo: aPortfolio 
	^aPortfolio alreadyIncludes: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50606347 overrides: 50605492!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605452 overrides: 50605482!
alreadyBelongsTo: aReceptiveAccount 
	^self alreadyIncludes: aReceptiveAccount.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605978!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self alreadyIncludes: aCandidateMember].
	
	^parents inject: false into: [:permission :aParent | permission or: (aParent shouldNotLetAdding: aCandidateMember)].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50606535 overrides: 50606530!
alreadyIncludes: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].! !

!methodRemoval: AccountableAsset #contains: stamp: 'TD 10/17/2022 14:59:37'!
contains: anOriginalMember
	self subclassResponsibility.!

!methodRemoval: Portfolio #contains: stamp: 'TD 10/17/2022 14:59:37'!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].!

!methodRemoval: ReceptiveAccount #contains: stamp: 'TD 10/17/2022 14:59:37'!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 15:02:17' prior: 50606574!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self alreadyIncludes: aCandidateMember].
	
	^parents inject: false into: [:disallow :aParent | disallow or: (aParent shouldNotLetAdding: aCandidateMember)].! !

!methodRemoval: AccountableAsset #parent: stamp: 'TD 10/17/2022 15:03:49'!
parent: aPortfolio 
	parent := aPortfolio!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:03:52'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:03:53'!
PASSED!

TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3 testTransaction1 testTransaction2 testTransaction3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:07:13'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3 testTransaction1 testTransaction2 testTransaction3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:08:53' overrides: 16961394!
setUp

	testAccount1 := ReceptiveAccount new.
	testAccount2 := ReceptiveAccount new.
	testAccount3 := ReceptiveAccount new.
	
	testPortfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !

TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:09:14'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:09:27' prior: 50604432!
test01emptyPortfolioHasZeroBalance

	self assert: 0 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:10:07' prior: 50604439!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: 50 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:10:17' prior: 50606747!
test02portfolioWith1AccountHasAccountBalance
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: 50 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:11:26' prior: 50604450!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	portfolio := Portfolio new.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:11:41' prior: 50606765!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:11:43'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:11:44'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:11:44'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:19' prior: 50604468!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:28' prior: 50604514!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: testAccount2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:31' prior: 50606502!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:33' prior: 50604583!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:40' prior: 50604608!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:44' prior: 50606861!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	Deposit register: 50 on: account.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:05' prior: 50606982!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:13' prior: 50606999!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:23:14'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:23:14'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:23:14'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:23:15'!
FAILURE!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:23:15'!
FAILURE!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:23:15'!
FAILURE!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:23:15'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:23:15'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:41' prior: 50604489!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self deny: (portfolio hasRegistered: transaction).! !

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:23:44'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:58' prior: 50607098!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction account|
	transaction := Deposit register: 50 on: account.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:01' prior: 50607114!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction account|
	transaction := Deposit register: 50 on: account.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:07' prior: 50607123!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction |
	transaction := Deposit register: 50 on: testAccount1.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:24:10'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:39' prior: 50604501!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:44' prior: 50607145!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:49' prior: 50607156!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testPortfolio1 hasRegistered: transaction).! !

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:24:53'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:25' prior: 50606882!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: testAccount2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:44' prior: 50607182!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:55' prior: 50607198!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:59' prior: 50607214!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction2)! !

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:26:00'!
FAILURE!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:26:00'!
FAILURE!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:26:00'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:26:01'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:26:01'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:26:01'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:26:01'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:26:04'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:24' prior: 50606901!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account2 transaction2 portfolio1 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:43' prior: 50607319!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:50' prior: 50607344!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:53' prior: 50607367!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:26:56'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:03' prior: 50607390!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:14' prior: 50607229!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:33' prior: 50604562!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	

	self assert: (OrderedCollection new) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:35' prior: 50607456!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	
	self assert: (OrderedCollection new) equals: testPortfolio1 transactions.! !

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:27:37'!
FAILURE!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:27:37'!
FAILURE!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:27:37'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:27:37'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:02' prior: 50604571!
test10portfolioWithOneAccountHasAccountsTransactions
	
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testAccount1 transactions) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:15' prior: 50607541!
test10portfolioWithOneAccountHasAccountsTransactions
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testAccount1 transactions) equals: testPortfolio1 transactions.! !

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:28:17'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:42' prior: 50606929!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:50' prior: 50607565!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:28:52'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:28:58'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:28:59'!
FAILURE!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:28:59'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:28:59'!
FAILURE!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:29:47' prior: 50606954!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:29:55' prior: 50607684!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:30:00'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:30:29' prior: 50606102!
test13portfolioCannotAddSameAccountTwice
	
	
	testPortfolio1 add: testAccount1.	
	
	self should: [testPortfolio1 add: testAccount1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:30:33' prior: 50607737!
test13portfolioCannotAddSameAccountTwice
	
	testPortfolio1 add: testAccount1.	
	
	self should: [testPortfolio1 add: testAccount1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:30:35'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:31:17' prior: 50606114!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio2 add: testAccount1.
		
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:31:22' prior: 50607760!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	testPortfolio1 add: testAccount1.
	testPortfolio2 add: testAccount1.
		
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:31:24'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:32:10' prior: 50606129!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:32:15' prior: 50607786!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:32:16'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:45' prior: 50606144!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio2 portfolio3 |
	
	testPortfolio1 add: testAccount1.
	portfolio2 := Portfolio new.
	portfolio3 := Portfolio new.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:55' prior: 50607812!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:59' prior: 50607828!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:34:01'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:09' prior: 50607841!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio3 add: testPortfolio2.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:34:10'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:37' prior: 50606315!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:42' prior: 50607877!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:34:43'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:35:39'!
test18cannotSelfAddPortfolio
	self should: [testPortfolio1 add: testPortfolio1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:35:41'!
FAILURE!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:35:41'!
FAILURE!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:36:17'!
FAILURE!
!Portfolio methodsFor: 'adding - private' stamp: 'TD 10/17/2022 15:37:03' prior: 50606585 overrides: 50606530!
alreadyIncludes: anOriginalMember
	
	^anOriginalMember = self or: (accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)]).! !

----STARTUP---- (17 October 2022 15:38:52) as C:\Users\tomas\Desktop\FACULTAD\Inge1\windows64\CuisUniversity-5481.image!

!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:54:30' prior: 50604534!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 14:59:36'!
alreadyIncludes: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember contains: anOriginalMember) or: aMember = anOriginalMember)].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'TD 10/17/2022 14:59:37'!
alreadyIncludes: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605410 overrides: 50605487!
cannotBeAddedTo: aPortfolio 
	^aPortfolio alreadyIncludes: self.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50606347 overrides: 50605492!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605452 overrides: 50605482!
alreadyBelongsTo: aReceptiveAccount 
	^self alreadyIncludes: aReceptiveAccount.! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50605978!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self alreadyIncludes: aCandidateMember].
	
	^parents inject: false into: [:permission :aParent | permission or: (aParent shouldNotLetAdding: aCandidateMember)].! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 14:59:37' prior: 50607961!
alreadyIncludes: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].! !

!methodRemoval: Portfolio #contains: stamp: 'TD 10/17/2022 15:38:58'!
contains: anOriginalMember
	
	^accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)].!

!methodRemoval: ReceptiveAccount #contains: stamp: 'TD 10/17/2022 15:38:58'!
contains: aCandidateMember	

	^aCandidateMember alreadyBelongsTo: self.!
!Portfolio methodsFor: 'information' stamp: 'TD 10/17/2022 15:02:17' prior: 50607999!
shouldNotLetAdding: aCandidateMember
	(parents isEmpty) ifTrue: [^self alreadyIncludes: aCandidateMember].
	
	^parents inject: false into: [:disallow :aParent | disallow or: (aParent shouldNotLetAdding: aCandidateMember)].! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:38:58'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3 testTransaction1 testTransaction2 testTransaction3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:38:58'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3 testTransaction1 testTransaction2 testTransaction3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:08:53' overrides: 16961394!
setUp

	testAccount1 := ReceptiveAccount new.
	testAccount2 := ReceptiveAccount new.
	testAccount3 := ReceptiveAccount new.
	
	testPortfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:38:58'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:38:58'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'testAccount1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:09:27' prior: 50604432!
test01emptyPortfolioHasZeroBalance

	self assert: 0 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:10:07' prior: 50604439!
test02portfolioWith1AccountHasAccountBalance
	|portfolio account |
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: 50 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:10:17' prior: 50608104!
test02portfolioWith1AccountHasAccountBalance
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: 50 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:11:26' prior: 50604450!
test03portfolioWithManyAccountsHasAccountSumBalance
	|portfolio |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	portfolio := Portfolio new.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:11:41' prior: 50608122!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:19' prior: 50604468!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:28' prior: 50604514!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 account2 transaction2 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: testAccount2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:31' prior: 50607933!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account1 account2 transaction2 portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:33' prior: 50604583!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:40' prior: 50604608!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio account account1 account2 transactionList portfolio1 |
	
	account := ReceptiveAccount new.
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Deposit register: 100 on: account1.
	
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	Withdraw register: 75 on: account2.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: account2 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:21:44' prior: 50608151!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	|portfolio account account1 account2 portfolio1 |
	
	Deposit register: 50 on: account.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: 75 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:05' prior: 50608272!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:13' prior: 50608289!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:41' prior: 50604489!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|portfolio transaction account|
	
	account := ReceptiveAccount new.
	transaction := Deposit register: 50 on: account.
	portfolio := Portfolio new.
	
	self deny: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:23:58' prior: 50608320!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction account|
	transaction := Deposit register: 50 on: account.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:01' prior: 50608331!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction account|
	transaction := Deposit register: 50 on: account.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:07' prior: 50608340!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction |
	transaction := Deposit register: 50 on: testAccount1.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:39' prior: 50604501!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: true equals: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:44' prior: 50608358!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|portfolio transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (portfolio hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:24:49' prior: 50608369!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|transaction |
	
	transaction := Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:25' prior: 50608172!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio account account1 transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	portfolio := Portfolio new.
	portfolio add: account.
	portfolio add: account1.
	portfolio add: testAccount2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:44' prior: 50608390!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|portfolio transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: true equals: (portfolio hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:55' prior: 50608406!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:25:59' prior: 50608422!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction2)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:24' prior: 50608191!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio account account2 transaction2 portfolio1 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: account2.
	portfolio := Portfolio new.
	portfolio1 := Portfolio new.
	portfolio add: account.
	portfolio add: testAccount2.
	portfolio1 add: account2.
	portfolio add: portfolio1.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:43' prior: 50608452!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|portfolio transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (portfolio hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:50' prior: 50608477!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:26:53' prior: 50608500!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction2 |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction2 := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction2).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:03' prior: 50608523!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:14' prior: 50608437!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:33' prior: 50604562!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	

	self assert: (OrderedCollection new) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:27:35' prior: 50608584!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	
	self assert: (OrderedCollection new) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:02' prior: 50604571!
test10portfolioWithOneAccountHasAccountsTransactions
	
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testAccount1 transactions) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:15' prior: 50608598!
test10portfolioWithOneAccountHasAccountsTransactions
	
	Deposit register: 50 on: testAccount1 .
	testPortfolio1 add: testAccount1.
	
	self assert: (testAccount1 transactions) equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:42' prior: 50608219!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|portfolio transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:28:50' prior: 50608618!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:29:47' prior: 50608244!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|portfolio transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: portfolio transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:29:55' prior: 50608661!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: testAccount1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: testAccount1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:30:29' prior: 50606102!
test13portfolioCannotAddSameAccountTwice
	
	
	testPortfolio1 add: testAccount1.	
	
	self should: [testPortfolio1 add: testAccount1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:30:33' prior: 50608709!
test13portfolioCannotAddSameAccountTwice
	
	testPortfolio1 add: testAccount1.	
	
	self should: [testPortfolio1 add: testAccount1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:31:17' prior: 50606114!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio2 add: testAccount1.
		
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:31:22' prior: 50608729!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	testPortfolio1 add: testAccount1.
	testPortfolio2 add: testAccount1.
		
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:32:10' prior: 50606129!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:32:15' prior: 50608751!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:45' prior: 50606144!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	|portfolio2 portfolio3 |
	
	testPortfolio1 add: testAccount1.
	portfolio2 := Portfolio new.
	portfolio3 := Portfolio new.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:55' prior: 50608773!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:33:59' prior: 50608789!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio1 add: testPortfolio2.
	testPortfolio3 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:09' prior: 50608802!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: testAccount1.
	testPortfolio3 add: testPortfolio2.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: testAccount1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:37' prior: 50606315!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:34:42' prior: 50608828!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:35:39'!
test18cannotSelfAddPortfolio
	self should: [testPortfolio1 add: testPortfolio1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!Portfolio methodsFor: 'adding - private' stamp: 'TD 10/17/2022 15:37:03' prior: 50608010!
alreadyIncludes: anOriginalMember
	
	^anOriginalMember = self or: (accountsAndPortfolios inject: false into: 
	[:isContained :aMember | isContained or: ((aMember alreadyIncludes: anOriginalMember) or: aMember = anOriginalMember)]).! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:39:13' prior: 50608847!
test18cannotSelfAddPortfolio

	self should: [testPortfolio1 add: testPortfolio1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!Portfolio methodsFor: 'accounts - private' stamp: 'TD 10/17/2022 15:39:54' prior: 50607977 overrides: 50605487!
cannotBeAddedTo: aPortfolio 
	^aPortfolio = self or: (aPortfolio alreadyIncludes: self).! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:39:56'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:39:57'!
PASSED!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:40:09'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:40:10'!
PASSED!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:40:21'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 testAccount2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:21' prior: 50608569!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608815!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: account1.
	testPortfolio3 add: testPortfolio2.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: account1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608719!
test13portfolioCannotAddSameAccountTwice
	
	testPortfolio1 add: account1.	
	
	self should: [testPortfolio1 add: account1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608762!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	testPortfolio1 add: account1.
	testPortfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: account1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608740!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	testPortfolio1 add: account1.
	testPortfolio2 add: account1.
		
	self should: [testPortfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608640!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608349!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction |
	transaction := Deposit register: 50 on: account1.
	
	self deny: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608067 overrides: 16961394!
setUp

	account1 := ReceptiveAccount new.
	testAccount2 := ReceptiveAccount new.
	testAccount3 := ReceptiveAccount new.
	
	testPortfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608685!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: testAccount2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608113!
test02portfolioWith1AccountHasAccountBalance
	
	Deposit register: 50 on: account1 .
	testPortfolio1 add: account1.
	
	self assert: 50 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608137!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608546!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608305!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: account1.
	Deposit register: 100 on: testAccount2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: testAccount2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608380!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|transaction |
	
	transaction := Deposit register: 50 on: account1 .
	testPortfolio1 add: account1.
	
	self assert: (testPortfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:22' prior: 50608608!
test10portfolioWithOneAccountHasAccountsTransactions
	
	Deposit register: 50 on: account1 .
	testPortfolio1 add: account1.
	
	self assert: (account1 transactions) equals: testPortfolio1 transactions.! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:40:26'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 testAccount3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609031!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: testAccount3.
	
	self assert: (testPortfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609180!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609133!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609166!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: testAccount3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609122 overrides: 16961394!
setUp

	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	testAccount3 := ReceptiveAccount new.
	
	testPortfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609203!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: testAccount3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: testAccount3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:27' prior: 50609091!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: testAccount3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: testAccount3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: testAccount3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:40:31'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 testPortfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609250!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: account3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: account3.
	
	self assert: (testPortfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609265!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: account3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: account3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: true equals: (testPortfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609288!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: account3.
	testPortfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: account3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: account3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609312!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: account3.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609326 overrides: 16961394!
setUp

	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	account3 := ReceptiveAccount new.
	
	testPortfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:31' prior: 50609337!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio2 add: account3.
	testPortfolio1 add: testPortfolio2.
	
	self assert: 75 equals: testPortfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:32' prior: 50609352!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	
	testPortfolio1 add: account1.
	testPortfolio1 add: account2.
	testPortfolio1 add: account3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: account3 transactions.
	
	self assert: transactionList equals: testPortfolio1 transactions.! !

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:40:43'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 portfolio1 testPortfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50608098!
test01emptyPortfolioHasZeroBalance

	self assert: 0 equals: portfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609219!
test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount
	|transaction |
	
	transaction := Deposit register: 50 on: account1 .
	portfolio1 add: account1.
	
	self assert: (portfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609421!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	testPortfolio2 add: account3.
	portfolio1 add: testPortfolio2.
	
	Withdraw register: 75 on: account3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: account3 transactions.
	
	self assert: transactionList equals: portfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609458 overrides: 16961394!
setUp

	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	account3 := ReceptiveAccount new.
	
	portfolio1 := Portfolio new.
	testPortfolio2 := Portfolio new.
	testPortfolio3 := Portfolio new.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609157!
test02portfolioWith1AccountHasAccountBalance
	
	Deposit register: 50 on: account1 .
	portfolio1 add: account1.
	
	self assert: 50 equals: portfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50608838!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	portfolio1 add: testPortfolio2.
	
	self should: [portfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50608865!
test18cannotSelfAddPortfolio

	self should: [portfolio1 add: portfolio1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609444!
test03portfolioWithManyAccountsHasAccountSumBalance
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio1 add: account3.
	
	self assert: 75 equals: portfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609059!
test13portfolioCannotAddSameAccountTwice
	
	portfolio1 add: account1.	
	
	self should: [portfolio1 add: account1.	] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609080!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	portfolio1 add: account1.
	testPortfolio2 add: account1.
		
	self should: [portfolio1 add: testPortfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609112!
test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered
	|transaction |
	transaction := Deposit register: 50 on: account1.
	
	self deny: (portfolio1 hasRegistered: transaction).! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609069!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	portfolio1 add: account1.
	portfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: account1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609398!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	testPortfolio2 add: account3.
	portfolio1 add: testPortfolio2.
	
	self assert: true equals: (portfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609230!
test10portfolioWithOneAccountHasAccountsTransactions
	
	Deposit register: 50 on: account1 .
	portfolio1 add: account1.
	
	self assert: (account1 transactions) equals: portfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609468!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	testPortfolio2 add: account3.
	portfolio1 add: testPortfolio2.
	
	self assert: 75 equals: portfolio1 balance.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609483!
test11portfolioWithManyAccountsHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio1 add: account3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: account3 transactions.
	
	self assert: transactionList equals: portfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50608591!
test09portfolioWithNoAccountsDoesNotHaveTransactions
	
	self assert: (OrderedCollection new) equals: portfolio1 transactions.! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609383!
test07portfolioWithManyAccountsHasSomeAccountsTransaction
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio1 add: account3.
	
	self assert: (portfolio1 hasRegistered: transaction)! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'TD 10/17/2022 15:40:43' prior: 50609046!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	portfolio1 add: account1.
	testPortfolio3 add: testPortfolio2.
	portfolio1 add: testPortfolio2.
	
	self should: [testPortfolio2 add: account1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 portfolio1 portfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:40:59'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 portfolio1 portfolio2 testPortfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 portfolio1 portfolio2 portfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: 'Portfolio-Ejercicio' stamp: 'TD 10/17/2022 15:41:15'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: 'account1 account2 account3 portfolio1 portfolio2 portfolio3'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:41:46' prior: 50609644!
test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio
	|transaction |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	transaction := Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio2 add: account3.
	portfolio1 add: portfolio2.
	
	self assert: true equals: (portfolio1 hasRegistered: transaction).
	
	"Nos jugo en contra aca el hecho de tener una sola coleccion para elementos de tipo abstracto AccountableAsset por eso este test paso de una, pero basicamente va a buscar a las hojas."! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:41:58' prior: 50609529!
test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll
	|transactionList |
	
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio2 add: account3.
	portfolio1 add: portfolio2.
	
	Withdraw register: 75 on: account3.
	
	transactionList := OrderedCollection new.
	transactionList addAll: account1 transactions.
	transactionList addAll: account2 transactions.
	transactionList addAll: account3 transactions.
	
	self assert: transactionList equals: portfolio1 transactions.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:42:09' prior: 50609676!
test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance
	Deposit register: 50 on: account1.
	Deposit register: 100 on: account2.
	Withdraw register: 75 on: account3.
	portfolio1 add: account1.
	portfolio1 add: account2.
	portfolio2 add: account3.
	portfolio1 add: portfolio2.
	
	self assert: 75 equals: portfolio1 balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:42:20' prior: 50609572!
test17portfolioCannotAddSameEmptyPortfolioTwice
	
	portfolio1 add: portfolio2.
	
	self should: [portfolio1 add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:42:36' prior: 50609733!
test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio
	
	portfolio1 add: account1.
	portfolio3 add: portfolio2.
	portfolio1 add: portfolio2.
	
	self should: [portfolio2 add: account1] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:42:39' prior: 50609633!
test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio
	
	portfolio1 add: account1.
	portfolio1 add: portfolio2.
	
	self should: [portfolio2 add: account1 ] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !
!PortfolioTest methodsFor: 'tests' stamp: 'TD 10/17/2022 15:42:43' prior: 50609613!
test14portfolioCannotAddAPortfolioWithAnAccountItHas
	
	portfolio1 add: account1.
	portfolio2 add: account1.
		
	self should: [portfolio1 add: portfolio2] raise: Error withMessageText: Portfolio repeatedEntityErrorDescription.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:42:53'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:42:53'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:42:53'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:42:53'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:42:54'!
ERROR!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:42:54'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:42:57'!
ERROR!

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:43:05'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:43:05'!
ERROR!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:43:06'!
PASSED!
!PortfolioTest methodsFor: 'set up' stamp: 'TD 10/17/2022 15:43:35' prior: 50609553 overrides: 16961394!
setUp

	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	account3 := ReceptiveAccount new.
	
	portfolio1 := Portfolio new.
	portfolio2 := Portfolio new.
	portfolio3 := Portfolio new.! !

!testRun: #PortfolioTest #test01emptyPortfolioHasZeroBalance stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test02portfolioWith1AccountHasAccountBalance stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test03portfolioWithManyAccountsHasAccountSumBalance stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test04portfolioWithManyAccountsAndPortfoliosHasAccountAndPortfolioSumBalance stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithNoAccountsDoesNotHaveATransactionRegistered stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithOneAccountHasTheSameTransactionAsTheAccount stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test07portfolioWithManyAccountsHasSomeAccountsTransaction stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithManyAccountsAndPortfoliosHasATransactionInsideAPortfolio stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithNoAccountsDoesNotHaveTransactions stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test10portfolioWithOneAccountHasAccountsTransactions stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test11portfolioWithManyAccountsHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test12portfolioWithManyAccountsAndPortfoliosHasAccountsTransactionsInAll stamp: 'TD 10/17/2022 15:43:37'!
PASSED!

!testRun: #PortfolioTest #test13portfolioCannotAddSameAccountTwice stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

!testRun: #PortfolioTest #test14portfolioCannotAddAPortfolioWithAnAccountItHas stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

!testRun: #PortfolioTest #test15portfolioCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

!testRun: #PortfolioTest #test16portfolioWithMultipleParentsCannotAddAccountAlreadyHadByAParentPortfolio stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

!testRun: #PortfolioTest #test17portfolioCannotAddSameEmptyPortfolioTwice stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

!testRun: #PortfolioTest #test18cannotSelfAddPortfolio stamp: 'TD 10/17/2022 15:43:38'!
PASSED!

----QUIT----(17 October 2022 15:43:47) CuisUniversity-5481.image priorSource: 8794964!